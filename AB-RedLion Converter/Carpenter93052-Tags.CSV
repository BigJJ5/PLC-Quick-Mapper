remark,"CSV-Import-Export"
remark,"Date = Mon Aug 28 07:30:52 2017"
remark,"Version = RSLogix 5000 v21.00"
remark,"Owner = jjablonowski"
remark,"Company = Revere Control System"
0.3
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,,BO5ExtendedApron:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO5ExtendedApron:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,ChutefeedFeedroll:C,"","AB:ETHERNET_MODULE:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,ChutefeedFeedroll:I,"","AB:ETHERNET_MODULE_INT_20Bytes:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,ChutefeedFeedroll:O,"","AB:ETHERNET_MODULE_INT_20Bytes:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,FOOutfeedFan:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,FOOutfeedFan:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,CCP:10:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,CCP:10:I,"","","CCP:I.Data[10]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,CCP:10:O,"","","CCP:O.Data[10]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,CCP:11:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,CCP:11:I,"","","CCP:I.Data[11]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,CCP:11:O,"","","CCP:O.Data[11]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,CCP:12:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,CCP:12:I,"","","CCP:I.Data[12]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,CCP:12:O,"","","CCP:O.Data[12]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,CCP:13:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,CCP:13:I,"","","CCP:I.Data[13]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,CCP:13:O,"","","CCP:O.Data[13]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,CCP:1:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CCP:1:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CCP:2:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CCP:2:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CCP:3:I,"","AB:1734_OB8S_Safety1:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CCP:3:O,"","AB:1734_OB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CCP:4:I,"","AB:1734_OB8S_Safety1:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CCP:4:O,"","AB:1734_OB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CCP:5:C,"","AB:1734_OE2:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,CCP:5:I,"","AB:1734_OE2:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,CCP:5:O,"","AB:1734_OE2:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,CCP:6:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,CCP:6:I,"","","CCP:I.Data[6]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,CCP:7:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,CCP:7:I,"","","CCP:I.Data[7]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,CCP:8:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,CCP:8:I,"","","CCP:I.Data[8]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,CCP:9:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,CCP:9:I,"","","CCP:I.Data[9]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,CCP:I,"","AB:1734_14SLOT:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,CCP:O,"","AB:1734_14SLOT:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,B1BlendConveyor:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,B1BlendConveyor:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,OBCP:10:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OBCP:10:I,"","","OBCP:I.Data[10]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OBCP:11:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OBCP:11:I,"","","OBCP:I.Data[11]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OBCP:12:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OBCP:12:I,"","","OBCP:I.Data[12]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OBCP:13:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OBCP:13:I,"","","OBCP:I.Data[13]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OBCP:14:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OBCP:14:I,"","","OBCP:I.Data[14]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OBCP:15:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OBCP:15:I,"","","OBCP:I.Data[15]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OBCP:16:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OBCP:16:I,"","","OBCP:I.Data[16]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,OBCP:16:O,"","","OBCP:O.Data[16]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OBCP:17:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OBCP:17:I,"","","OBCP:I.Data[17]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,OBCP:17:O,"","","OBCP:O.Data[17]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OBCP:18:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OBCP:18:I,"","","OBCP:I.Data[18]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,OBCP:18:O,"","","OBCP:O.Data[18]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OBCP:19:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OBCP:19:I,"","","OBCP:I.Data[19]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,OBCP:19:O,"","","OBCP:O.Data[19]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OBCP:1:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OBCP:1:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OBCP:2:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OBCP:2:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OBCP:3:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OBCP:3:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OBCP:4:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OBCP:4:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OBCP:5:I,"","AB:1734_OB8S_Safety1:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OBCP:5:O,"","AB:1734_OB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OBCP:6:I,"","AB:1734_OB8S_Safety1:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OBCP:6:O,"","AB:1734_OB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OBCP:7:I,"","AB:1734_OB8S_Safety1:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OBCP:7:O,"","AB:1734_OB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OBCP:8:I,"","AB:1734_OB8S_Safety1:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OBCP:8:O,"","AB:1734_OB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OBCP:9:I,"","AB:1734_OB8S_Safety1:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OBCP:9:O,"","AB:1734_OB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OBCP:I,"","AB:1734_20SLOT:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,OBCP:O,"","AB:1734_20SLOT:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,FS51ReserveSiloFeedroll:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,FS51ReserveSiloFeedroll:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TransportBelt:C,"","AB:ETHERNET_MODULE:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TransportBelt:I,"","AB:ETHERNET_MODULE_INT_20Bytes:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TransportBelt:O,"","AB:ETHERNET_MODULE_INT_20Bytes:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO4ExtendedApron:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO4ExtendedApron:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO1LiftApron:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO1LiftApron:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO3LoadApron:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO3LoadApron:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,DrafterGroup1:C,"","AB:ETHERNET_MODULE:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,DrafterGroup1:I,"","AB:ETHERNET_MODULE_INT_20Bytes:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,DrafterGroup1:O,"","AB:ETHERNET_MODULE_INT_20Bytes:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,DrafterGroup3:C,"","AB:ETHERNET_MODULE:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,DrafterGroup3:I,"","AB:ETHERNET_MODULE_INT_20Bytes:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,DrafterGroup3:O,"","AB:ETHERNET_MODULE_INT_20Bytes:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,ChutefeedVentilators:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,ChutefeedVentilators:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO3ExtendedApron:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO3ExtendedApron:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,OB2RP:1:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OB2RP:1:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OB2RP:2:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OB2RP:2:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OB2RP:3:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB2RP:3:I,"","","OB2RP:I.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,OB2RP:3:O,"","","OB2RP:O.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB2RP:4:C,"","AB:1734_IE2:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,OB2RP:4:I,"","AB:1734_IE2:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,OB2RP:5:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB2RP:5:I,"","","OB2RP:I.Data[5]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB2RP:6:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB2RP:6:I,"","","OB2RP:I.Data[6]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB2RP:7:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB2RP:7:I,"","","OB2RP:I.Data[7]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,OB2RP:7:O,"","","OB2RP:O.Data[7]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB2RP:8:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB2RP:8:I,"","","OB2RP:I.Data[8]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,OB2RP:8:O,"","","OB2RP:O.Data[8]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB2RP:I,"","AB:1734_9SLOT:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,OB2RP:O,"","AB:1734_9SLOT:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,Worker:C,"","AB:ETHERNET_MODULE:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,Worker:I,"","AB:ETHERNET_MODULE_INT_20Bytes:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,Worker:O,"","AB:ETHERNET_MODULE_INT_20Bytes:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO2LoadApron:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO2LoadApron:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO5LoadApron:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO5LoadApron:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,FeedRoll:C,"","AB:ETHERNET_MODULE:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,FeedRoll:I,"","AB:ETHERNET_MODULE_INT_20Bytes:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,FeedRoll:O,"","AB:ETHERNET_MODULE_INT_20Bytes:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,CRP1:1:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CRP1:1:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CRP1:2:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CRP1:2:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CRP1:3:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CRP1:3:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CRP1:4:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CRP1:4:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CRP1:5:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CRP1:5:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CRP1:6:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CRP1:6:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CRP1:7:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CRP1:7:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CRP1:8:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CRP1:8:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CRP1:9:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CRP1:9:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CRP1:I,"","AB:1734_10SLOT:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,CRP1:O,"","AB:1734_10SLOT:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,MainCylinder:C,"","AB:ETHERNET_MODULE:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,MainCylinder:I,"","AB:ETHERNET_MODULE_INT_20Bytes:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,MainCylinder:O,"","AB:ETHERNET_MODULE_INT_20Bytes:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,OB5RP:1:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OB5RP:1:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OB5RP:2:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OB5RP:2:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OB5RP:3:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB5RP:3:I,"","","OB5RP:I.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,OB5RP:3:O,"","","OB5RP:O.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB5RP:4:C,"","AB:1734_IE2:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,OB5RP:4:I,"","AB:1734_IE2:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,OB5RP:5:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB5RP:5:I,"","","OB5RP:I.Data[5]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB5RP:6:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB5RP:6:I,"","","OB5RP:I.Data[6]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB5RP:7:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB5RP:7:I,"","","OB5RP:I.Data[7]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,OB5RP:7:O,"","","OB5RP:O.Data[7]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB5RP:8:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB5RP:8:I,"","","OB5RP:I.Data[8]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,OB5RP:8:O,"","","OB5RP:O.Data[8]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB5RP:I,"","AB:1734_9SLOT:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,OB5RP:O,"","AB:1734_9SLOT:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,DeliveryRoll:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,DeliveryRoll:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,RH2LiftApron:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,RH2LiftApron:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,RH2RP:1:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,RH2RP:1:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,RH2RP:2:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,RH2RP:2:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,RH2RP:3:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,RH2RP:3:I,"","","RH2RP:I.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,RH2RP:3:O,"","","RH2RP:O.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,RH2RP:4:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,RH2RP:4:I,"","","RH2RP:I.Data[4]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,RH2RP:5:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,RH2RP:5:I,"","","RH2RP:I.Data[5]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,RH2RP:6:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,RH2RP:6:I,"","","RH2RP:I.Data[6]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,RH2RP:6:O,"","","RH2RP:O.Data[6]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,RH2RP:7:C,"","AB:1734_DO4:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,RH2RP:7:O,"","","RH2RP:O.Data[7]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,RH2RP:I,"","AB:1734_8SLOT:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,RH2RP:O,"","AB:1734_8SLOT:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,PLCCP:10:C,"","AB:1734_OE2:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,PLCCP:10:I,"","AB:1734_OE2:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,PLCCP:10:O,"","AB:1734_OE2:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,PLCCP:11:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,PLCCP:11:I,"","","PLCCP:I.Data[11]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,PLCCP:12:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,PLCCP:12:I,"","","PLCCP:I.Data[12]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,PLCCP:13:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,PLCCP:13:I,"","","PLCCP:I.Data[13]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,PLCCP:14:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,PLCCP:14:I,"","","PLCCP:I.Data[14]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,PLCCP:15:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,PLCCP:15:I,"","","PLCCP:I.Data[15]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,PLCCP:15:O,"","","PLCCP:O.Data[15]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,PLCCP:16:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,PLCCP:16:I,"","","PLCCP:I.Data[16]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,PLCCP:16:O,"","","PLCCP:O.Data[16]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,PLCCP:17:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,PLCCP:17:I,"","","PLCCP:I.Data[17]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,PLCCP:17:O,"","","PLCCP:O.Data[17]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,PLCCP:18:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,PLCCP:18:I,"","","PLCCP:I.Data[18]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,PLCCP:18:O,"","","PLCCP:O.Data[18]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,PLCCP:19:C,"","AB:1734_DO4:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,PLCCP:19:O,"","","PLCCP:O.Data[19]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,PLCCP:1:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,PLCCP:1:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,PLCCP:20:C,"","AB:1734_DO4:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,PLCCP:20:O,"","","PLCCP:O.Data[20]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,PLCCP:21:C,"","AB:1734_DO4:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,PLCCP:21:O,"","","PLCCP:O.Data[21]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,PLCCP:22:C,"","AB:1734_DO4:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,PLCCP:22:O,"","","PLCCP:O.Data[22]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,PLCCP:2:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,PLCCP:2:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,PLCCP:3:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,PLCCP:3:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,PLCCP:4:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,PLCCP:4:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,PLCCP:5:I,"","AB:1734_OB8S_Safety1:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,PLCCP:5:O,"","AB:1734_OB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,PLCCP:6:I,"","AB:1734_OB8S_Safety1:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,PLCCP:6:O,"","AB:1734_OB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,PLCCP:7:C,"","AB:1734_IE2:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,PLCCP:7:I,"","AB:1734_IE2:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,PLCCP:8:C,"","AB:1734_IE2:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,PLCCP:8:I,"","AB:1734_IE2:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,PLCCP:9:C,"","AB:1734_OE2:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,PLCCP:9:I,"","AB:1734_OE2:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,PLCCP:9:O,"","AB:1734_OE2:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,PLCCP:I,"","AB:1734_23SLOT:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,PLCCP:O,"","AB:1734_23SLOT:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,DrafterGroup5:C,"","AB:ETHERNET_MODULE:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,DrafterGroup5:I,"","AB:ETHERNET_MODULE_INT_20Bytes:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,DrafterGroup5:O,"","AB:ETHERNET_MODULE_INT_20Bytes:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BottomTakeoff:C,"","AB:ETHERNET_MODULE:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BottomTakeoff:I,"","AB:ETHERNET_MODULE_INT_20Bytes:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BottomTakeoff:O,"","AB:ETHERNET_MODULE_INT_20Bytes:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,RH1ExtendedApron:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,RH1ExtendedApron:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,OB1RP:1:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OB1RP:1:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OB1RP:2:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OB1RP:2:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OB1RP:3:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB1RP:3:I,"","","OB1RP:I.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,OB1RP:3:O,"","","OB1RP:O.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB1RP:4:C,"","AB:1734_IE2:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,OB1RP:4:I,"","AB:1734_IE2:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,OB1RP:5:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB1RP:5:I,"","","OB1RP:I.Data[5]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB1RP:6:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB1RP:6:I,"","","OB1RP:I.Data[6]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB1RP:7:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB1RP:7:I,"","","OB1RP:I.Data[7]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,OB1RP:7:O,"","","OB1RP:O.Data[7]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB1RP:8:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB1RP:8:I,"","","OB1RP:I.Data[8]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,OB1RP:8:O,"","","OB1RP:O.Data[8]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB1RP:I,"","AB:1734_9SLOT:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,OB1RP:O,"","AB:1734_9SLOT:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO1ExtendedApron:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO1ExtendedApron:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TH6LiftApron:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TH6LiftApron:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BottomTOFBelt:C,"","AB:ETHERNET_MODULE:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BottomTOFBelt:I,"","AB:ETHERNET_MODULE_INT_20Bytes:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BottomTOFBelt:O,"","AB:ETHERNET_MODULE_INT_20Bytes:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,FOFeedroll:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,FOFeedroll:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,RH1LiftApron:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,RH1LiftApron:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO1LoadApron:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO1LoadApron:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,Apron:C,"","AB:ETHERNET_MODULE:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,Apron:I,"","AB:ETHERNET_MODULE_INT_20Bytes:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,Apron:O,"","AB:ETHERNET_MODULE_INT_20Bytes:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,B1BlendTransportFan:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,B1BlendTransportFan:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TopTakeoff:C,"","AB:ETHERNET_MODULE:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TopTakeoff:I,"","AB:ETHERNET_MODULE_INT_20Bytes:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TopTakeoff:O,"","AB:ETHERNET_MODULE_INT_20Bytes:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,RH1RP:1:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,RH1RP:1:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,RH1RP:2:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,RH1RP:2:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,RH1RP:3:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,RH1RP:3:I,"","","RH1RP:I.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,RH1RP:3:O,"","","RH1RP:O.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,RH1RP:4:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,RH1RP:4:I,"","","RH1RP:I.Data[4]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,RH1RP:5:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,RH1RP:5:I,"","","RH1RP:I.Data[5]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,RH1RP:6:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,RH1RP:6:I,"","","RH1RP:I.Data[6]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,RH1RP:6:O,"","","RH1RP:O.Data[6]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,RH1RP:7:C,"","AB:1734_DO4:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,RH1RP:7:O,"","","RH1RP:O.Data[7]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,RH1RP:I,"","AB:1734_8SLOT:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,RH1RP:O,"","AB:1734_8SLOT:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TopScrambler:C,"","AB:ETHERNET_MODULE:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TopScrambler:I,"","AB:ETHERNET_MODULE_INT_20Bytes:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TopScrambler:O,"","AB:ETHERNET_MODULE_INT_20Bytes:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,RH2ExtendedApron:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,RH2ExtendedApron:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,ScaleBelt:C,"","AB:ETHERNET_MODULE:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,ScaleBelt:I,"","AB:ETHERNET_MODULE_INT_20Bytes:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,ScaleBelt:O,"","AB:ETHERNET_MODULE_INT_20Bytes:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO4LiftApron:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO4LiftApron:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BottomDoffer:C,"","AB:ETHERNET_MODULE:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BottomDoffer:I,"","AB:ETHERNET_MODULE_INT_20Bytes:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BottomDoffer:O,"","AB:ETHERNET_MODULE_INT_20Bytes:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,DrafterGroup4:C,"","AB:ETHERNET_MODULE:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,DrafterGroup4:I,"","AB:ETHERNET_MODULE_INT_20Bytes:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,DrafterGroup4:O,"","AB:ETHERNET_MODULE_INT_20Bytes:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TH7RP:1:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,TH7RP:1:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,TH7RP:2:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,TH7RP:2:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,TH7RP:3:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,TH7RP:3:I,"","","TH7RP:I.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,TH7RP:3:O,"","","TH7RP:O.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,TH7RP:4:C,"","AB:1734_IE2:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TH7RP:4:I,"","AB:1734_IE2:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TH7RP:5:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,TH7RP:5:I,"","","TH7RP:I.Data[5]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,TH7RP:6:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,TH7RP:6:I,"","","TH7RP:I.Data[6]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,TH7RP:6:O,"","","TH7RP:O.Data[6]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,TH7RP:I,"","AB:1734_7SLOT:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TH7RP:O,"","AB:1734_7SLOT:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TopDoffer:C,"","AB:ETHERNET_MODULE:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TopDoffer:I,"","AB:ETHERNET_MODULE_INT_20Bytes:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TopDoffer:O,"","AB:ETHERNET_MODULE_INT_20Bytes:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO3LiftApron:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO3LiftApron:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,FS52ReserveSiloFeedroll:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,FS52ReserveSiloFeedroll:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TH7LiftApron:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TH7LiftApron:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO2ExtendedApron:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO2ExtendedApron:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,OB4RP:1:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OB4RP:1:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OB4RP:2:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OB4RP:2:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OB4RP:3:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB4RP:3:I,"","","OB4RP:I.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,OB4RP:3:O,"","","OB4RP:O.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB4RP:4:C,"","AB:1734_IE2:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,OB4RP:4:I,"","AB:1734_IE2:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,OB4RP:5:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB4RP:5:I,"","","OB4RP:I.Data[5]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB4RP:6:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB4RP:6:I,"","","OB4RP:I.Data[6]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB4RP:7:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB4RP:7:I,"","","OB4RP:I.Data[7]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,OB4RP:7:O,"","","OB4RP:O.Data[7]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB4RP:8:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB4RP:8:I,"","","OB4RP:I.Data[8]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,OB4RP:8:O,"","","OB4RP:O.Data[8]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB4RP:I,"","AB:1734_9SLOT:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,OB4RP:O,"","AB:1734_9SLOT:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,DrafterGroup2:C,"","AB:ETHERNET_MODULE:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,DrafterGroup2:I,"","AB:ETHERNET_MODULE_INT_20Bytes:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,DrafterGroup2:O,"","AB:ETHERNET_MODULE_INT_20Bytes:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,RedLionDSP:C,"","AB:ETHERNET_MODULE:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,RedLionDSP:I,"","AB:ETHERNET_MODULE_INT_400Bytes:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,RedLionDSP:O,"","AB:ETHERNET_MODULE_INT_400Bytes:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BottomScrambler:C,"","AB:ETHERNET_MODULE:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BottomScrambler:I,"","AB:ETHERNET_MODULE_INT_20Bytes:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BottomScrambler:O,"","AB:ETHERNET_MODULE_INT_20Bytes:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,CRP2:10:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,CRP2:10:I,"","","CRP2:I.Data[10]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,CRP2:11:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,CRP2:11:I,"","","CRP2:I.Data[11]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,CRP2:12:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,CRP2:12:I,"","","CRP2:I.Data[12]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,CRP2:13:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,CRP2:13:I,"","","CRP2:I.Data[13]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,CRP2:14:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,CRP2:14:I,"","","CRP2:I.Data[14]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,CRP2:15:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,CRP2:15:I,"","","CRP2:I.Data[15]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,CRP2:15:O,"","","CRP2:O.Data[15]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,CRP2:16:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,CRP2:16:I,"","","CRP2:I.Data[16]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,CRP2:16:O,"","","CRP2:O.Data[16]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,CRP2:1:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CRP2:1:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,CRP2:2:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,CRP2:2:I,"","","CRP2:I.Data[2]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,CRP2:2:O,"","","CRP2:O.Data[2]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,CRP2:3:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,CRP2:3:I,"","","CRP2:I.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,CRP2:3:O,"","","CRP2:O.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,CRP2:4:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,CRP2:4:I,"","","CRP2:I.Data[4]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,CRP2:4:O,"","","CRP2:O.Data[4]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,CRP2:5:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,CRP2:5:I,"","","CRP2:I.Data[5]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,CRP2:5:O,"","","CRP2:O.Data[5]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,CRP2:6:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,CRP2:6:I,"","","CRP2:I.Data[6]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,CRP2:6:O,"","","CRP2:O.Data[6]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,CRP2:7:C,"","AB:1734_IE2:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,CRP2:7:I,"","AB:1734_IE2:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,CRP2:8:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,CRP2:8:I,"","","CRP2:I.Data[8]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,CRP2:9:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,CRP2:9:I,"","","CRP2:I.Data[9]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,CRP2:I,"","AB:1734_17SLOT:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,CRP2:O,"","AB:1734_17SLOT:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,OB3RP:1:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OB3RP:1:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OB3RP:2:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OB3RP:2:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,OB3RP:3:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB3RP:3:I,"","","OB3RP:I.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,OB3RP:3:O,"","","OB3RP:O.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB3RP:4:C,"","AB:1734_IE2:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,OB3RP:4:I,"","AB:1734_IE2:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,OB3RP:5:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB3RP:5:I,"","","OB3RP:I.Data[5]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB3RP:6:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB3RP:6:I,"","","OB3RP:I.Data[6]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB3RP:7:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB3RP:7:I,"","","OB3RP:I.Data[7]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,OB3RP:7:O,"","","OB3RP:O.Data[7]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB3RP:8:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,OB3RP:8:I,"","","OB3RP:I.Data[8]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,OB3RP:8:O,"","","OB3RP:O.Data[8]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,OB3RP:I,"","AB:1734_9SLOT:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,OB3RP:O,"","AB:1734_9SLOT:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,FS52:1:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,FS52:1:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,FS52:2:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,FS52:2:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,FS52:3:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,FS52:3:I,"","","FS52:I.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,FS52:3:O,"","","FS52:O.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,FS52:4:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,FS52:4:I,"","","FS52:I.Data[4]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,FS52:I,"","AB:1734_5SLOT:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,FS52:O,"","AB:1734_5SLOT:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,FS52ReserveSiloOutfeedFan:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,FS52ReserveSiloOutfeedFan:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO5LiftApron:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO5LiftApron:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,VBORP:1:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,VBORP:1:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,VBORP:2:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,VBORP:2:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,VBORP:3:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,VBORP:3:I,"","","VBORP:I.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,VBORP:3:O,"","","VBORP:O.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,VBORP:4:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,VBORP:4:I,"","","VBORP:I.Data[4]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,VBORP:I,"","AB:1734_5SLOT:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,VBORP:O,"","AB:1734_5SLOT:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TopTOFBelt:C,"","AB:ETHERNET_MODULE:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TopTOFBelt:I,"","AB:ETHERNET_MODULE_INT_20Bytes:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TopTOFBelt:O,"","AB:ETHERNET_MODULE_INT_20Bytes:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO4LoadApron:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO4LoadApron:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO2LiftApron:I,"","AB:PowerFlex525V_E_3DC2426F:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,BO2LiftApron:O,"","AB:PowerFlex525V_EENET_Drive:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TH6RP:1:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,TH6RP:1:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,TH6RP:2:I,"","AB:1734_IB8S_Safety2:I:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,TH6RP:2:O,"","AB:1734_IB8S:O:0","","(Class := Safety, ExternalAccess := Read/Write)"
TAG,,TH6RP:3:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,TH6RP:3:I,"","","TH6RP:I.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,TH6RP:3:O,"","","TH6RP:O.Data[3]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,TH6RP:4:C,"","AB:1734_IE2:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TH6RP:4:I,"","AB:1734_IE2:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TH6RP:5:C,"","AB:1734_DI8:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,TH6RP:5:I,"","","TH6RP:I.Data[5]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,TH6RP:6:C,"","AB:1734_DO8_NoDiag:C:0","","(Class := Standard, ExternalAccess := Read/Write)"
ALIAS,,TH6RP:6:I,"","","TH6RP:I.Data[6]","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,TH6RP:6:O,"","","TH6RP:O.Data[6]","(RADIX := Binary, ExternalAccess := Read/Write)"
TAG,,TH6RP:I,"","AB:1734_7SLOT:I:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,TH6RP:O,"","AB:1734_7SLOT:O:0","","(Class := Standard, ExternalAccess := Read/Write)"
TAG,,Alarms,"","Alarms","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,Anticipation_Percent,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,Apron,"","SEWDrive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,AspirationFanContAux,"","","CCP:6:I.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,AspirationFanRun,"","","CCP:10:O.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,B1BlendConveyor,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,B1BlendConveyorFailedToMove,"Although the Drive Ran, The Belt Did not Move","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,B1BlenderBeater,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,B1BlenderBeaterCont,"","","OBCP:18:O.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,B1BlenderBeaterContAux,"","","OBCP:14:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,B1BlenderBeaterZeroSpeed,"","","OBCP:1:I.Pt04Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,B1BlenderBeaterZeroSpeedStatus,"","","OBCP:1:I.Pt04Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,B1BlenderBeaterZSpeedStatus,"Motor at Stand Still Delayed Status","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,B1BlenderConveyorPositionProx,"","","FS52:4:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,B1BlenderInnerDoorLS,"","","VBORP:4:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,B1BlenderLeftEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,B1BlenderLeftEStopPB1,"","","VBORP:1:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,B1BlenderLeftEStopPB1Status,"","","VBORP:1:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,B1BlenderLeftEStopPB2,"","","VBORP:1:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,B1BlenderRightEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,B1BlenderRightEStopPB1,"","","VBORP:1:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,B1BlenderRightEStopPB1Status,"","","VBORP:1:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,B1BlenderRightEStopPB2,"","","VBORP:1:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,B1BlendTransportFan,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,B1_Ready,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,B1_VBO_FS51RPDoorEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,B1_VBO_FS51RPDoorEStopPB1,"","","VBORP:2:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,B1_VBO_FS51RPDoorEStopPB1Status,"","","VBORP:2:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,B1_VBO_FS51RPDoorEStopPB2,"","","VBORP:2:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BlendAlarmHornTimer,"","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BlendAlarmTimerValue,"","DINT","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BlendingAlarmHorn,"","","PLCCP:17:O.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BlendingAlarmHornLatch,"Latches Horn Until Alarm Reset","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BlendingAlarmOS,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BlendingAlarmSlowMode,"Activate Slow Mode for Blending Alarm","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BlendingGreenStackLight1,"","","FS52:3:O.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BlendingGreenStackLight2,"","","VBORP:3:O.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BlendingHornStackLight1,"","","FS52:3:O.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BlendingHornStackLight2,"","","VBORP:3:O.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BlendingHornTimer,"Timer for Beeping the Horn","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BlendingRedStackLight1,"","","FS52:3:O.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BlendingRedStackLight2,"","","VBORP:3:O.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BlendingYellowStackLight1,"","","FS52:3:O.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BlendingYellowStackLight2,"","","VBORP:3:O.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BlendLine,"","BlendLine","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BlendLineMetalDetectorStatus,"Blend Line Argus Metal Detector Status$NPower and Air Pressure","","OB4RP:1:I.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BlendLineStartHorn,"replace me$N$N","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BlendSystemStartPL,"replace me","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO1,"","Hopper","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO1BaleBreakerZeroSpeed,"","","OB1RP:2:I.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1BaleBreakerZeroSpeedStatus,"","","OB1RP:2:I.Pt07Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO1BaleBreakerZSpeedStatus,"Motor at Stand Still Delayed Status","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO1BaleOpenerRestartHorn,"","","OB1RP:7:O.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO1Breaker,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO1BreakerCont,"","","OBCP:16:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1BreakerContAux,"","","OBCP:12:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO1Damper,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO1Doffer,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO1DofferCont,"","","OBCP:16:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1DofferContAux,"","","OBCP:12:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1DofferContAuxSafe,"","","OBCP:3:I.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1DofferContAuxSafeStatus,"","","OBCP:3:I.Pt07Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO1DoorLocks,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO1Dump,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO1ExtendedApron,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO1FillTooLongTmr,"Filling is Taking too Long Alarm","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO1JogPB,"","","OB1RP:5:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1LeftExtendedApronPE,"","","OB1RP:5:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1LeftLoadApronPE,"","","OB1RP:5:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO1LiftApron,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO1LoadApron,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO1Loadcell,"","","OB1RP:4:I.Ch0Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO1LoadDoor,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO1LoadDoorClosedLS,"","","OB1RP:5:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1LoadDoorClosedPL,"","","OB1RP:7:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1LoadDoorCloseSol,"","","OB1RP:7:O.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1LoadDoorCloseSS,"","","OB1RP:5:I.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1LoadDoorOpenBeacon,"","","OB1RP:7:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1LoadDoorOpenSol,"","","OB1RP:7:O.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1LoadDoorOpenSS,"","","OB1RP:5:I.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO1LoadDoorSafety,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO1LoadDoorSafety1,"","","OB1RP:2:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1LoadDoorSafety1Status,"","","OB1RP:2:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1LoadDoorSafety2,"","","OB1RP:2:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1LoadGateReleasePB,"","","OB1RP:5:I.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1LoadGateReleaseSol,"","","OB1RP:3:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO1PanelEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO1PanelEStopPB1,"","","OB1RP:1:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1PanelEStopPB1Status,"","","OB1RP:1:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1PanelEStopPB2,"","","OB1RP:1:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO1ResetDrives,"Reset Drives After Safety Fault","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO1ResetSafety,"Mapped to Safety Bit for Zone Reset","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO1RestartPB,"","","OB1RP:5:I.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO1RestartSystem,"Restart the System from Restart Pushbutton","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO1RestartTmr,"BO1 Restart/Reset Timer","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO1RightBaleEntryEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO1RightBaleEntryEStopPB1,"","","OB1RP:1:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1RightBaleEntryEStopPB1Status,"","","OB1RP:1:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1RightBaleEntryEStopPB2,"","","OB1RP:1:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO1StartOS,"One Shot","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO1StartOS2,"One Shot$N","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO1TopAccessHatch,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO1TopAccessHatch1,"","","OB1RP:2:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1TopAccessHatch1Status,"","","OB1RP:2:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1TopAccessHatch2,"","","OB1RP:2:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1TopAccessHatchReleaseSol,"","","OB1RP:3:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1WeighPanDamperCloseSol,"","","OB1RP:7:O.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO1WeighPanDumpSol,"","","OB1RP:7:O.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO2,"","Hopper","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO2BaleBreakerZeroSpeed,"","","OB2RP:2:I.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2BaleBreakerZeroSpeedStatus,"","","OB2RP:2:I.Pt07Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO2BaleBreakerZSpeedStatus,"Motor at Stand Still Delayed Status","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO2BaleOpenerRestartHorn,"","","OB2RP:7:O.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO2Breaker,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO2BreakerCont,"","","OBCP:16:O.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2BreakerContAux,"","","OBCP:12:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO2Damper,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO2Doffer,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO2DofferCont,"","","OBCP:16:O.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2DofferContAux,"","","OBCP:12:I.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2DofferContAuxSafe,"","","OBCP:4:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2DofferContAuxSafeStatus,"","","OBCP:4:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO2DoorLocks,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO2Dump,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO2ExtendedApron,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO2FillTooLongTmr,"Filling is Taking too Long Alarm","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO2JogPB,"","","OB2RP:5:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2LeftExtendedApronPE,"","","OB2RP:5:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2LeftLoadApronPE,"","","OB2RP:5:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO2LiftApron,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO2LoadApron,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO2Loadcell,"","","OB2RP:4:I.Ch0Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO2LoadDoor,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO2LoadDoorClosedLS,"","","OB2RP:5:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2LoadDoorClosedPL,"","","OB2RP:7:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2LoadDoorCloseSol,"","","OB2RP:7:O.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2LoadDoorCloseSS,"","","OB2RP:5:I.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2LoadDoorOpenBeacon,"","","OB2RP:7:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2LoadDoorOpenSol,"","","OB2RP:7:O.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2LoadDoorOpenSS,"","","OB2RP:5:I.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO2LoadDoorSafety,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO2LoadDoorSafety1,"","","OB2RP:2:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2LoadDoorSafety1Status,"","","OB2RP:2:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2LoadDoorSafety2,"","","OB2RP:2:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2LoadGateReleasePB,"","","OB2RP:5:I.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2LoadGateReleaseSol,"","","OB2RP:3:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO2PanelEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO2PanelEStopPB1,"","","OB2RP:1:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2PanelEStopPB1Status,"","","OB2RP:1:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2PanelEStopPB2,"","","OB2RP:1:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO2ResetDrives,"Reset Drives After Safety Fault$N","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO2ResetSafety,"Mapped to Safety Bit for Zone Reset$N","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO2RestartPB,"","","OB2RP:5:I.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO2RestartSystem,"Restart the System from Restart Pushbutton","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO2RestartTmr,"BO2 Restart/Reset Timer","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO2RightBaleEntryEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO2RightBaleEntryEStopPB1,"","","OB2RP:1:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2RightBaleEntryEStopPB1Status,"","","OB2RP:1:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2RightBaleEntryEStopPB2,"","","OB2RP:1:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO2StartOS,"One Shot","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO2StartOS2,"One Shot","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO2TopAccessHatch,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO2TopAccessHatch1,"","","OB2RP:2:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2TopAccessHatch1Status,"","","OB2RP:2:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2TopAccessHatch2,"","","OB2RP:2:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2TopAccessHatchReleaseSol,"","","OB2RP:3:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2WeighPanDamperCloseSol,"","","OB2RP:7:O.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO2WeighPanDumpSol,"","","OB2RP:7:O.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO3,"","Hopper","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO3BaleBreakerZeroSpeed,"","","OB3RP:2:I.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3BaleBreakerZeroSpeedStatus,"","","OB3RP:2:I.Pt07Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO3BaleBreakerZSpeedStatus,"Motor at Stand Still Delayed Status","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO3BaleOpenerRestartHorn,"","","OB3RP:7:O.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO3Breaker,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO3BreakerCont,"","","OBCP:16:O.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3BreakerContAux,"","","OBCP:12:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO3Damper,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO3Doffer,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO3DofferCont,"","","OBCP:16:O.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3DofferContAux,"","","OBCP:12:I.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3DofferContAuxSafe,"","","OBCP:4:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3DofferContAuxSafeStatus,"","","OBCP:4:I.Pt01Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO3DoorLocks,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO3Dump,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO3ExtendedApron,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO3FillTooLongTmr,"Filling is Taking too Long Alarm","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO3GateDoorReleasePB,"","","OB3RP:5:I.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3JogPB,"","","OB3RP:5:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3LeftExtendedApronPE,"","","OB3RP:5:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3LeftLoadApronPE,"","","OB3RP:5:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO3LiftApron,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO3LoadApron,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO3Loadcell,"","","OB3RP:4:I.Ch0Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO3LoadDoor,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO3LoadDoorClosedLS,"","","OB3RP:5:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3LoadDoorClosedPL,"","","OB3RP:7:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3LoadDoorCloseSol,"","","OB3RP:7:O.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3LoadDoorCloseSS,"","","OB3RP:5:I.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3LoadDoorOpenBeacon,"","","OB3RP:7:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3LoadDoorOpenSol,"","","OB3RP:7:O.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3LoadDoorOpenSS,"","","OB3RP:5:I.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO3LoadDoorSafety,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO3LoadDoorSafety1,"","","OB3RP:2:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3LoadDoorSafety1Status,"","","OB3RP:2:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3LoadDoorSafety2,"","","OB3RP:2:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3LoadGateReleaseSol,"","","OB3RP:3:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO3PanelEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO3PanelEStopPB1,"","","OB3RP:1:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3PanelEStopPB1Status,"","","OB3RP:1:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3PanelEStopPB2,"","","OB3RP:1:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO3ResetDrives,"Reset Drives After Safety Fault$N","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO3ResetSafety,"Mapped to Safety Bit for Zone Reset$N","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO3RestartPB,"","","OB3RP:5:I.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO3RestartSystem,"Restart the System from Restart Pushbutton","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO3RestartTmr,"BO3 Restart/Reset Timer","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO3RightBaleEntryEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO3RightBaleEntryEStopPB1,"","","OB3RP:1:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3RightBaleEntryEStopPB1Status,"","","OB3RP:1:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3RightBaleEntryEStopPB2,"","","OB3RP:1:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO3StartOS,"One Shot","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO3StartOS2,"One Shot","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO3TopAccessHatch,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO3TopAccessHatch1,"","","OB3RP:2:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3TopAccessHatch1Status,"","","OB3RP:2:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3TopAccessHatch2,"","","OB3RP:2:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3TopAccessHatchReleaseSol,"","","OB3RP:3:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3WeighPanDamperCloseSol,"","","OB3RP:7:O.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO3WeighPanDumpSol,"","","OB3RP:7:O.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO4,"","Hopper","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO4BaleBreakerZeroSpeed,"","","OB4RP:2:I.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4BaleBreakerZeroSpeedStatus,"","","OB4RP:2:I.Pt07Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO4BaleBreakerZSpeedStatus,"Motor at Stand Still Delayed Status","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO4BaleOpenerRestartHorn,"","","OB4RP:7:O.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO4Breaker,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO4BreakerCont,"","","OBCP:16:O.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4BreakerContAux,"","","OBCP:12:I.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO4Damper,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO4Doffer,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO4DofferCont,"","","OBCP:16:O.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4DofferContAux,"","","OBCP:12:I.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4DofferContAuxSafe,"","","OBCP:4:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4DofferContAuxSafeStatus,"","","OBCP:4:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO4DoorLocks,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO4Dump,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO4ExtendedApron,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO4FillTooLongTmr,"Filling is Taking too Long Alarm","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO4GateDoorReleasePB,"","","OB4RP:5:I.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4GateDoorReleaseSol,"","","OB4RP:3:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4JogPB,"","","OB4RP:5:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4LeftExtendedApronPE,"","","OB4RP:5:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4LeftLoadApronPE,"","","OB4RP:5:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO4LiftApron,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO4LoadApron,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO4Loadcell,"","","OB4RP:4:I.Ch0Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO4LoadDoor,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO4LoadDoorClosedLS,"","","OB4RP:5:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4LoadDoorClosedPL,"","","OB4RP:7:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4LoadDoorCloseSol,"","","OB4RP:7:O.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4LoadDoorCloseSS,"","","OB4RP:5:I.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4LoadDoorOpenBeacon,"","","OB4RP:7:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4LoadDoorOpenSol,"","","OB4RP:7:O.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4LoadDoorOpenSS,"","","OB4RP:5:I.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO4LoadDoorSafety,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO4LoadDoorSafety1,"","","OB4RP:2:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4LoadDoorSafety1Status,"","","OB4RP:2:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4LoadDoorSafety2,"","","OB4RP:2:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO4PanelEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO4PanelEStopPB1,"","","OB4RP:1:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4PanelEStopPB1Status,"","","OB4RP:1:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4PanelEStopPB2,"","","OB4RP:1:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO4ResetDrives,"Reset Drives After Safety Fault$N","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO4ResetSafety,"Mapped to Safety Bit for Zone Reset$N","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO4RestartPB,"","","OB4RP:5:I.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO4RestartSystem,"Restart the System from Restart Pushbutton","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO4RestartTmr,"BO4 Restart/Reset Timer","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO4RightBaleEntryEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO4RightBaleEntryEStopPB1,"","","OB4RP:1:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4RightBaleEntryEStopPB1Status,"","","OB4RP:1:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4RightBaleEntryEStopPB2,"","","OB4RP:1:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO4StartOS,"One Shot","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO4StartOS2,"One Shot","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO4TopAccessHatch,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO4TopAccessHatch1,"","","OB4RP:2:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4TopAccessHatch1Status,"","","OB4RP:2:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4TopAccessHatch2,"","","OB4RP:2:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4TopAccessHatchReleaseSol,"","","OB4RP:3:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4WeighPanDamperCloseSol,"","","OB4RP:7:O.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO4WeighPanDumpSol,"","","OB4RP:7:O.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO5,"","Hopper","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO5BaleBreakerZeroSpeed,"","","OB5RP:2:I.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5BaleBreakerZeroSpeedStatus,"","","OB5RP:2:I.Pt07Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO5BaleBreakerZSpeedStatus,"Motor at Stand Still Delayed Status","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO5BaleOpenerRestartHorn,"","","OB5RP:7:O.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO5Breaker,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO5BreakerCont,"","","OBCP:17:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5BreakerContAux,"","","OBCP:13:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO5Damper,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO5Doffer,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO5DofferCont,"","","OBCP:17:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5DofferContAux,"","","OBCP:13:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5DofferContAuxSafe,"","","OBCP:4:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5DofferContAuxSafeStatus,"","","OBCP:4:I.Pt03Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO5DoorLocks,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO5Dump,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO5ExtendedApron,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO5FillTooLongTmr,"Filling is Taking too Long Alarm","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO5GateDoorReleasePB,"","","OB5RP:5:I.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5JogPB,"","","OB5RP:5:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5LeftExtendedApronPE,"","","OB5RP:5:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5LeftLoadApronPE,"","","OB5RP:5:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO5LiftApron,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO5LoadApron,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO5Loadcell,"","","OB5RP:4:I.Ch0Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO5LoadDoor,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO5LoadDoorClosedLS,"","","OB5RP:5:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5LoadDoorClosedPL,"","","OB5RP:7:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5LoadDoorCloseSol,"","","OB5RP:7:O.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5LoadDoorCloseSS,"","","OB5RP:5:I.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5LoadDoorOpenBeacon,"","","OB5RP:7:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5LoadDoorOpenSol,"","","OB5RP:7:O.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5LoadDoorOpenSS,"","","OB5RP:5:I.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO5LoadDoorSafety,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO5LoadDoorSafety1,"","","OB5RP:2:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5LoadDoorSafety1Status,"","","OB5RP:2:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5LoadDoorSafety2,"","","OB5RP:2:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5LoadGateReleaseSol,"","","OB5RP:3:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO5PanelEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO5PanelEStopPB1,"","","OB5RP:1:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5PanelEStopPB1Status,"","","OB5RP:1:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5PanelEStopPB2,"","","OB5RP:1:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO5ResetDrives,"Reset Drives After Safety Fault$N","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO5ResetSafety,"Mapped to Safety Bit for Zone Reset$N","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO5RestartPB,"","","OB5RP:5:I.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO5RestartSystem,"Restart the System from Restart Pushbutton","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO5RestartTmr,"BO5 Restart/Reset Timer","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO5RightBaleEntryEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO5RightBaleEntryEStopPB1,"","","OB5RP:1:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5RightBaleEntryEStopPB1Status,"","","OB5RP:1:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5RightBaleEntryEStopPB2,"","","OB5RP:1:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BO5StartOS,"One Shot","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO5StartOS2,"One Shot","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,BO5TopAccessHatch,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,BO5TopAccessHatch1,"","","OB5RP:2:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5TopAccessHatch1Status,"","","OB5RP:2:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5TopAccessHatch2,"","","OB5RP:2:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5TopAccessHatchReleaseSol,"","","OB5RP:3:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5WeighPanDamperCloseSol,"","","OB5RP:7:O.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,BO5WeighPanDumpSol,"","","OB5RP:7:O.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,BottomDoffer,"","SEWDrive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BottomScrambler,"","SEWDrive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BottomScramblerRoll2Ratio,"Ratio for Roll 2 Speed","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,BottomTakeoff,"","SEWDrive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,BottomTOFBelt,"","SEWDrive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,Bypass_XLP,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,CalculateCrosslapperSetpoints,"Calculate Setpoints before Sending them to Dilo","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,CalculateLoomSetpoints,"Calculate Setpoints before Sending them to Dilo","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,Calender,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Calender24VStatus,"","","PLCCP:13:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CalenderEStop,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CalenderEStop1,"","","PLCCP:2:I.Pt04Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CalenderEStop1Status,"","","PLCCP:2:I.Pt04Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CalenderEStop2,"","","PLCCP:2:I.Pt05Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CalenderInline,"","","PLCCP:13:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CalenderReadyToStart,"","","PLCCP:13:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CalenderReset,"","","PLCCP:22:O.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CalenderSafetyExpansion1,"","","PLCCP:5:O.Pt04Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CalenderSafetyExpansion2,"","","PLCCP:5:O.Pt05Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CalenderSafetyExpansionMonitor,"","","PLCCP:3:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CalenderSafetyExpansionMonitorStatus,"","","PLCCP:3:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CalenderShouldBeRunning,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CalenderSpeedFeedback,"","","PLCCP:8:I.Ch0Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CalenderSpeedRef,"","","PLCCP:10:O.Ch0Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CalenderSpeedRefScaler,"","Scaler","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,CalenderSpeedScaler,"","Scaler","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CalenderStart,"","","PLCCP:22:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CalenderStartTimer,"","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CalenderStop,"","","PLCCP:22:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CalenderStopInternal,"Internal Bit for Stopping the Calender","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,CalenderStopTimer,"Timer to Hold Stop Command","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,CalenderZone,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CalenderZoneExpansionUnitStatus,"","","PLCCP:5:I.Pt04OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Calender_Enabled,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,Calender_Off,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,Calender_On,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,CardAspirationFan,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardAspirationFanPressure,"Should have Pressure when the Fan is Running","","CRP2:8:I.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardBottomLeftBrushWrap,"","","CRP2:12:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardBottomRightBrushWrap,"","","CRP2:12:I.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardCover1,"","CardCover","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,CardCover1ClosedProx,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardCover1ClosedProx1,"","","CRP2:1:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover1ClosedProx1Status,"","","CRP2:1:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover1ClosedProx2,"","","CRP2:1:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover1LeftAndRightClosedLimit,"","","CRP2:9:I.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover1LeftAndRightOpenLimit,"","","CRP2:9:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover1LeftClosedLimit,"","","CRP2:9:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover1LeftCont,"","","CCP:12:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover1LeftContAux,"","","CCP:7:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover1LeftOpenLimit,"","","CRP2:9:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover1RightClosedLimit,"","","CRP2:9:I.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover1RightCont,"","","CCP:12:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover1RightContAux,"","","CCP:7:I.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover1RightOpenLimit,"","","CRP2:9:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardCover2,"","CardCover","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,CardCover2ClosedProx,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardCover2ClosedProx1,"","","CRP2:1:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover2ClosedProx1Status,"","","CRP2:1:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover2ClosedProx2,"","","CRP2:1:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover2LeftAndRightClosedLimit,"","","CRP2:10:I.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover2LeftAndRightOpenLimit,"","","CRP2:10:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover2LeftClosedLimit,"","","CRP2:9:I.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover2LeftCont,"","","CCP:12:O.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover2LeftContAux,"","","CCP:7:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover2LeftOpenLimit,"","","CRP2:9:I.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover2RightClosedLimit,"","","CRP2:10:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover2RightCont,"","","CCP:12:O.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover2RightContAux,"","","CCP:7:I.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover2RightOpenLimit,"","","CRP2:10:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardCover3,"","CardCover","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,CardCover3ClosedProx,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardCover3ClosedProx1,"","","CRP2:1:I.Pt04Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover3ClosedProx1Status,"","","CRP2:1:I.Pt04Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover3ClosedProx2,"","","CRP2:1:I.Pt05Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover3LeftAndRightClosedLimit,"","","CRP2:11:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover3LeftAndRightOpenLimit,"","","CRP2:11:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover3LeftClosedLimit,"","","CRP2:10:I.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover3LeftCont,"","","CCP:12:O.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover3LeftContAux,"","","CCP:7:I.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover3LeftOpenLimit,"","","CRP2:10:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover3RightClosedLimit,"","","CRP2:10:I.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover3RightCont,"","","CCP:12:O.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover3RightContAux,"","","CCP:7:I.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover3RightOpenLimit,"","","CRP2:10:I.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardCover4,"","CardCover","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,CardCover4ClosedProx,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardCover4ClosedProx1,"","","CRP2:1:I.Pt06Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover4ClosedProx1Status,"","","CRP2:1:I.Pt06Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover4ClosedProx2,"","","CRP2:1:I.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover4LeftAndRightClosedLimit,"","","CRP2:11:I.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover4LeftAndRightOpenLimit,"","","CRP2:11:I.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover4LeftClosedLimit,"","","CRP2:11:I.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover4LeftCont,"","","CCP:12:O.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover4LeftContAux,"","","CCP:8:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover4LeftOpenLimit,"","","CRP2:11:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover4RightClosedLimit,"","","CRP2:11:I.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover4RightCont,"","","CCP:12:O.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover4RightContAux,"","","CCP:8:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCover4RightOpenLimit,"","","CRP2:11:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardCoverCylindersDown,"","","CCP:4:O.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardCoverCylindersDownControl,"Control Bit Sent to the Safety Routine","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardCoverCylindersUp,"","","CCP:4:O.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardCoverCylindersUpControl,"Control Bit Sent to the Safety Routine","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardCoverDownContAux,"","","CCP:7:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardCoverFailedToRun,"Directional Contactor Failed to Run","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,CardCoverFailedToRunTimer,"Failed to Run Timer","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,CardCoverFailedToStop,"Directional Contactor Failed to Stop","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,CardCoverFailedToStopTimer,"Failed to Stop Timer","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,CardCoverFaulted,"Direction Control Fault","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,CardCoverSafetyDownControl,"Safety Bit Mapped from Standard Bit","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,CardCoverSafetyUpControl,"Safety Bit Mapped from Standard Bit","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardCoverUpContAux,"","","CCP:7:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardDoorLocks,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,CardDoorLockStagger,"Stagger the Outputs","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,CardDoorReleaseStagger,"Stagger the Outputs$N","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardFeedLightBarrier,"","","CRP2:12:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardFeedrollTopHatch,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardFeedrollTopHatch1,"","","CRP1:9:I.Pt00Data","(RADIX := Binary, ExternalAccess := Read/Write)"
ALIAS,,CardFeedrollTopHatch1Status,"","","CRP1:9:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardFeedrollTopHatch2,"","","CRP1:9:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardFeedrollTopHatchReleaseSol,"","","CRP2:4:O.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardGreenStackLight,"","","CRP2:16:O.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardHornStackLight,"","","CRP2:16:O.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardLeftApronDoorEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardLeftApronDoorEStopPB1,"","","CRP1:1:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftApronDoorEStopPB1Status,"","","CRP1:1:I.Pt03Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftApronDoorEStopPB2,"","","CRP1:1:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardLeftBottomAccessDoor,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardLeftBottomAccessDoor1,"","","CRP1:6:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftBottomAccessDoor1Status,"","","CRP1:6:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftBottomAccessDoor2,"","","CRP1:6:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftBottomAccessDoorReleaseSol,"","","CRP2:3:O.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardLeftDoor1,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor11,"","","CRP1:4:I.Pt04Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor11Status,"","","CRP1:4:I.Pt04Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor12,"","","CRP1:4:I.Pt05Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor1ReleaseSol,"","","CRP2:2:O.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardLeftDoor2,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor21,"","","CRP1:4:I.Pt06Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor21Status,"","","CRP1:4:I.Pt06Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor22,"","","CRP1:4:I.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor2ReleaseSol,"","","CRP2:2:O.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardLeftDoor3,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor31,"","","CRP1:5:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor31Status,"","","CRP1:5:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor32,"","","CRP1:5:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor3ReleaseSol,"","","CRP2:2:O.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardLeftDoor4,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor41,"","","CRP1:5:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor41Status,"","","CRP1:5:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor42,"","","CRP1:5:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor4ReleaseSol,"","","CRP2:3:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardLeftDoor5,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor51,"","","CRP1:5:I.Pt04Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor51Status,"","","CRP1:5:I.Pt04Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor52,"","","CRP1:5:I.Pt05Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor5ReleaseSol,"","","CRP2:3:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardLeftDoor6,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor61,"","","CRP1:5:I.Pt06Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor61Status,"","","CRP1:5:I.Pt06Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor62,"","","CRP1:5:I.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor6ReleaseSol,"","","CRP2:3:O.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardLeftDoor7,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor71,"","","CRP1:6:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor71Status,"","","CRP1:6:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor72,"","","CRP1:6:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftDoor7ReleaseSol,"","","CRP2:3:O.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardLeftFeedrollDoorEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardLeftFeedrollDoorEStopPB1,"","","CRP1:1:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftFeedrollDoorEStopPB1Status,"","","CRP1:1:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftFeedrollDoorEStopPB2,"","","CRP1:1:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardLeftScaleBeltDoor,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardLeftScaleBeltDoor1,"","","CRP1:4:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftScaleBeltDoor1Status,"","","CRP1:4:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftScaleBeltDoor2,"","","CRP1:4:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardLeftScaleBeltDoorReleaseSol,"","","CRP2:2:O.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardMetalDetected,"Latched Bit Until Jogged Reverse","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardMetalDetector,"","","CCP:8:I.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRedStackLight,"","","CRP2:16:O.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardRightApronDoorEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardRightApronDoorEStopPB1,"","","CRP1:1:I.Pt06Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightApronDoorEStopPB1Status,"","","CRP1:1:I.Pt06Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightApronDoorEStopPB2,"","","CRP1:1:I.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardRightBottomAccessDoor,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardRightBottomAccessDoorReleaseSol,"","","CRP2:4:O.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightBottomPullCable1,"","","CRP1:8:I.Pt04Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightBottomPullCable1Status,"","","CRP1:8:I.Pt04Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightBottomPullCable2,"","","CRP1:8:I.Pt05Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardRightDoor1,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor11,"","","CRP1:6:I.Pt06Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor11Status,"","","CRP1:6:I.Pt06Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor12,"","","CRP1:6:I.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor1ReleaseSol,"","","CRP2:3:O.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardRightDoor2,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor21,"","","CRP1:7:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor21Status,"","","CRP1:7:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor22,"","","CRP1:7:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor2ReleaseSol,"","","CRP2:3:O.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardRightDoor3,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor31,"","","CRP1:7:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor31Status,"","","CRP1:7:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor32,"","","CRP1:7:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor3ReleaseSol,"","","CRP2:4:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardRightDoor4,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor41,"","","CRP1:7:I.Pt04Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor41Status,"","","CRP1:7:I.Pt04Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor42,"","","CRP1:7:I.Pt05Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor4ReleaseSol,"","","CRP2:4:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardRightDoor5,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor51,"","","CRP1:7:I.Pt06Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor51Status,"","","CRP1:7:I.Pt06Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor52,"","","CRP1:7:I.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor5ReleaseSol,"","","CRP2:4:O.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardRightDoor6,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor61,"","","CRP1:8:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor61Status,"","","CRP1:8:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor62,"","","CRP1:8:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor6ReleaseSol,"","","CRP2:4:O.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardRightDoor7,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor71,"","","CRP1:8:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor71Status,"","","CRP1:8:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor72,"","","CRP1:8:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightDoor7ReleaseSol,"","","CRP2:4:O.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardRightFeedrollDoorEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardRightFeedrollDoorEStopPB1,"","","CRP1:1:I.Pt04Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightFeedrollDoorEStopPB1Status,"","","CRP1:1:I.Pt04Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightFeedrollDoorEStopPB2,"","","CRP1:1:I.Pt05Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CardRightScaleBeltDoor,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CardRightScaleBeltDoor1,"","","CRP1:6:I.Pt04Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightScaleBeltDoor1Status,"","","CRP1:6:I.Pt04Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightScaleBeltDoor2,"","","CRP1:6:I.Pt05Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardRightScaleBeltDoorReleaseSol,"","","CRP2:3:O.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardTopLeftBrushWrap,"","","CRP2:12:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardTopRightBrushWrap,"","","CRP2:12:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CardYellowStackLight,"","","CRP2:16:O.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Card_Enabled,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,CCPComms,"","CommsCheck","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CCPEnclosureThermostat,"","","CCP:8:I.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CentralFiltrationRunning,"Pressure Switch$NRunning Proof","","CRP2:8:I.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,ChangedToNormalStopFault,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,Chutefeed,"","FineOpener","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
COMMENT,,Chutefeed,"Chutefeed Reserve Hopper Call to FS52",,"Chutefeed.STATUS.CALLFORFIBER"
TAG,,ChutefeedBeater,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedBeaterCont,"","","CCP:10:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedBeaterContAux,"","","CCP:6:I.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedBoxLowerPE,"","","CRP2:8:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedBoxUpperPE,"","","CRP2:8:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,ChutefeedCompaction,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedCompactionContAux,"","","CCP:6:I.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedCompactionRun,"","","CCP:10:O.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedCompactionSpeedRef,"","","CCP:5:O.Ch1Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,ChuteFeedDeliveryJogSpeed,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,ChutefeedDeliveryRoll,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,ChutefeedDoorLocks,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,ChutefeedFeedroll,"","SEWDrive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedFeedrollContAux,"","","CCP:6:I.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedFeedrollRun,"","","CCP:10:O.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedFeedrollSpeedRef,"","","CCP:5:O.Ch0Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,ChuteFeedFollowSpeed,"","LadderScale","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,ChutefeedFrontAccessDoor,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedFrontAccessDoor1,"","","CRP1:4:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedFrontAccessDoor1Status,"","","CRP1:4:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedFrontAccessDoor2,"","","CRP1:4:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedFrontAccessDoorReleaseSol,"","","CRP2:2:O.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,ChutefeedFrontLeftLeftDoor,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedFrontLeftLeftDoor1,"Operator Side Left","","CRP1:3:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedFrontLeftLeftDoor1Status,"Operator Side Left","","CRP1:3:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedFrontLeftLeftDoor2,"Operator Side Left","","CRP1:3:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,ChutefeedFrontLeftRightDoor,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedFrontLeftRightDoor1,"Operator Side Right","","CRP1:3:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedFrontLeftRightDoor1Status,"Operator Side Right","","CRP1:3:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedFrontLeftRightDoor2,"Operator Side Right","","CRP1:3:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,ChutefeedFrontRightLeftDoor,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedFrontRightLeftDoor1,"Opposite Side Left","","CRP1:3:I.Pt04Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedFrontRightLeftDoor1Status,"Opposite Side Left","","CRP1:3:I.Pt04Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedFrontRightLeftDoor2,"Opposite Side Left","","CRP1:3:I.Pt05Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,ChutefeedFrontRightRightDoor,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedFrontRightRightDoor1,"Opposite Side Right","","CRP1:3:I.Pt06Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedFrontRightRightDoor1Status,"Opposite Side Right","","CRP1:3:I.Pt06Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedFrontRightRightDoor2,"Opposite Side Right","","CRP1:3:I.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,ChutefeedPEStatus,"Debounced Status$N","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,ChutefeedPETOF,"Debounce Timer","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,ChutefeedPETON,"Debounce Timer$N","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedPhotohelicCloseOnPressure,"Min","","CRP2:8:I.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChutefeedPhotohelicOpenOnPressure,"Call","","CRP2:8:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,ChuteFeedRollFollowReference,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,chuteFeedTest,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,ChutefeedVentilators,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,ChuteFeedVentilatorsTempContactor,"","","CCP:11:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChuteFeedVentilatorsTempContactorFB,"","","CCP:9:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,ChuteReserveHopperLeftAccessDoor,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,ChuteReserveHopperLeftAccessDoor1,"","","CRP1:9:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChuteReserveHopperLeftAccessDoor1Status,"","","CRP1:9:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChuteReserveHopperLeftAccessDoor2,"","","CRP1:9:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,ChuteReserveHopperRightAccessDoor,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,ChuteReserveHopperRightAccessDoor1,"","","CRP1:9:I.Pt04Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChuteReserveHopperRightAccessDoor1Status,"","","CRP1:9:I.Pt04Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ChuteReserveHopperRightAccessDoor2,"","","CRP1:9:I.Pt05Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Chute_Delay_On,"","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,Chute_Delay_Run,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,ConveyorMovingTmr1,"Timer to Confirm Conveyor Movement Using the Prox","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,ConveyorMovingTmr2,"Timer to Confirm Conveyor Movement Using the Prox","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,CopyRecipeIndex,"Index Value for the $QCopy From$Q Recipe","INT","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,CopyRecipeSelectOS1,"One Shot","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,CopyRecipeSelectOS2,"One Shot","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,Crosslapper,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,CrosslapperCV1AccessDoor,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CrosslapperCV1AccessDoor1,"","","CRP1:2:I.Pt04Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CrosslapperCV1AccessDoor1Status,"","","CRP1:2:I.Pt04Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CrosslapperCV1AccessDoor2,"","","CRP1:2:I.Pt05Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CrosslapperCV1AccessDoorRelSol,"","","CRP2:4:O.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CrosslapperEStop,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CrosslapperEStop1,"","","PLCCP:2:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CrosslapperEStop1Status,"","","PLCCP:2:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CrosslapperEStop1StatusDelete,"","","PLCCP:2:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CrosslapperEStop2,"","","PLCCP:2:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CrosslapperEStopDilo,"","","PLCCP:12:I.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CrosslapperInline,"","","PLCCP:12:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CrosslapperLoadDataTimer,"Timer to Initiate Load in the Crosslapper PLC","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CrosslapperMessageEStopMaster,"","","PLCCP:19:O.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CrosslapperPlantOn,"","","PLCCP:19:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CrosslapperReadData,"JUST A LABEL","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CrosslapperReadyToStart,"","","PLCCP:12:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CrosslapperResetEStop,"","","PLCCP:19:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CrosslapperSafetyExpansion1,"","","PLCCP:5:O.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CrosslapperSafetyExpansion2,"","","PLCCP:5:O.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CrosslapperSafetyExpansionMonitor,"","","PLCCP:3:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CrosslapperSafetyExpansionMonitorStatus,"","","PLCCP:3:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CrosslapperSoftwareFastStop,"","","PLCCP:12:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CrosslapperSpeedFeedback,"","","PLCCP:7:I.Ch0Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,CrosslapperSpeedRef,"","","PLCCP:9:O.Ch0Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,CrosslapperZone,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,CrosslapperZoneExpansionUnitStatus,"","","PLCCP:5:I.Pt00OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Crosslapper_Analog_Maximum,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,Crosslapper_Analog_Minimum,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,Crosslapper_Bypass_Maximum,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,Crosslapper_Info,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,Crosslapper_Input_Maximum,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,Crosslapper_Output_Maximum,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,Crosslappe_Output_Minimum,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,CRP1Comms,"","CommsCheck","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,CRP2Comms,"","CommsCheck","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,CurrentIOStatus,"","STRING","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,CurrentLinePercent,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,CurrentSPRecipe,"","Recipe","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,DataFromExitPLC,"","DataTransfer","","(Class := Standard, Producer := ""ExitPLC"", RemoteTag := ""DataToCardPLC"", RemoteFile := 0, RPI := 20, Unicast := true, ExternalAccess := Read/Write)"
TAG,,DataToExitPLC,"Produced Tag to Exit PLC$N(DO NOT REMOVE)","DataTransfer","","(Class := Standard, ProduceCount := 1, ProgrammaticallySendEventTrigger := false, UnicastPermitted := true, Constant := false, ExternalAccess := Read/Write, MinimumRPI := 0.200, MaximumRPI := 536870.900, DefaultRPI := 0)"
TAG,,DeliveryRollSpeedScale,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,DeliveryRoll_Scale,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,DrafterBottomRollersLimitSwitch,"","","CRP2:14:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,DrafterDoorLocks,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,DrafterG1DrawRatio,"Draw Setpoint in Ratio Format","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,DrafterG2DrawRatio,"Draw Setpoint in Ratio Format","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,DrafterG3DrawRatio,"Draw Setpoint in Ratio Format","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,DrafterG4DrawRatio,"Draw Setpoint in Ratio Format","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,DrafterG5DrawRatio,"Draw Setpoint in Ratio Format","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,DrafterGroup1,"","SEWDrive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,DrafterGroup2,"","SEWDrive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,DrafterGroup3,"","SEWDrive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,DrafterGroup4,"","SEWDrive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,DrafterGroup5,"","SEWDrive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,DrafterLeftDoor1,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,DrafterLeftDoor11,"","","CRP1:8:I.Pt06Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,DrafterLeftDoor11Status,"","","CRP1:8:I.Pt06Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,DrafterLeftDoor12,"","","CRP1:8:I.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,DrafterLeftDoor1ReleaseSol,"","","CRP2:5:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,DrafterLeftEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,DrafterLeftEStopPB1,"","","CRP1:2:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,DrafterLeftEStopPB1Status,"","","CRP1:2:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,DrafterLeftEStopPB2,"","","CRP1:2:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,DrafterLiftMotor,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,DrafterLiftMotorDownContAux,"","","CCP:9:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,DrafterLiftMotorDownRun,"","","CCP:10:O.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,DrafterLiftMotorMSP,"","","CCP:6:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,DrafterLiftMotorUpContAux,"","","CCP:9:I.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,DrafterLiftMotorUpRun,"","","CCP:10:O.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,DrafterRightDoor1,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,DrafterRightDoor11,"","","CRP1:9:I.Pt06Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,DrafterRightDoor11Status,"","","CRP1:9:I.Pt06Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,DrafterRightDoor12,"","","CRP1:9:I.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,DrafterRightDoor1ReleaseSol,"","","CRP2:5:O.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,DrafterRightEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,DrafterRightEStopPB1,"","","CRP1:2:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,DrafterRightEStopPB1Status,"","","CRP1:2:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,DrafterRightEStopPB2,"","","CRP1:2:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,DrafterTopRollersLimitSwitch,"","","CRP2:14:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Drafter_enabled,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,DumpCompleteTimer,"Time for Weight Setpoint Reached Reset","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,ExitEquipment24VStatus,"","","PLCCP:13:I.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,ExitEquipmentEStop,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,ExitEquipmentEStop1,"","","PLCCP:2:I.Pt06Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ExitEquipmentEStop1Status,"","","PLCCP:2:I.Pt06Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ExitEquipmentEStop2,"","","PLCCP:2:I.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ExitEquipmentReadyToStart,"Accumulator Full","","PLCCP:13:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ExitEquipmentSafetyExpansion1,"","","PLCCP:5:O.Pt06Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ExitEquipmentSafetyExpansion2,"","","PLCCP:5:O.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ExitEquipmentSafetyExpansionMonitor,"","","PLCCP:3:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ExitEquipmentSafetyExpansionMonStatus,"","","PLCCP:3:I.Pt03Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,ExitEquipmentZone,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,ExitEquipmentZoneExpansionUnitStatus,"","","PLCCP:5:I.Pt06OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,ExitPLCComms,"","CommsCheck","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,FastStopFaults,"","Faults","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,FaultedString,"$QFaulted$Q String for Status","STRING","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,FeedRoll,"","SEWDrive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,FeedrollJogReversePB,"","","CRP2:8:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,FeedRollJogReverseTimer,"Timer to Unlatch Metal Detected","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,FeedRollPIDOutSet,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,FeedRollPIDProductionActual,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,FeedRollPIDProductionTarget,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,FeedRollRampedSetpoint,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,FeedRollSetpoint,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,FeedRollTargetSetpoint,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,FeedRoll_Setpoint_Mode,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,FeedRoll_Weigh_Mode,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,FeetToMetersMultiplier,"Multiplier for Conversion","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,FiveMinuteTimer,"","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,FOFeedroll,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,FollowScale,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,FOOutfeedFan,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,ForceZone10,"","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,ForceZone11,"","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,ForceZone12,"","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,ForceZone16,"","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,FS51Beater,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,FS51BeaterCont,"","","OBCP:18:O.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,FS51BeaterContAux,"","","OBCP:14:I.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,FS51BeaterZeroSpeed,"","","OBCP:1:I.Pt05Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,FS51BeaterZeroSpeedStatus,"","","OBCP:1:I.Pt05Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,FS51BeaterZSpeedStatus,"Motor at Stand Still Delayed Status","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,FS51FiberLowAlarmTimer,"Alarm Delay","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,FS51InspectionDoorSwitch,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,FS51InspectionDoorSwitch1,"","","VBORP:2:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,FS51InspectionDoorSwitch1Status,"","","VBORP:2:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,FS51InspectionDoorSwitch2,"","","VBORP:2:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,FS51LowPEStateTOF,"","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,FS51LowPEStateTON,"","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,FS51ReserveSiloFeedroll,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,FS51SiloFiberLevelLowerPE,"","","VBORP:4:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,FS51SiloFiberLevelUpperPE,"","","VBORP:4:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,FS51System,"","FineOpener","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,FS51_Ready,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,FS52Beater,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,FS52BeaterCont,"","","OBCP:18:O.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,FS52BeaterContAux,"","","OBCP:14:I.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,FS52BeaterZeroSpeed,"","","OBCP:1:I.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,FS52BeaterZeroSpeedStatus,"","","OBCP:1:I.Pt07Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,FS52BeaterZSpeedStatus,"Motor at Stand Still Delayed Status","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,FS52Comms,"","CommsCheck","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,FS52FeedRollAdjustedSpeed,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,FS52FeedRollMinimum,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,FS52FeedRollMinSpeed,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,FS52FeedRollSpeedControl,"","LadderScale","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,FS52FiberLowAlarmTimer,"Alarm Delay$N","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,FS52LowerInspectionDoorSwitch,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,FS52LowerInspectionDoorSwitch1,"","","FS52:2:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,FS52LowerInspectionDoorSwitch1Status,"","","FS52:2:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,FS52LowerInspectionDoorSwitch2,"","","FS52:2:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,FS52LowPEStateTOF,"","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,FS52LowPEStateTON,"","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,FS52PanelEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,FS52PanelEStopPB1,"","","FS52:1:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,FS52PanelEStopPB1Status,"","","FS52:1:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,FS52PanelEStopPB2,"","","FS52:1:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,FS52ReserveSiloFeedroll,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,FS52ReserveSiloOutfeedFan,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,FS52RPControlPower,"","","OBCP:11:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,FS52SiloFiberLowerPE,"","","FS52:4:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,FS52SiloFiberUpperPE,"","","FS52:4:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,FS52System,"","FineOpener","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,FS52UpperInspectionDoorSwitch,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,FS52UpperInspectionDoorSwitch1,"","","FS52:2:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,FS52UpperInspectionDoorSwitch1Status,"","","FS52:2:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,FS52UpperInspectionDoorSwitch2,"","","FS52:2:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,FS52_Ready,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,FS5XLowAlarmDelay,"Delay Fiber Low Alarm Timer","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,FS5XLowFiberAlarmLatch,"One of the Silos is Low on Fiber","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,FS5XLowFiberAlarmSlowMode,"Activate Slow Mode if one of the FS5 Silos is Low","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,GlobalSafetyExpansionMonitor,"","","OBCP:3:I.Pt06Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,GlobalSafetyExpansionMonitorStatus,"","","OBCP:3:I.Pt06Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,GlobalSafetyInputStatus,"Status of All Global  Safety Inputs","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,HMI1NormalStopPB,"","","PLCCP:11:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,HMI3NormalStopPB,"","","PLCCP:11:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,HMI4NormalStopPB,"","","PLCCP:11:I.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,HMIBottomScramblerRoll2Speed,"Roll 2 Speed for HMI Display","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMIStation1EStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,HMIStation1EStopPB1,"","","PLCCP:1:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,HMIStation1EStopPB1Status,"","","PLCCP:1:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,HMIStation1EStopPB2,"","","PLCCP:1:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,HMIStation1GreenPL,"","","PLCCP:16:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,HMIStation1Horn,"","","PLCCP:16:O.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,HMIStation1RedPL,"","","PLCCP:16:O.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,HMIStation1YellowPL,"","","PLCCP:16:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,HMIStation2EStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,HMIStation2GreenPL,"","","PLCCP:16:O.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,HMIStation2Horn,"","","PLCCP:16:O.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,HMIStation2Horn120,"","","PLCCP:17:O.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,HMIStation2RedPL,"","","PLCCP:16:O.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,HMIStation2YellowPL,"","","PLCCP:16:O.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,HMIStation3EStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,HMIStation3EStopPB1,"","","PLCCP:1:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,HMIStation3EStopPB1Status,"","","PLCCP:1:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,HMIStation3EStopPB2,"","","PLCCP:1:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,HMIStation3Horn120,"","","PLCCP:17:O.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,HMIStation4EStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,HMIStation4EStopPB1,"","","PLCCP:1:I.Pt06Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,HMIStation4EStopPB1Status,"","","PLCCP:1:I.Pt06Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,HMIStation4EStopPB2,"","","PLCCP:1:I.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,HMIStation4GreenPL,"","","PLCCP:17:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,HMIStation4Horn,"","","PLCCP:17:O.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,HMIStation4RedPL,"","","PLCCP:17:O.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,HMIStation4YellowPL,"","","PLCCP:17:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,HMITopScramblerRoll2Speed,"Roll 2 Speed for HMI Display","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_BlendingAlarmSilence,"Button on the HMI","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CalenderReadyToStart,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CalenderSpeedFPM,"Calender Speed in Feet/Minute","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CalenderSpeedMPM,"Calender Speed in Meters/Minute","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CalenderSpeedRefFPM,"Speed Ref Being Sent to the Calender in Feet/Minute","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CalenderSpeedRefMPM,"Reference Being Sent to the Calender in Meters/Minute","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CancelRecipeAction,"Cancel Requested Recipe Action","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CopyRecipe,"First Step in Copying a Recipe","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CopyRecipeActive,"First Step is Active for Copying a Recipe","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CopyRecipeConfirm,"Copy Recipe Request Confirm Command","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CopySelectRecipe,"Index Value for Selected the $QCopy From$Q Recipe","INT","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CopySelectRecipeDec,"Decrement Command for Selecting the $QCopy From$Q Recipe","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CopySelectRecipeInc,"Increment Command for Selecting the $QCopy From$Q Recipe","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperApronHeightMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperApronHeightMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperApronHeightRMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperApronHeightRMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperDraftMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperDraftMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperEntryWidthMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperEntryWidthMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperExitWidthLMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperExitWidthLMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperExitWidthMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperExitWidthMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperLayerOverlapMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperLayerOverlapMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperNumberOfLayersMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperNumberOfLayersMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperProf1Max,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperProf1Min,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperProf2Max,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperProf2Min,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperProf3Max,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperProf3Min,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperProf4Max,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperProf4Min,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperProf5Max,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperProf5Min,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperProf6Max,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperProf6Min,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperProf7Max,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperProf7Min,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperProf8Max,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperProf8Min,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperProfMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperProfMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperSetpointError,"Entered Setpoint Out of Range for the Crosslapper","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperSpeedMPM,"Crosslapper Speed Feedback in Meters/Minute for Display","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_CrosslapperSpeedRefMPM,"Speed Setpoint Sent to the Crosslapper in Meter/Minute","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_DisableMahloControl,"Command$N","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_DrafterBottomRollersLimit,"Display for HMI","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_DrafterSectionDraw,"Total Draw for Drafter Section","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_DrafterSectionDrawRatio,"Drafter Section Total Draw Ratio","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_DrafterTopRollersLimit,"Display for HMI","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_EnableMahloControl,"Command","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_ExitEquipmentReady,"Display for Screen","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_FeedrollToSetpointMode,"Command from HMI","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_FeedRollToWeighMode,"Command from HMI","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_FingerRollersDraft,"Setpoint Data to be Scaled Before Going to the Looms$' PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_InfeedApronDraft,"Setpoint Data to be Scaled Before Going to the Looms$' PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_LineTotalDraw,"Total Line Draw from Apron to Calender","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_LoadedRecipe,"For HMI Display$NValue from Loaded Recipe","Recipe","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_LoadRecipe,"Command to Load Recipe to Line","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_LoadRecipeActive,"The First Step to Load Recipe Is Active$N(Confirmation Required to Complete)","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_LoadRecipeConfirm,"Step 2 In Loading a Recipe$N","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_LoadSelectRecipe,"Recipe Selected for Loading","INT","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_LoadSelectRecipeDec,"Decrement Selected Load Recipe","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_LoadSelectRecipeInc,"Increment Selected Load Recipe","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_LoomSetpointError,"Entered Setpoint Out of Range for Looms","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_LoomSpeedFPM,"Loom Speed in Feet/Minute","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_LoomSpeedMPM,"Loom Speed in Meters/Minute","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_LoomsSpeedRefFPM,"Reference Being Sent to the Looms in Feet/Minute","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_LoomsSpeedRefMPM,"Reference Sent to to Looms in Meters/Minute","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1AdvancePerStroke,"Setpoint Data to be Scaled Before Going to the Looms$' PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1AdvancePerStrokeMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1AdvancePerStrokeMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1AdvancePerStrokeSetpointFB,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1DrawOffDraft,"Setpoint Data to be Scaled Before Going to the Looms$' PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1DrawOffDraftActual,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1DrawOffDraftSetpointFB,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1DrawOffSpeedActual,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1FingerRollerDraftActual,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1FingerRollerDraftMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1FingerRollerDraftMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1FingerRollerDraftSetpointFB,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1FingerRollerGapActual,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1FingerRollerSpeedActual,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1Gap,"Setpoint Data to be Scaled Before Going to the Looms$' PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1GapActual,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1GapMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1GapMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1GapSetpointFB,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1InfeedApronDraftMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1InfeedApronDraftMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1InfeedDraftActual,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1InfeedDraftMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1InfeedDraftMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1InfeedDraftSetpointFB,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1InfeedSpeedActual,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1InfeedSpeedSetpointFB,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1NeedleDensitySetpointFB,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1needleLength,"Setpoint Data to be Scaled Before Going to the Looms$' PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1NeedleLengthMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1NeedleLengthMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1NeedleLengthSetpointFB,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1OutfeedDraftMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1OutfeedDraftMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1Penetration,"Setpoint Data to be Scaled Before Going to the Looms$' PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1PenetrationAcutal,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1PenetrationMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1PenetrationMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1PenetrationSetpointFB,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1SpeedMasterActual,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1StitchingDensitySetpointFB,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M1StrokeFrequencyActual,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2AdvancePerStroke,"Setpoint Data to be Scaled Before Going to the Looms$' PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2AdvancePerStrokeMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2AdvancePerStrokeMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2AdvancePerStrokeSetpointFB,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2DrawOffDraft,"Setpoint Data to be Scaled Before Going to the Looms$' PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2DrawOffDraftActual,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2DrawOffDraftSetpointFB,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2DrawOffSpeedActual,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2Gap,"Setpoint Data to be Scaled Before Going to the Looms$' PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2GapActual,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2GapMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2GapMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2GapSetpointFB,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2InfeedDraft,"Setpoint Data to be Scaled Before Going to the Looms$' PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2InfeedDraftActual,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2InfeedDraftMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2InfeedDraftMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2InfeedDraftSetpointFB,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2InfeedSpeedActual,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2InfeedSpeedSetpointFB,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2NeedleDensityBottomSetpointFB,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2NeedleDensityTopSetpointFB,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2NeedleLengthBottom,"Setpoint Data to be Scaled Before Going to the Looms$' PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2NeedleLengthBottomMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2NeedleLengthBottomMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2NeedleLengthBottomSetpointFB,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2NeedleLengthTop,"Setpoint Data to be Scaled Before Going to the Looms$' PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2NeedleLengthTopMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2NeedleLengthTopMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2NeedleLengthTopSetpointFB,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2OutfeedDraftMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2OutfeedDraftMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2PenetrationBottom,"Setpoint Data to be Scaled Before Going to the Looms$' PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2PenetrationBottomActual,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2PenetrationBottomMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2PenetrationBottomMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2PenetrationBottomSetpointFB,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2PenetrationTop,"Setpoint Data to be Scaled Before Going to the Looms$' PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2PenetrationTopActual,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2PenetrationTopMax,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2PenetrationTopMin,"Value Derived from Siemens PLC Registers","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2PenetrationTopSetpointFB,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2StitchingDensitySetpointFB,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_M2StrokeFrequencyActual,"Read from the Looms PLC and Scaled $N(if Necessary)","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_NewRecipeName,"New Recipe Name for the $QPaste To$Q Recipe","STRING","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_PasteSelectRecipe,"Index Value for Selected the $QPaste To$Q Recipe","INT","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_PasteSelectRecipeDec,"Decrement Command for Selecting the $QPaste To$Q Recipe","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_PasteSelectRecipeInc,"Increment Command for Selecting the $QPaste To$Q Recipe","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_RCApronHeightFBLeft,"Scaled Value From the Red Lion DSP","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_RCApronHeightFBRight,"Scaled Value From the Red Lion DSP","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_RCCrosslapperDraft,"Scaled Value From the Red Lion DSP","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_RCEntryWidth,"Scaled Value From the Red Lion DSP","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_RCExitWidthLeft,"Scaled Value From the Red Lion DSP","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_RCExitWidthRight,"Scaled Value From the Red Lion DSP","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_RCLayerOverlap,"Scaled Value From the Red Lion DSP","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_RCNumberOfLayers,"Scaled Value From the Red Lion DSP","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_RCProfileFB0,"Scaled Value From the Red Lion DSP","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_RCProfileFB1,"Scaled Value From the Red Lion DSP","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_RCProfileFB2,"Scaled Value From the Red Lion DSP","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_RCProfileFB3,"Scaled Value From the Red Lion DSP","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_RCProfileFB4,"Scaled Value From the Red Lion DSP","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_RCProfileFB5,"Scaled Value From the Red Lion DSP","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_RCProfileFB6,"Scaled Value From the Red Lion DSP","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_RCProfileFB7,"Scaled Value From the Red Lion DSP","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_RCProfileFB8,"Scaled Value From the Red Lion DSP","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_SaveRecipe,"Command to Save Current Setpoints to Selected Recipe$N","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_SaveRecipeActive,"First Step in Saving Recipe$NConfirm to Follow","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_SaveRecipeConfirm,"Save Recipe Command Confirm","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_SaveRecipeName,"","STRING","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_SaveSelectRecipe,"Save Recipe Index$N(Recipe to Receive Values)","INT","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_SaveSelectRecipeDec,"Decrement $QSave to$Q Recipe Index","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_SaveSelectRecipeInc,"Increment $QSave to$Q Recipe Index","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_SendCrosslapperSetpoints,"Manual Pushbutton from HMI to Send Entered Values","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_SendLoomSetpoints,"Manual Pushbutton from HMI to Send Entered Values","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_StartMahloControl,"Command","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,HMI_Station1SlowModePB,"","","PLCCP:11:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,HMI_Station2SlowModePB,"","","PLCCP:11:I.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,HMI_Station4SlowModePB,"","","PLCCP:11:I.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,HMI_StopMahloControl,"Command$N","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_ViewRecipe,"","Recipe","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_ViewSelectRecipe,"Index for $QView$Q Recipe","DINT","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_ViewSelectRecipeDec,"Decrement Command for $QView$Q Recipe","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_ViewSelectRecipeInc,"Increment Command for $QView$Q Recipe","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_WCApronHeightLeftSetpoint,"Setpoint Data to be Scaled Before Going to the XLPR PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_WCApronHeightRightSetpoint,"Setpoint Data to be Scaled Before Going to the XLPR PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_WCLapperDraft,"Setpoint Data to be Scaled Before Going to the XLPR PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_WCLapperEntryWidth,"Setpoint Data to be Scaled Before Going to the XLPR PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_WCLapperExitWidthLeft,"Setpoint Data to be Scaled Before Going to the XLPR PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_WCLapperExitWidthRight,"Setpoint Data to be Scaled Before Going to the XLPR PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_WCLayerOverlap,"Setpoint Data to be Scaled Before Going to the XLPR PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_WCNumberOfLayers,"Setpoint Data to be Scaled Before Going to the XLPR PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_WCProfileSetpoint0,"Setpoint Data to be Scaled Before Going to the XLPR PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_WCProfileSetpoint1,"Setpoint Data to be Scaled Before Going to the XLPR PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_WCProfileSetpoint2,"Setpoint Data to be Scaled Before Going to the XLPR PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_WCProfileSetpoint3,"Setpoint Data to be Scaled Before Going to the XLPR PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_WCProfileSetpoint4,"Setpoint Data to be Scaled Before Going to the XLPR PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_WCProfileSetpoint5,"Setpoint Data to be Scaled Before Going to the XLPR PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_WCProfileSetpoint6,"Setpoint Data to be Scaled Before Going to the XLPR PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_WCProfileSetpoint7,"Setpoint Data to be Scaled Before Going to the XLPR PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HMI_WCProfileSetpoint8,"Setpoint Data to be Scaled Before Going to the XLPR PLC","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,HornBeeper,"On 1 Cycle$NOff 1 Cycle$Nof Blending Horn Timer","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HornFlipFlopBit,"Bit for Toggling the JK Flipflop","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,HornJK,"","JKFlipFLop","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,InitiateCopyRecipe,"Copy Recipe Request Confirmed","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,InitiateLoadRecipe,"Load Recipe Confirmed and Load Initiated","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,InitiateSaveRecipe,"Actual Save Action Bit","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,IOLEDDescriptions,"","STRING[5]","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,IOModuleFault,"An Item in the I/O Configuration is Faulted","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,IO_LEDStatus,"","INT","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,LeftMetalDetectorBuzzer,"","","PLCCP:18:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,LeftMetalDetectorLight,"","","PLCCP:18:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,LeftSideBuzzerTime,"Time for Buzzer","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,LeftSideMetalDetected,"Left Metal Detector Triggered","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,LeftSideMetalDetector,"","","PLCCP:14:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,LineActRamp,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,LineSetSpeed,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,LineStoppedOS,"One shot","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,Line_Ready,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,Line_Start,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,LoadRecipeIndex,"Index Number for Indirect Addressing","INT","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,LoadRecipeSelectOS1,"One Shot","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,LoadRecipeSelectOS2,"One Shot","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Local24VDCControlPower,"","","CCP:6:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,LoomDifference,"Positive = Analog Too Fast","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,LoomsEStop,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,LoomsEStop1,"","","PLCCP:2:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,LoomsEStop1Status,"","","PLCCP:2:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,LoomsEStop2,"","","PLCCP:2:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,LoomsEStopDilo,"","","PLCCP:12:I.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,LoomsInline,"","","PLCCP:12:I.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,LoomsLoadDataTimer,"Timer to Initiate Load in the Looms$' PLC","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,LoomsMessageEStopMaster,"","","PLCCP:20:O.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,LoomsPlantOn,"","","PLCCP:20:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,LoomsReadyToStart,"","","PLCCP:12:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,LoomsResetEStop,"","","PLCCP:20:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,LoomsSafetyExpansion1,"","","PLCCP:5:O.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,LoomsSafetyExpansion2,"","","PLCCP:5:O.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,LoomsSafetyExpansionMonitor,"","","PLCCP:3:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,LoomsSafetyExpansionMonitorStatus,"","","PLCCP:3:I.Pt01Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,LoomsSoftwareFastStop,"","","PLCCP:12:I.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,LoomsSpeedFeedback,"","","PLCCP:7:I.Ch1Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,LoomsSpeedRef,"","","PLCCP:9:O.Ch1Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,LoomsSpeedRefScaler,"","Scaler","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,LoomsSpeedScaler,"","Scaler","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,LoomsZone,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,LoomsZoneExpansionUnitStatus,"","","PLCCP:5:I.Pt02OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Looms_Enabled,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,Looms_Info,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,Looms_Off,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,Looms_On,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,LowFiberHornTimer,"Timer for Pulsing Horn","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,MainCylinder,"","SEWDrive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,MainCylinderBrakeResistorTherm,"","","CCP:6:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,MainScaleActWeight,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,MainscaleAverage,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,MainScaleSetpoint,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,MaximumPoundsProduction,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,MaximumProduction,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,MetalDetectorPower,"Metal Detectors Power Relay","","PLCCP:14:I.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,MetalDetectTestOS,"One Shot","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,MetalDetectTestTimer,"","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,MetersToFeetMultiplier,"Multiplier for Conversion$N","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,No,"Always Off","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,NormalStopFaults,"","Faults","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,NotApplicable,"Doesn$'t Matter","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,nothing,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,OB1DisconnectAux,"","","OBCP:10:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,OB1DisconnectSafety,"Mapped from Non-Safety Input","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,OB1DisconnectToSafety,"For Safety Mapping","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,OB1RPComms,"","CommsCheck","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,OB2DisconnectAux,"","","OBCP:10:I.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,OB2DisconnectSafety,"Mapped from Non-Safety Input","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,OB2DisconnectToSafety,"For Safety Mapping","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,OB2RPComms,"","CommsCheck","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,OB3DisconnectAux,"","","OBCP:10:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,OB3DisconnectSafety,"Mapped from Non-Safety Input","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,OB3DisconnectToSafety,"For Safety Mapping","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,OB3RPComms,"","CommsCheck","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,OB4DisconnectAux,"","","OBCP:10:I.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,OB4DisconnectSafety,"Mapped from Non-Safety Input","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,OB4DisconnectToSafety,"For Safety Mapping","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,OB4RPComms,"","CommsCheck","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,OB5DisconnectAux,"","","OBCP:10:I.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,OB5DisconnectSafety,"Mapped from Non-Safety Input","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,OB5DisconnectToSafety,"For Safety Mapping","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,OB5RPComms,"","CommsCheck","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,OBCPComms,"","CommsCheck","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,OBCPEnclosureThermostat,"","","OBCP:11:I.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,OBCPLocalControlPower,"","","OBCP:10:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,OBCPRemoteControlPower,"","","OBCP:10:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,PasteRecipeIndex,"Index Value for the $QPaste To$Q Recipe","INT","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,PasteRecipeSelectOS1,"One Shot","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,PasteRecipeSelectOS2,"One Shot","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,PhotohelicMinDebounceTimer,"","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,PLCCPComms,"","CommsCheck","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,PLCCPThermostat,"","","PLCCP:11:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,PoundsDisplayAverageSeconds,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,PoundsPerHour,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,PoundsPerHour1,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,Pounds_Smoothing,"","DriveRamp","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,ProgramScanCount,"","DINT","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,ProttTransportMotor,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,ProttTransportMotorCont,"","","CCP:10:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,ProttTransportMotorContAux,"","","CCP:8:I.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCApronHeightFBLeft,"Read From$NDB151:74","","RedLionDSP:I.Data[111]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCApronHeightFBRight,"Read From$NDB151:76","","RedLionDSP:I.Data[112]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCCrosslapperApronHeightMax,"","","RedLionDSP:I.Data[131]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCCrosslapperApronHeightMin,"","","RedLionDSP:I.Data[130]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCCrosslapperDraft,"Read From$NDB151:26","","RedLionDSP:I.Data[101]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCCrosslapperDraftMax,"","","RedLionDSP:I.Data[119]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCCrosslapperDraftMin,"","","RedLionDSP:I.Data[118]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCCrosslapperEntryWidthMax,"","","RedLionDSP:I.Data[125]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCCrosslapperEntryWidthMin,"","","RedLionDSP:I.Data[124]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCCrosslapperExitWidthMax,"","","RedLionDSP:I.Data[123]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCCrosslapperExitWidthMin,"","","RedLionDSP:I.Data[122]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCCrosslapperLayerOverlapMax,"","","RedLionDSP:I.Data[129]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCCrosslapperLayerOverlapMin,"","","RedLionDSP:I.Data[128]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCCrosslapperNumberOfLayersMax,"","","RedLionDSP:I.Data[127]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCCrosslapperNumberOfLayersMin,"","","RedLionDSP:I.Data[126]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCCrosslapperProfMax,"","","RedLionDSP:I.Data[121]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCCrosslapperProfMin,"","","RedLionDSP:I.Data[120]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCEntryWidth,"Read From$NDB151:96","","RedLionDSP:I.Data[115]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCExitWidthLeft,"Read From$NDB151:98","","RedLionDSP:I.Data[116]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCExitWidthRight,"Read From$NDB151:100","","RedLionDSP:I.Data[117]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCLayerOverlap,"Read From$NDB151:94","","RedLionDSP:I.Data[114]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCNumberOfLayers,"Read From$NDB151:92","","RedLionDSP:I.Data[113]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCProfileFB0,"Read From$NDB151:28","","RedLionDSP:I.Data[102]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCProfileFB1,"Read From$NDB151:30","","RedLionDSP:I.Data[103]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCProfileFB2,"Read From$NDB151:32","","RedLionDSP:I.Data[104]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCProfileFB3,"Read From$NDB151:34","","RedLionDSP:I.Data[105]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCProfileFB4,"Read From$NDB151:36","","RedLionDSP:I.Data[106]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCProfileFB5,"Read From$NDB151:38","","RedLionDSP:I.Data[107]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCProfileFB6,"Read From$NDB151:40","","RedLionDSP:I.Data[108]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCProfileFB7,"Read From$NDB151:42","","RedLionDSP:I.Data[109]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCProfileFB8,"Read From$NDB151:44","","RedLionDSP:I.Data[110]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RCSetpointError,"Read From$N106.2","","RedLionDSP:I.Data[100].10","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Recipes,"","Recipe[300]","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,RedLionDSPComms,"","CommsCheck","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,RH1BlowInHood1Sol,"","","RH1RP:6:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH1BlowInHood2Sol,"","","RH1RP:6:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH1BlowInHoodBetweenPE,"","","RH1RP:5:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH1BlowInHoodPE1,"","","RH1RP:5:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH1BlowInHoodPE2,"","","RH1RP:5:I.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH1BlowInHoodValve1Confirm,"","","RH1RP:5:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH1BlowInHoodValve2Confirm,"","","RH1RP:5:I.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,RH1DeliveryFan,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,RH1DeliveryFanCont,"","","OBCP:17:O.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH1DeliveryFanContAux,"","","OBCP:13:I.6","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH1DemandSignal,"","","RH1RP:7:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH1DisconnectAux,"","","OBCP:11:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,RH1Doffer,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,RH1DofferCont,"","","OBCP:17:O.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH1DofferContAux,"","","OBCP:13:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH1DofferZeroSpeed,"","","OBCP:1:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH1DofferZeroSpeedStatus,"","","OBCP:1:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,RH1DofferZSpeedStatus,"Motor at Stand Still Delayed Status","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,RH1DoorLocks,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,RH1ExtendedApron,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,RH1ExtendedApronPE,"","","RH1RP:5:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,RH1LeftEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,RH1LeftEStopPB1,"","","RH1RP:1:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH1LeftEStopPB1Status,"","","RH1RP:1:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH1LeftEStopPB2,"","","RH1RP:1:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,RH1LiftApron,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,RH1OutfeedFan,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,RH1OutfeedFanCont,"","","OBCP:17:O.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH1OutfeedFanContAux,"","","OBCP:13:I.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,RH1RightEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,RH1RightEStopPB1,"","","RH1RP:1:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH1RightEStopPB1Status,"","","RH1RP:1:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH1RightEStopPB2,"","","RH1RP:1:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,RH1RPComms,"","CommsCheck","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,RH1SideAccessDoorReleaseSol,"","","RH1RP:3:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,RH1SideAccessDoorSwitch,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,RH1SideAccessDoorSwitch1,"","","RH1RP:2:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH1SideAccessDoorSwitch1Status,"","","RH1RP:2:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH1SideAccessDoorSwitch2,"","","RH1RP:2:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,RH1TopAccessHatch,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,RH1TopAccessHatch1,"","","RH1RP:2:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH1TopAccessHatch1Status,"","","RH1RP:2:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH1TopAccessHatch2,"","","RH1RP:2:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH1TopAccessHatchReleaseSol,"","","RH1RP:3:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH2BlowInHood1Sol,"","","RH2RP:6:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH2BlowInHood2Sol,"","","RH2RP:6:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH2BlowInHoodBetweenPE,"","","RH2RP:5:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH2BlowInHoodPE1,"","","RH2RP:5:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH2BlowInHoodPE2,"","","RH2RP:5:I.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH2BlowInHoodValve1Confirm,"","","RH2RP:5:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH2BlowInHoodValve2Confirm,"","","RH2RP:5:I.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,RH2DeliveryFan,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,RH2DeliveryFanCont,"","","OBCP:18:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH2DeliveryFanContAux,"","","OBCP:14:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH2DemandSignal,"","","RH2RP:7:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH2DisconnectAux,"","","OBCP:11:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,RH2Doffer,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,RH2DofferCont,"","","OBCP:17:O.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH2DofferContAux,"","","OBCP:13:I.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH2DofferZeroSpeed,"","","OBCP:1:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH2DofferZeroSpeedStatus,"","","OBCP:1:I.Pt03Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,RH2DofferZSpeedStatus,"Motor at Stand Still Delayed Status","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,RH2DoorLocks,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,RH2ExtendedApron,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,RH2ExtendedApronPE,"","","RH2RP:5:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,RH2LeftEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,RH2LeftEStopPB1,"","","RH2RP:1:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH2LeftEStopPB1Status,"","","RH2RP:1:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH2LeftEStopPB2,"","","RH2RP:1:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,RH2LiftApron,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,RH2OutfeedFan,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,RH2OutfeedFanCont,"","","OBCP:18:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH2OutfeedFanContAux,"","","OBCP:14:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,RH2RightEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,RH2RightEStopPB1,"","","RH2RP:1:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH2RightEStopPB1Status,"","","RH2RP:1:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH2RightEStopPB2,"","","RH2RP:1:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,RH2RPComms,"","CommsCheck","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,RH2SideAccessDoorReleaseSol,"","","RH2RP:3:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,RH2SideAccessDoorSwitch,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,RH2SideAccessDoorSwitch1,"","","RH2RP:2:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH2SideAccessDoorSwitch1Status,"","","RH2RP:2:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH2SideAccessDoorSwitch2,"","","RH2RP:2:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,RH2TopAccessHatch,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,RH2TopAccessHatch1,"","","RH2RP:2:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH2TopAccessHatch1Status,"","","RH2RP:2:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH2TopAccessHatch2,"","","RH2RP:2:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RH2TopAccessHatchReleaseSol,"","","RH2RP:3:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RightMetalDetectorBuzzer,"","","PLCCP:18:O.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RightMetalDetectorLight,"","","PLCCP:18:O.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,RightSideBuzzerTime,"Time for Buzzer","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,RightSideMetalDetected,"Right Metal Detector Triggered","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,RightSideMetalDetector,"","","PLCCP:14:I.5","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1AdvancePerStrokeMax,"","","RedLionDSP:I.Data[48]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1AdvancePerStrokeMin,"","","RedLionDSP:I.Data[47]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1AdvancePerStrokeSP,"","","RedLionDSP:I.Data[24]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1DrawOffDraftAct,"","","RedLionDSP:I.Data[3]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1DrawOffDraftSP,"","","RedLionDSP:I.Data[21]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1DrawOffSpeedAct,"","","RedLionDSP:I.Data[6]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1FingerRollerDraftAct,"","","RedLionDSP:I.Data[2]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1FingerRollerDraftMax,"","","RedLionDSP:I.Data[44]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1FingerRollerDraftMin,"","","RedLionDSP:I.Data[43]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1FingerRollerDraftSP,"","","RedLionDSP:I.Data[20]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1FingerRollersGapAct,"","","RedLionDSP:I.Data[10]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1FingerRollerSpeedAct,"","","RedLionDSP:I.Data[5]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1GapAct,"","","RedLionDSP:I.Data[9]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1GapMax,"","","RedLionDSP:I.Data[52]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1GapMin,"","","RedLionDSP:I.Data[51]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1GapSP,"","","RedLionDSP:I.Data[28]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1InfeedApronDraftMax,"","","RedLionDSP:I.Data[42]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1InfeedApronDraftMin,"","","RedLionDSP:I.Data[41]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1InfeedDraftAct,"","","RedLionDSP:I.Data[1]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1InfeedDraftSP,"","","RedLionDSP:I.Data[19]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1InfeedSpeedAct,"","","RedLionDSP:I.Data[4]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1InfeedSpeedSP,"","","RedLionDSP:I.Data[22]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1NeedleDensitySP,"","","RedLionDSP:I.Data[23]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1NeedleLengthSP,"","","RedLionDSP:I.Data[26]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1OutfeedDraftMax,"","","RedLionDSP:I.Data[46]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1OutfeedDraftMin,"","","RedLionDSP:I.Data[45]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1PenetrationAct,"","","RedLionDSP:I.Data[8]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1PenetrationMax,"","","RedLionDSP:I.Data[50]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1PenetrationMin,"","","RedLionDSP:I.Data[49]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1PenetrationSP,"","","RedLionDSP:I.Data[27]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1SpeedMasterAct,"","","RedLionDSP:I.Data[0]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1StitchingDensitySP,"","","RedLionDSP:I.Data[25]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM1StrokeFreqAct,"","","RedLionDSP:I.Data[7]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2AdvancePerStrokeMax,"","","RedLionDSP:I.Data[58]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2AdvancePerStrokeMin,"","","RedLionDSP:I.Data[57]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2AdvancePerStrokeSP,"","","RedLionDSP:I.Data[34]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2DrawOffDraftAct,"","","RedLionDSP:I.Data[12]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2DrawOffDraftSP,"","","RedLionDSP:I.Data[30]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2DrawOffSpeedAct,"","","RedLionDSP:I.Data[14]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2GapAct,"","","RedLionDSP:I.Data[18]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2GapMax,"","","RedLionDSP:I.Data[64]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2GapMin,"","","RedLionDSP:I.Data[63]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2GapSP,"","","RedLionDSP:I.Data[40]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2InfeedDraftAct,"","","RedLionDSP:I.Data[11]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2InfeedDraftMax,"","","RedLionDSP:I.Data[54]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2InfeedDraftMin,"","","RedLionDSP:I.Data[53]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2InfeedDraftSP,"","","RedLionDSP:I.Data[29]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2InfeedSpeedAct,"","","RedLionDSP:I.Data[13]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2InfeedSpeedSP,"","","RedLionDSP:I.Data[31]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2NeedleDensityBottomSP,"","","RedLionDSP:I.Data[33]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2NeedleDensityTopSP,"","","RedLionDSP:I.Data[32]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2NeedleLengthBottomSP,"","","RedLionDSP:I.Data[37]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2NeedleLengthTopSP,"","","RedLionDSP:I.Data[36]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2OutfeedDraftMax,"","","RedLionDSP:I.Data[56]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2OutfeedDraftMin,"","","RedLionDSP:I.Data[55]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2PenetrationBottomAct,"","","RedLionDSP:I.Data[17]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2PenetrationBottomMax,"","","RedLionDSP:I.Data[62]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2PenetrationBottomMin,"","","RedLionDSP:I.Data[61]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2PenetrationBottomSP,"","","RedLionDSP:I.Data[39]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2PenetrationTopAct,"","","RedLionDSP:I.Data[16]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2PenetrationTopMax,"","","RedLionDSP:I.Data[60]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2PenetrationTopMin,"","","RedLionDSP:I.Data[59]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2PenetrationTopSP,"","","RedLionDSP:I.Data[38]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2StitchingDensitySP,"","","RedLionDSP:I.Data[35]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,RLM2StrokeFreqAct,"","","RedLionDSP:I.Data[15]","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,RunScanCounter,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,Run_Chute_Test,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,SafetyAlarms,"","Alarms","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
TAG,,SafetyCardCoverFailedToRun,"Failed to Run Status","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,SafetyCardCoverFailedToStop,"Failed to Stop Status$N","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,SafetyCardCoverFailToRun,"Safety Timer","TIMER","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
TAG,,SafetyCardCoverFailToStop,"Safety Timer","TIMER","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
TAG,,SafetyCardCoverFault,"Fault Status$N","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,SafetyFaultReset,"Non-Safety Tag Linked to Safety Tag for Safety Routines","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,SafetyInstructionFaultReset,"Manual Command for Testing Only","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,SafetyNo,"Always Off","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,SafetyReset,"","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,SafetyYes,"Always On","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,SafetyZoneReset,"Non-Safety Tag Linked to Safety Tag to Reset E-Stop Zones","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,SafetyZoneResetStagger,"Stagger Resets So They$'re not All at Once","TIMER","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
TAG,,SafetyZonesReset,"Resets Safety Zones","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,SaveRecipeIndex,"Indirect Index Pointer","INT","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,SaveRecipeSelectOS1,"One Shot","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,SaveRecipeSelectOS2,"One Shot","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,ScaleAverageSeconds,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,ScaleBelt,"","SEWDrive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,ScaleBeltMax,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,ScaleBeltScaler,"","Scaler","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,ScaleBeltWeight,"","","CRP2:7:I.Ch0Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Scale_Smoothing,"","DriveRamp","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,ScanCountReset,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,ScanPerSecond,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,ScansPerMinute,"","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,SetRecipeNumbers,"Sets Recipe Number Values Inside the Recipe","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,SetRecipeNumbersIndex,"","DINT","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,SEWFaults,"List of Faults for the SEW Drives","STRING[200]","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,SEWStatus,"List Of Status Strings for the SEW Drive","STRING[20]","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,SlowModeOS,"One Shot for Slow Mode Toggle","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,SlowModeOS2,"One Shot for Slow Mode","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,SlowModeOS3,"One Shot for Slow Mode","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,StartMahloControlHoldInTmr,"Hold in the Command for a Time","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,Start_Chute_Delivery,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,StopMahloControlHoldInTmr,"Hold in the Command for a Time","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,System,"","System","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,TestBlendingHorn,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,TestBO3BreakerContactor,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,TestCardHorn,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,TestPulses,"Just Used to Test Pulses","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,TestXLPRTakeover,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,TestZone1B,"","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,test_call,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,test_chute,"","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,TH6,"","Hopper","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,TH6Damper,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,TH6DisconnectAux,"","","OBCP:10:I.7","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,TH6DisconnectSafety,"Mapped from Non-Safety Input","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,TH6DisconnectToSafety,"For Safety Mapping","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,TH6Doffer,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,TH6DofferCont,"","","OBCP:17:O.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH6DofferContAux,"","","OBCP:13:I.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH6DofferContAuxSafe,"","","OBCP:1:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,TH6DoorLocks,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,TH6Dump,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,TH6ExtendedApronPE,"","","TH6RP:5:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH6ExtendedApronRunSol,"","","TH6RP:6:O.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,TH6FillTooLongTmr,"Filling is Taking too Long Alarm","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,TH6LeftAccessDoor,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,TH6LeftAccessDoor1,"","","TH6RP:2:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH6LeftAccessDoor1Status,"","","TH6RP:2:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH6LeftAccessDoor2,"","","TH6RP:2:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH6LeftAccessDoorReleaseSol,"","","TH6RP:3:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,TH6LiftApron,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,TH6Loadcell,"","","TH6RP:4:I.Ch0Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH6MaterialLoadPE,"","","TH6RP:5:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,TH6PanelEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,TH6PanelEStopPB1,"","","TH6RP:1:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH6PanelEStopPB1Status,"","","TH6RP:1:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH6PanelEStopPB2,"","","TH6RP:1:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,TH6RightAccessDoor,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,TH6RightAccessDoor1,"","","TH6RP:2:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH6RightAccessDoor1Status,"","","TH6RP:2:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH6RightAccessDoor2,"","","TH6RP:2:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH6RightAccessDoorReleaseSol,"","","TH6RP:3:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH6RightBaleEntryEStopPB1,"","","TH6RP:1:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH6RightBaleEntryEStopPB1Status,"","","TH6RP:1:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH6RightBaleEntryEStopPB2,"","","TH6RP:1:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,TH6RPComms,"","CommsCheck","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,TH6WeighPanDumpSol,"","","TH6RP:6:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH6WeighPnDamperCloseSol,"","","TH6RP:6:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,TH7,"","Hopper","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,TH7Damper,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,TH7DisconnectAux,"","","OBCP:11:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,TH7DisconnectSafety,"Mapped from Non-Safety Input","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,TH7DisconnectToSafety,"For Safety Mapping","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,TH7Doffer,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,TH7DofferCont,"","","OBCP:17:O.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH7DofferContAux,"","","OBCP:13:I.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH7DofferContAuxSafe,"","","OBCP:1:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,TH7DoorLocks,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,TH7Dump,"","Solenoid","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,TH7ExtendedApronPE,"","","TH7RP:5:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH7ExtendedApronRunSol,"","","TH7RP:6:O.2","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,TH7FillTooLongTmr,"Filling is Taking too Long Alarm","TIMER","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,TH7LeftAccessDoor,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,TH7LeftAccessDoor1,"","","TH7RP:2:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH7LeftAccessDoor1Status,"","","TH7RP:2:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH7LeftAccessDoor2,"","","TH7RP:2:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH7LeftAccessDoorReleaseSol,"","","TH7RP:3:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,TH7LiftApron,"","Drive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,TH7Loadcell,"","","TH7RP:4:I.Ch0Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH7MaterialLoadPE,"","","TH7RP:5:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,TH7PanelEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,TH7PanelEStopPB1,"","","TH7RP:1:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH7PanelEStopPB1Status,"","","TH7RP:1:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH7PanelEStopPB2,"","","TH7RP:1:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,TH7RightAccessDoor,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,TH7RightAccessDoor1,"","","TH7RP:2:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH7RightAccessDoor1Status,"","","TH7RP:2:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH7RightAccessDoor2,"","","TH7RP:2:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH7RightAccessDoorReleaseSol,"","","TH7RP:3:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,TH7RightBaleEntryEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,TH7RightBaleEntryEStopPB1,"","","TH7RP:1:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH7RightBaleEntryEStopPB1Status,"","","TH7RP:1:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH7RightBaleEntryEStopPB2,"","","TH7RP:1:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,TH7RPComms,"","CommsCheck","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,TH7WeighPanDumpSol,"","","TH7RP:6:O.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,TH7WeighPnDamperCloseSol,"","","TH7RP:6:O.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,TopDoffer,"","SEWDrive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,TopScrambler,"","SEWDrive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,TopScramblerRoll2Ratio,"Ratio for Roll 2 Speed","REAL","","(Class := Standard, RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,,TopTakeoff,"","SEWDrive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,TopTOFBelt,"","SEWDrive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,TransportBelt,"","SEWDrive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,VBOBeater,"","Motor","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,VBOBeaterCont,"","","OBCP:18:O.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,VBOBeaterContAux,"","","OBCP:14:I.4","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,VBOBeaterContAuxSafe,"","","OBCP:1:I.Pt06Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,VBOBeaterContAuxSafeStatus,"","","OBCP:1:I.Pt06Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,VBOLeftEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,VBOLeftEStopPB1,"","","VBORP:1:I.Pt04Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,VBOLeftEStopPB1Status,"","","VBORP:1:I.Pt04Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,VBOLeftEStopPB2,"","","VBORP:1:I.Pt05Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,VBORightEStopPB,"","RedundantSafetyInput","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,VBORightEStopPB1,"","","VBORP:1:I.Pt06Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,VBORightEStopPB1Status,"","","VBORP:1:I.Pt06Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,VBORightEStopPB2,"","","VBORP:1:I.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,VBORPComms,"","CommsCheck","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,VBORPControlPower,"","","OBCP:11:I.3","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,ViewRecipeIndex,"Index for Loading $QView$Q Recipe","INT","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,ViewRecipeSelectOS1,"One Shot","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,ViewRecipeSelectOS2,"One Shot","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,WCApronHeightLeftSetpoint,"Write to$NDB150:68","","RedLionDSP:O.Data[119]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WCApronHeightRightSetpoint,"Write to$NDB150:70","","RedLionDSP:O.Data[120]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WCEnableMahloControl,"Write to$N6.0","","RedLionDSP:O.Data[100].8","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WCEStopResetToCrosslapper,"Write to$N124.3","","RedLionDSP:O.Data[130].11","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WCLapperDraft,"Write to$NDB150:8","","RedLionDSP:O.Data[101]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WCLapperEntryWidth,"Write to$NDB150:54","","RedLionDSP:O.Data[113]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WCLapperExitWidthLeft,"Write to$NDB150:52","","RedLionDSP:O.Data[112]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WCLapperExitWidthRight,"Write to$NDB150:50","","RedLionDSP:O.Data[111]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WCLayerOverlap,"Write to$NDB150:58","","RedLionDSP:O.Data[115]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WCNumberOfLayers,"Write to$NDB150:56","","RedLionDSP:O.Data[114]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WCProfileSetpoint0,"Write to$NDB150:10","","RedLionDSP:O.Data[102]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WCProfileSetpoint1,"Write to$NDB150:12","","RedLionDSP:O.Data[103]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WCProfileSetpoint2,"Write to$NDB150:14","","RedLionDSP:O.Data[104]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WCProfileSetpoint3,"Write to$NDB150:16","","RedLionDSP:O.Data[105]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WCProfileSetpoint4,"Write to$NDB150:18","","RedLionDSP:O.Data[106]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WCProfileSetpoint5,"Write to$NDB150:20","","RedLionDSP:O.Data[107]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WCProfileSetpoint6,"Write to$NDB150:22","","RedLionDSP:O.Data[108]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WCProfileSetpoint7,"Write to$NDB150:24","","RedLionDSP:O.Data[109]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WCProfileSetpoint8,"Write to$NDB150:26","","RedLionDSP:O.Data[110]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WCRemoteControlSetpoint,"Write to$N124.2","","RedLionDSP:O.Data[130].10","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WCResetErrorSetpoint,"Write to$N124.1","","RedLionDSP:O.Data[130].9","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WCStartMahloControl,"Write to$N6.1","","RedLionDSP:O.Data[100].9","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WCStopMahloControl,"Write to$N6.2","","RedLionDSP:O.Data[100].10","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WCTakeoverSetpoint,"Write to$N124.0","","RedLionDSP:O.Data[130].8","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,WebDetector,"REPLACE ME","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,WinderMetalDetectResetPB,"","","PLCCP:14:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WinderStationNormalStopPB,"","","PLCCP:14:I.0","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WLEStopResetToLooms,"","","RedLionDSP:O.Data[17].11","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WLFingerRollersDraft,"","","RedLionDSP:O.Data[1]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WLInfeedApronDraft,"","","RedLionDSP:O.Data[0]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WLM1AdvancePerStroke,"","","RedLionDSP:O.Data[3]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WLM1DrawOffDraft,"","","RedLionDSP:O.Data[2]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WLM1Gap,"","","RedLionDSP:O.Data[7]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WLM1NeedleLength,"","","RedLionDSP:O.Data[5]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WLM1Penetration,"","","RedLionDSP:O.Data[6]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WLM2AdvancePerStroke,"","","RedLionDSP:O.Data[10]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WLM2DrawOffDraft,"","","RedLionDSP:O.Data[9]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WLM2Gap,"","","RedLionDSP:O.Data[16]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WLM2InfeedDraft,"","","RedLionDSP:O.Data[8]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WLM2NeedleLengthBottom,"","","RedLionDSP:O.Data[13]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WLM2NeedleLengthTop,"","","RedLionDSP:O.Data[12]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WLM2PenetrationBottom,"","","RedLionDSP:O.Data[15]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WLM2PenetrationTop,"","","RedLionDSP:O.Data[14]","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WLRemoteControlSetpoint,"","","RedLionDSP:O.Data[17].10","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WLResetErrorSetpoint,"","","RedLionDSP:O.Data[17].9","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,WLTakeOverSetpoint,"","","RedLionDSP:O.Data[17].8","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Worker,"","SEWDrive","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,WorkerBrakeResistorTherm,"","","CCP:6:I.1","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,XLP_Bypass_Scale,"","LadderScale","","(Class := Standard, Constant := false, ExternalAccess := Read/Write)"
TAG,,Yes,"Always On","BOOL","","(Class := Standard, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,,ZeroSpeedTimers,"Timers for Zero Speed Status","TIMER[20]","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
TAG,,Zone10,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone10ExpansionUnitStatus,"","","OBCP:8:I.Pt04OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone10InputsDelayOff,"","TIMER","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone10SafetyExpansion1,"","","OBCP:8:O.Pt04Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone10SafetyExpansion2,"","","OBCP:8:O.Pt05Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone11,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone11ChutefeedBeaterZeroSpeed,"","","CCP:2:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone11ChutefeedBeaterZeroSpeedStatus,"","","CCP:2:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone11ChutefeedBeaterZSpeedStatus,"Motor at Stand Still Delayed Status","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone11ExpansionUnitStatus,"","","CCP:3:I.Pt00OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone11SafetyExpansion1,"","","CCP:3:O.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone11SafetyExpansion2,"","","CCP:3:O.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone11SafetyExpansionMonitor,"","","CCP:1:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone11SafetyExpansionMonitorStatus,"","","CCP:1:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone12,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone12ExpansionUnitStatus,"","","CCP:3:I.Pt02OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone12SafetyExpansion1,"","","CCP:3:O.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone12SafetyExpansion2,"","","CCP:3:O.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone12SafetyExpansionMonitor,"","","CCP:1:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone12SafetyExpansionMonitorStatus,"","","CCP:1:I.Pt01Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone13,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone13ExpansionUnitStatus,"","","CCP:3:I.Pt04OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone13SafetyExpansion1,"","","CCP:3:O.Pt04Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone13SafetyExpansion2,"","","CCP:3:O.Pt05Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone13SafetyExpansionMonitor,"","","CCP:1:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone13SafetyExpansionMonitorStatus,"","","CCP:1:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone14,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone14ExpansionUnitStatus,"","","CCP:3:I.Pt06OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone14SafetyExpansion1,"","","CCP:3:O.Pt06Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone14SafetyExpansion2,"","","CCP:3:O.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone14SafetyExpansionMonitor,"","","CCP:1:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone14SafetyExpansionMonitorStatus,"","","CCP:1:I.Pt03Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone15,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone15DownSafetyExpansionMonitor,"","","CCP:1:I.Pt05Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone15UpSafetyExpansionMonitor,"","","CCP:1:I.Pt04Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone16,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone16ExpansionUnitStatus,"","","CCP:4:I.Pt02OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone16SafetyExpansion1,"","","CCP:4:O.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone16SafetyExpansion2,"","","CCP:4:O.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone16SafetyExpansionMonitor,"","","CCP:1:I.Pt06Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone16SafetyExpansionMonitorStatus,"","","CCP:1:I.Pt06Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone1A,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone1AExpansionUnitStatus,"","","OBCP:5:I.Pt00OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone1ASafetyExpansion1,"","","OBCP:5:O.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone1ASafetyExpansion2,"","","OBCP:5:O.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone1ASafetyExpansionMonitor,"","","OBCP:2:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone1ASafetyExpansionMonitorStatus,"","","OBCP:2:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone1B,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone1BExpansionUnitStatus,"","","OBCP:5:I.Pt02OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone1BResetFromRestart,"Mapped from Restart Pushbutton in Non-Safety Program","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone1BSafetyExpansion1,"","","OBCP:5:O.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone1BSafetyExpansion2,"","","OBCP:5:O.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone1BSafetyExpansionMonitor,"","","OBCP:2:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone1BSafetyExpansionMonitorStatus,"","","OBCP:2:I.Pt01Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone2A,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone2AExpansionUnitStatus,"","","OBCP:5:I.Pt04OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone2ASafetyExpansion1,"","","OBCP:5:O.Pt04Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone2ASafetyExpansion2,"","","OBCP:5:O.Pt05Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone2ASafetyExpansionMonitor,"","","OBCP:2:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone2ASafetyExpansionMonitorStatus,"","","OBCP:2:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone2B,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone2BExpansionUnitStatus,"","","OBCP:5:I.Pt06OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone2BResetFromRestart,"Mapped from Restart Pushbutton in Non-Safety Program","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone2BSafetyExpansion1,"","","OBCP:5:O.Pt06Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone2BSafetyExpansion2,"","","OBCP:5:O.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone2BSafetyExpansionMonitor,"","","OBCP:2:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone2BSafetyExpansionMonitorStatus,"","","OBCP:2:I.Pt03Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone3A,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone3AExpansionUnitStatus,"","","OBCP:6:I.Pt00OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone3ASafetyExpansion1,"","","OBCP:6:O.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone3ASafetyExpansion2,"","","OBCP:6:O.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone3ASafetyExpansionMonitor,"","","OBCP:2:I.Pt04Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone3ASafetyExpansionMonitorStatus,"","","OBCP:2:I.Pt04Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone3B,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone3BExpansionUnitStatus,"","","OBCP:6:I.Pt02OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone3BResetFromRestart,"Mapped from Restart Pushbutton in Non-Safety Program","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone3BSafetyExpansion1,"","","OBCP:6:O.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone3BSafetyExpansion2,"","","OBCP:6:O.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone3BSafetyExpansionMonitor,"","","OBCP:2:I.Pt05Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone3BSafetyExpansionMonitorStatus,"","","OBCP:2:I.Pt05Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone4A,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone4AExpansionUnitStatus,"","","OBCP:6:I.Pt04OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone4ASafetyExpansion1,"","","OBCP:6:O.Pt04Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone4ASafetyExpansion2,"","","OBCP:6:O.Pt05Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone4ASafetyExpansionMonitor,"","","OBCP:2:I.Pt06Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone4ASafetyExpansionMonitorStatus,"","","OBCP:2:I.Pt06Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone4B,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone4BExpansionUnitStatus,"","","OBCP:6:I.Pt06OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone4BResetFromRestart,"Mapped from Restart Pushbutton in Non-Safety Program","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone4BSafetyExpansion1,"","","OBCP:6:O.Pt06Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone4BSafetyExpansion2,"","","OBCP:6:O.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone4BSafetyExpansionMonitor,"","","OBCP:2:I.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone4BSafetyExpansionMonitorStatus,"","","OBCP:2:I.Pt07Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone5A,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone5AExpansionUnitStatus,"","","OBCP:7:I.Pt00OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone5ASafetyExpansion1,"","","OBCP:7:O.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone5ASafetyExpansion2,"","","OBCP:7:O.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone5ASafetyExpansionMonitor,"","","OBCP:3:I.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone5ASafetyExpansionMonitorStatus,"","","OBCP:3:I.Pt00Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone5B,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone5BExpansionUnitStatus,"","","OBCP:7:I.Pt02OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone5BResetFromRestart,"Mapped from Restart Pushbutton in Non-Safety Program","BOOL","","(Class := Safety, RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone5BSafetyExpansion1,"","","OBCP:7:O.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone5BSafetyExpansion2,"","","OBCP:7:O.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone5BSafetyExpansionMonitor,"","","OBCP:3:I.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone5BSafetyExpansionMonitorStatus,"","","OBCP:3:I.Pt01Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone6,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone6ExpansionUnitStatus,"","","OBCP:7:I.Pt04OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone6SafetyExpansion1,"","","OBCP:7:O.Pt04Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone6SafetyExpansion2,"","","OBCP:7:O.Pt05Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone6SafetyExpansionMonitor,"","","OBCP:3:I.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone6SafetyExpansionMonitorStatus,"","","OBCP:3:I.Pt02Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone7,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone7ExpansionUnitStatus,"","","OBCP:7:I.Pt06OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone7SafetyExpansion1,"","","OBCP:7:O.Pt06Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone7SafetyExpansion2,"","","OBCP:7:O.Pt07Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone7SafetyExpansionMonitor,"","","OBCP:3:I.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone7SafetyExpansionMonitorStatus,"","","OBCP:3:I.Pt03Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone8,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone8ExpansionUnitStatus,"","","OBCP:8:I.Pt00OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone8SafetyExpansion1,"","","OBCP:8:O.Pt00Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone8SafetyExpansion2,"","","OBCP:8:O.Pt01Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone8SafetyExpansionMonitor,"","","OBCP:3:I.Pt04Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone8SafetyExpansionMonitorStatus,"","","OBCP:3:I.Pt04Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TAG,,Zone9,"","SafetyZone","","(Class := Safety, Constant := false, ExternalAccess := Read/Write)"
ALIAS,,Zone9ExpansionUnitStatus,"","","OBCP:8:I.Pt02OutputStatus","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone9SafetyExpansion1,"","","OBCP:8:O.Pt02Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone9SafetyExpansion2,"","","OBCP:8:O.Pt03Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone9SafetyExpansionMonitor,"","","OBCP:3:I.Pt05Data","(RADIX := Decimal, ExternalAccess := Read/Write)"
ALIAS,,Zone9SafetyExpansionMonitorStatus,"","","OBCP:3:I.Pt05Status","(RADIX := Decimal, ExternalAccess := Read/Write)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,LineDrives,MainCylinder_Stanstill,"","TIMER","","(Constant := false, ExternalAccess := Read/Write)"
TAG,LineDrives,ScaleDisplayAverageSeconds,"","REAL","","(RADIX := Float, Constant := false, ExternalAccess := Read/Write)"
TAG,LineDrives,Scale_Smoothing1,"","DriveRamp","","(Constant := false, ExternalAccess := Read/Write)"
TAG,LineDrives,test_main,"","BOOL","","(RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,SafetyProgram,ForceZone13,"","BOOL","","(RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,SafetyProgram,ForceZone14,"","BOOL","","(RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,SafetyProgram,ForceZone1A,"","BOOL","","(RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,SafetyProgram,ForceZone1B,"","BOOL","","(RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,SafetyProgram,ForceZone2A,"","BOOL","","(RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,SafetyProgram,ForceZone2B,"","BOOL","","(RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,SafetyProgram,ForceZone3A,"","BOOL","","(RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,SafetyProgram,ForceZone3B,"","BOOL","","(RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,SafetyProgram,ForceZone4A,"","BOOL","","(RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,SafetyProgram,ForceZone4B,"","BOOL","","(RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,SafetyProgram,ForceZone5A,"","BOOL","","(RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TAG,SafetyProgram,ForceZone5B,"","BOOL","","(RADIX := Decimal, Constant := false, ExternalAccess := Read/Write)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,DriveRamp:AOI,RampInput,"Speed Ref to be Ramped","REAL","","(RADIX := Float, Usage := Input, ExternalAccess := Read/Write, Required := true, Visible := true)"
TAG,DriveRamp:AOI,AccelSeconds,"Accel Rate (Seconds)","REAL","","(RADIX := Float, Usage := Input, ExternalAccess := Read/Write, Required := true, Visible := true)"
TAG,DriveRamp:AOI,DecelSeconds,"Decel Rate (Seconds)","REAL","","(RADIX := Float, Usage := Input, ExternalAccess := Read/Write, Required := true, Visible := true)"
TAG,DriveRamp:AOI,MaximumDriveSpeed,"Maximum Drive Speed","REAL","","(RADIX := Float, Usage := Input, ExternalAccess := Read/Write, Required := true, Visible := true)"
TAG,DriveRamp:AOI,RampedOutput,"Ramped Reference to Drive","REAL","","(RADIX := Float, Usage := Output, ExternalAccess := Read Only, Required := true, Visible := true)"
TAG,DriveRamp:AOI,AllowRamp,"","BOOL","","(RADIX := Decimal, Usage := Input, ExternalAccess := Read/Write, Required := true, Visible := true)"
TAG,DriveRamp:AOI,SCRV_01,"","S_CURVE","","(Usage := Local, ExternalAccess := Read/Write)"
TAG,DriveRamp:AOI,DIV_01,"","FBD_MATH","","(Usage := Local, ExternalAccess := Read/Write)"
TAG,DriveRamp:AOI,DIV_02,"","FBD_MATH","","(Usage := Local, ExternalAccess := Read/Write)"
TAG,DriveRamp:AOI,BNOT_01,"","FBD_BOOLEAN_NOT","","(Usage := Local, ExternalAccess := Read/Write)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,JKFlipFLop:AOI,Input,"","BOOL","","(RADIX := Decimal, Usage := Input, ExternalAccess := Read/Write, Required := true, Visible := true)"
TAG,JKFlipFLop:AOI,Output,"","BOOL","","(RADIX := Decimal, Usage := Output, ExternalAccess := Read Only, Required := true, Visible := true)"
TAG,JKFlipFLop:AOI,Clear,"","BOOL","","(RADIX := Decimal, Usage := Input, ExternalAccess := Read/Write, Required := true, Visible := true)"
TAG,JKFlipFLop:AOI,JKFF_01,"","FLIP_FLOP_JK","","(Usage := Local, ExternalAccess := Read/Write)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,LadderScale:AOI,RawInput,"Raw Data to be Scaled","REAL","","(RADIX := Float, Usage := Input, ExternalAccess := Read/Write, Required := true, Visible := true)"
TAG,LadderScale:AOI,InputMin,"Minimum Expected Raw Input","REAL","","(RADIX := Float, Usage := Input, ExternalAccess := Read/Write, Required := true, Visible := true)"
TAG,LadderScale:AOI,InputMax,"Maximum Expected Raw Output","REAL","","(RADIX := Float, Usage := Input, ExternalAccess := Read/Write, Required := true, Visible := true)"
TAG,LadderScale:AOI,OutputMin,"Expected Output at Min Input","REAL","","(RADIX := Float, Usage := Input, ExternalAccess := Read/Write, Required := true, Visible := true)"
TAG,LadderScale:AOI,OutputMax,"Expected Output at Max Input","REAL","","(RADIX := Float, Usage := Input, ExternalAccess := Read/Write, Required := true, Visible := true)"
TAG,LadderScale:AOI,ScaledOutput,"Scaled Value","REAL","","(RADIX := Float, Usage := Output, ExternalAccess := Read Only, Required := true, Visible := true)"
TAG,LadderScale:AOI,Clamp,"Clamps Value at Output Min/Max","BOOL","","(RADIX := Decimal, Usage := Input, ExternalAccess := Read/Write, Required := true, Visible := true)"
TAG,LadderScale:AOI,SCL_01,"","SCALE","","(Usage := Local, ExternalAccess := Read/Write)"
TYPE,SCOPE,NAME,DESCRIPTION,DATATYPE,SPECIFIER,ATTRIBUTES
TAG,LineSpeedRamp:AOI,NormalAccel,"Accel Rate for Normal Ramp","REAL","","(RADIX := Float, Usage := Input, ExternalAccess := Read/Write, Required := true, Visible := true)"
TAG,LineSpeedRamp:AOI,NormalDecel,"Decel Rate for Normal Ramp","REAL","","(RADIX := Float, Usage := Input, ExternalAccess := Read/Write, Required := true, Visible := true)"
TAG,LineSpeedRamp:AOI,MaximumSpeed,"Maximum Line Speed","REAL","","(RADIX := Float, Usage := Input, ExternalAccess := Read/Write, Required := true, Visible := true)"
TAG,LineSpeedRamp:AOI,EStopDecel,"Decel Rate for E-Stop Ramping","REAL","","(RADIX := Float, Usage := Input, ExternalAccess := Read/Write, Required := true, Visible := true)"
TAG,LineSpeedRamp:AOI,RampEnable,"Enables Reference Ramp","BOOL","","(RADIX := Decimal, Usage := Input, ExternalAccess := Read/Write, Required := true, Visible := true)"
TAG,LineSpeedRamp:AOI,AtZeroSpeed,"Ramp has Decelerated to Zero","BOOL","","(RADIX := Decimal, Usage := Output, ExternalAccess := Read Only, Required := true, Visible := true)"
TAG,LineSpeedRamp:AOI,PreRampReference,"Reference Sent to be Ramped","REAL","","(RADIX := Float, Usage := Input, ExternalAccess := Read/Write, Required := true, Visible := true)"
TAG,LineSpeedRamp:AOI,RampedReference,"Reference out of Ramp","REAL","","(RADIX := Float, Usage := Output, ExternalAccess := Read Only, Required := true, Visible := true)"
TAG,LineSpeedRamp:AOI,EStopStatus,"E-Stop Status to Reduce Decel Time","BOOL","","(RADIX := Decimal, Usage := Input, ExternalAccess := Read/Write, Required := true, Visible := true)"
TAG,LineSpeedRamp:AOI,HoldRamp,"1-Hold Ramp at Current Rate","BOOL","","(RADIX := Decimal, Usage := Input, ExternalAccess := Read/Write, Required := true, Visible := true)"
TAG,LineSpeedRamp:AOI,DIV_02,"","FBD_MATH","","(Usage := Local, ExternalAccess := Read/Write)"
TAG,LineSpeedRamp:AOI,DIV_01,"","FBD_MATH","","(Usage := Local, ExternalAccess := Read/Write)"
TAG,LineSpeedRamp:AOI,SCRV_01,"","S_CURVE","","(Usage := Local, ExternalAccess := Read/Write)"
TAG,LineSpeedRamp:AOI,SEL_02,"","SELECT","","(Usage := Local, ExternalAccess := Read/Write)"
TAG,LineSpeedRamp:AOI,DIV_03,"","FBD_MATH","","(Usage := Local, ExternalAccess := Read/Write)"
TAG,LineSpeedRamp:AOI,SEL_01,"","SELECT","","(Usage := Local, ExternalAccess := Read/Write)"
TAG,LineSpeedRamp:AOI,LEQ_01,"","FBD_COMPARE","","(Usage := Local, ExternalAccess := Read/Write)"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"BlendLine","B1BlendBeater","****$NPermissive to operate the motor.$N****","OTE(B1BlenderBeater.Internal.Permissive)","0"
RCOMMENT,"BlendLine","B1BlendBeater","****$NManual Run Control$N****","OTE(B1BlenderBeater.Internal.IntermediateRunForward)","1"
RCOMMENT,"BlendLine","B1BlendBeater","****$NManual Jog Control$N****","OTE(B1BlenderBeater.Internal.IntermediateJogForward)","2"
RCOMMENT,"BlendLine","B1BlendBeater","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(B1BlenderBeater.Internal.AutoOffDelayTimer,?,?)","3"
RCOMMENT,"BlendLine","B1BlendBeater","****$NMotor Starter Control$N****","OTE(B1BlenderBeaterCont)","4"
RCOMMENT,"BlendLine","B1BlendBeater","****$NRunning Status$N****","OTE(B1BlenderBeater.Status.RunningForward)","5"
RCOMMENT,"BlendLine","B1BlendBeater","****$NIf the motor does not start when commanded, it has failed to run$N****","OTL(B1BlenderBeater.Status.FailedToStart)","6"
RCOMMENT,"BlendLine","B1BlendBeater","****$NIf a motor continues to run when the run command has been removed,$Nit has failed to stop.$N****$N","OTL(B1BlenderBeater.Status.FailedToStop)","7"
RCOMMENT,"BlendLine","B1BlendBeater","****$NGeneral Faulted Status$N****","OTE(B1BlenderBeater.Status.Faulted)","8"
RCOMMENT,"BlendLine","B1BlendBeater","****$NReset Fault Latches$N****","OTU(B1BlenderBeater.Status.FailedToStop)","9"
RCOMMENT,"BlendLine","B1BlendControl","****$NPermissive to Operate Blend Line$N****","OTE(BlendLine.Internal.Permissive)","0"
RCOMMENT,"BlendLine","B1BlendControl","****$NCommand the blend line to weigh mode.$N****","OTU(BlendLine.Command.ToWeighMode)","2"
RCOMMENT,"BlendLine","B1BlendControl","****$NCommand the blend line to volumetric mode.$N****","OTU(BlendLine.Command.ToVolumetricMode)","3"
RCOMMENT,"BlendLine","B1BlendControl","****$NBlend Line Start$N****","TON(BlendLine.Internal.StartDelayTimer,?,?)","4"
RCOMMENT,"BlendLine","B1BlendControl","****$NThis horn should let the operators know if there has been a problem that shut down the blending.$N****","OTL(BlendingAlarmHornLatch)","5"
RCOMMENT,"BlendLine","B1BlendControl","****$NReset alarm$N****","OTU(BlendingAlarmHornLatch)","6"
RCOMMENT,"BlendLine","B1BlendControl","****$NThe blend line must be running for an amount of time$Nbefore the low level alarms will be active.$N****","TON(FS5XLowAlarmDelay,?,?)","7"
RCOMMENT,"BlendLine","B1BlendControl","****$NDebounce for the PE$N****","TOF(FS51LowPEStateTOF,?,?)","8"
RCOMMENT,"BlendLine","B1BlendControl","****$NDebounce for the PE$N****","TOF(FS52LowPEStateTOF,?,?)","9"
RCOMMENT,"BlendLine","B1BlendControl","****$NOnce the startup delay time has passed, the lower PEs are used$Nto determine when the silo is low.$N****","TON(FS51FiberLowAlarmTimer,?,?)","10"
RCOMMENT,"BlendLine","B1BlendControl","****$NOnce the startup delay time has passed, the lower PEs are used$Nto determine when the silo is low.$N****","TON(FS52FiberLowAlarmTimer,?,?)","11"
RCOMMENT,"BlendLine","B1BlendControl","****$NIf either silo is low, latch the alarm.$N****","OTL(FS5XLowFiberAlarmLatch)","12"
RCOMMENT,"BlendLine","B1BlendControl","****$NReset the alarm.$N****$NNOTE:  The reset also resets the startup timer above.","OTU(FS5XLowFiberAlarmLatch)","13"
RCOMMENT,"BlendLine","B1BlendControl","****$NThis timer is a cycling timer active when the alarm latch is on.$NThe .acc value is used below to fire the horn.$N****","TON(LowFiberHornTimer,?,?)","14"
RCOMMENT,"BlendLine","B1BlendControl","****$NTimer for horn sequence.$N****","TON(BlendAlarmHornTimer,?,?)","15"
RCOMMENT,"BlendLine","B1BlendControl","****$NActual Horn Output$N****","OTE(BlendingAlarmHorn)","16"
RCOMMENT,"BlendLine","B1BlendControl","****$NOnce the start delay timer is done, the blend line is in run mode.$N****","OTE(BlendLine.Status.Running)","17"
RCOMMENT,"BlendLine","B1BlendControl","****$NFlash the pilot light while the line is starting and solid when running.$N****","OTE(BlendSystemStartPL)","18"
RCOMMENT,"BlendLine","B1BlendControl","****$NSound the start horn when starting.$N****","OTE(BlendLineStartHorn)","19"
RCOMMENT,"BlendLine","B1BlendControl","****$NThe blend system will either receive a call from the CFX (if the fine opener is bypassed)$Nor from the Fine Opener (if it is inline).$N****","OTE(BlendLine.Internal.CallForFiber)","20"
RCOMMENT,"BlendLine","B1BlendControl","****$NIf the conveyor is set up to run the normal index, the fiber may pile up too high.$NThe solution is to have an index that is half the normal index lenght.  When it is enabled$Nfrom the HMI, the IndexSteps value changes.$N****","OTE(BlendLine.Status.HalfLengthEnabled)","21"
RCOMMENT,"BlendLine","B1BlendControl","****$NDelete rung if the half length setpoint is to be entered instead of calculated.$N****","DIV(BlendLine.Command.NormalLengthSteps,2,BlendLine.Command.HalfLengthSteps)","22"
RCOMMENT,"BlendLine","B1BlendControl","****$NThe normal index was determined to be 112 pulses.$NThe half length therefore is 56.$N****","MOV(BlendLine.Command.HalfLengthSteps,BlendLine.Internal.IndexSteps)","23"
RCOMMENT,"BlendLine","B1BlendControl","****$NThe normal index was determined to be 112 pulses.$NThe half length therefore is 56.$N****","MOV(BlendLine.Command.NormalLengthSteps,BlendLine.Internal.IndexSteps)","24"
RCOMMENT,"BlendLine","B1BlendControl","****$NCount the pulses to determine when the conveyor has indexed to the$Nnext station.$N****$NThe Index Step Normal at startup was 58.$N******","MOV(0,BlendLine.Status.PulseCount)","25"
RCOMMENT,"BlendLine","B1BlendControl","****$NUnlatch the index complete bit when the dump is complete.$N****","OTU(BlendLine.Status.BlendConveyorIndexComplete)","26"
RCOMMENT,"BlendLine","B1BlendControl","****$NWhen all the enabled hoppers have reached setpoint and the conveyor is at the index point dump the hoppers.$N****","OTL(BlendLine.Internal.DumpCommand)","27"
RCOMMENT,"BlendLine","B1BlendControl","****$NThe dump command should stay active for an amount of time$Nand then shut itself off.$N****","OTL(BlendLine.Status.SystemDumpComplete)","28"
RCOMMENT,"BlendLine","B1BlendControl","****$NBecause the vibration of closing the dump doors may cause a weight setpoint reached$Nbit to be latched, the timer is added to unlatch that bit for a time after the door$Nhas closed.$N****","TON(DumpCompleteTimer,?,?)","30"
RCOMMENT,"BlendLine","B1BlendControl","****$NWhen the dump complete is set, the dump closes and after a delay, the doors open.$N****","TOF(BlendLine.Internal.OpenDoorTimer,?,?)","31"
RCOMMENT,"BlendLine","B1BlendControl","****$NAfter the hoppers dump their fiber index the conveyor.$N****","OTL(BlendLine.Internal.IndexConveyor)","32"
RCOMMENT,"BlendLine","B1BlendControl","****$NUnlatch the conveyor index command.$N****","OTU(BlendLine.Internal.IndexConveyor)","33"
RCOMMENT,"BlendLine","B1BlendControl","****$NCall for the motor to run based on the control mode.$N****","OTE(BlendLine.Internal.RunBlendConveyor)","34"
RCOMMENT,"BlendLine","B1BlendControl","****$NCall for the motor to run based on the control mode.$N****","OTE(BlendLine.Internal.RunBlendBeater)","35"
RCOMMENT,"BlendLine","B1BlendControl","****$NCall for the motor to run based on the control mode.$N****","OTE(BlendLine.Internal.RunBlendDeliveryFan)","36"
RCOMMENT,"BlendLine","B1BlendControl","****$NThe RunLiftAprons bit is used in the individual hopper routines to control$Ntheir lift aprons.$N****","OTE(BlendLine.Internal.RunLiftAprons)","37"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NPermissive to operate the motor.$N****","OTE(B1BlendConveyor.Internal.Permissive)","0"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NJog Command$N****","OTE(B1BlendConveyor.Internal.IntermediateJog)","1"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(B1BlendConveyor.Internal.DriveReverse)","2"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(B1BlendConveyor.Internal.MaintModeRun)","3"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(B1BlendConveyor.Internal.AutoOffDelayTimer,?,?)","4"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NMotor Starter Control$N****","OTE(B1BlendConveyor.Internal.ReleaseRamp)","5"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(B1BlendConveyor.Internal.DecelTime,B1BlendConveyor.Internal.DecelTime)","6"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(B1BlendConveyor.Internal.SpeedReference.ScaledOutput,B1BlendConveyor:O.FreqCommand)","7"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(B1BlendConveyor:O.Start)","8"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(B1BlendConveyor:O.Stop)","9"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NThe reverse command is set above.$N****","OTE(B1BlendConveyor:O.Reverse)","10"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(B1BlendConveyor:O.Forward)","11"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(B1BlendConveyor.Internal.ActualSpeedScaler.ScaledOutput,B1BlendConveyor.Status.ActualSpeed)","12"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(B1BlendConveyor.Internal.LoadScaler.ScaledOutput,B1BlendConveyor.Status.MotorLoad)","13"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NDrive Running Status$N****","OTE(B1BlendConveyor.Status.Running)","14"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NJogging Forward Status$N****","OTE(B1BlendConveyor.Status.JoggingFwd)","15"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NJogging Reverse Status$N****","OTE(B1BlendConveyor.Status.JoggingRev)","16"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NWhen the drive is running, the prox should be pulsing.  If it does not$Npulse, the belt is stuck.$N****","TON(ConveyorMovingTmr1,?,?)","17"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NWhen the drive is running, the prox should be pulsing.  If it does not$Npulse, the belt is stuck.$N****","TON(ConveyorMovingTmr2,?,?)","18"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NIf either of the two timers get done, the belt has failed to move.$N****","OTL(B1BlendConveyorFailedToMove)","19"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NReset the alarm.$N****","OTU(B1BlendConveyorFailedToMove)","20"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(B1BlendConveyor.Status.FailedToStart)","21"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(B1BlendConveyor.Status.FailedToStop)","22"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(B1BlendConveyor.Status.Faulted)","23"
RCOMMENT,"BlendLine","B1BlendConveyor","****$NUnlatch the Drive Faulted Status$N****","OTU(B1BlendConveyor.Status.FailedToStop)","24"
RCOMMENT,"BlendLine","B1BlendTransportFan","****$NPermissive to operate the motor.$N****","OTE(B1BlendTransportFan.Internal.Permissive)","0"
RCOMMENT,"BlendLine","B1BlendTransportFan","****$NJog Command$N****","OTE(B1BlendTransportFan.Internal.IntermediateJog)","1"
RCOMMENT,"BlendLine","B1BlendTransportFan","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(B1BlendTransportFan.Internal.DriveReverse)","2"
RCOMMENT,"BlendLine","B1BlendTransportFan","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(B1BlendTransportFan.Internal.MaintModeRun)","3"
RCOMMENT,"BlendLine","B1BlendTransportFan","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(B1BlendTransportFan.Internal.AutoOffDelayTimer,?,?)","4"
RCOMMENT,"BlendLine","B1BlendTransportFan","****$NMotor Starter Control$N****","OTE(B1BlendTransportFan.Internal.ReleaseRamp)","5"
RCOMMENT,"BlendLine","B1BlendTransportFan","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(B1BlendTransportFan.Internal.DecelTime,B1BlendTransportFan.Internal.DecelTime)","6"
RCOMMENT,"BlendLine","B1BlendTransportFan","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(B1BlendTransportFan.Internal.SpeedReference.ScaledOutput,B1BlendTransportFan:O.FreqCommand)","7"
RCOMMENT,"BlendLine","B1BlendTransportFan","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(B1BlendTransportFan:O.Start)","8"
RCOMMENT,"BlendLine","B1BlendTransportFan","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(B1BlendTransportFan:O.Stop)","9"
RCOMMENT,"BlendLine","B1BlendTransportFan","****$NThe reverse command is set above.$N****","OTE(B1BlendTransportFan:O.Reverse)","10"
RCOMMENT,"BlendLine","B1BlendTransportFan","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(B1BlendTransportFan:O.Forward)","11"
RCOMMENT,"BlendLine","B1BlendTransportFan","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(B1BlendTransportFan.Internal.ActualSpeedScaler.ScaledOutput,B1BlendTransportFan.Status.ActualSpeed)","12"
RCOMMENT,"BlendLine","B1BlendTransportFan","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(B1BlendTransportFan.Internal.LoadScaler.ScaledOutput,B1BlendTransportFan.Status.MotorLoad)","13"
RCOMMENT,"BlendLine","B1BlendTransportFan","****$NDrive Running Status$N****","OTE(B1BlendTransportFan.Status.Running)","14"
RCOMMENT,"BlendLine","B1BlendTransportFan","****$NJogging Forward Status$N****","OTE(B1BlendTransportFan.Status.JoggingFwd)","15"
RCOMMENT,"BlendLine","B1BlendTransportFan","****$NJogging Reverse Status$N****","OTE(B1BlendTransportFan.Status.JoggingRev)","16"
RCOMMENT,"BlendLine","B1BlendTransportFan","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(B1BlendTransportFan.Status.FailedToStart)","17"
RCOMMENT,"BlendLine","B1BlendTransportFan","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(B1BlendTransportFan.Status.FailedToStop)","18"
RCOMMENT,"BlendLine","B1BlendTransportFan","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(B1BlendTransportFan.Status.Faulted)","19"
RCOMMENT,"BlendLine","B1BlendTransportFan","****$NUnlatch the Drive Faulted Status$N****","OTU(B1BlendTransportFan.Status.FailedToStop)","20"
RCOMMENT,"BlendLine","BlendLineMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(B1BlendControl,0)","0"
RCOMMENT,"BlendLine","BlendLineMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(B1BlendBeater,0)","1"
RCOMMENT,"BlendLine","BlendLineMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(B1BlendTransportFan,0)","2"
RCOMMENT,"BlendLine","BlendLineMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(B1BlendConveyor,0)","3"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"BO1Program","BO1Breaker","****$NPermissive to Operate$N****","OTE(BO1Breaker.Internal.Permissive)","0"
RCOMMENT,"BO1Program","BO1Breaker","****$NManual Run Control$N****","OTE(BO1Breaker.Internal.IntermediateRunForward)","1"
RCOMMENT,"BO1Program","BO1Breaker","****$NManual Jog Control$N****","OTE(BO1Breaker.Internal.IntermediateJogForward)","2"
RCOMMENT,"BO1Program","BO1Breaker","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(BO1Breaker.Internal.AutoOffDelayTimer,?,?)","3"
RCOMMENT,"BO1Program","BO1Breaker","****$NMotor Starter Control$N****","OTE(BO1BreakerCont)","4"
RCOMMENT,"BO1Program","BO1Breaker","****$NRunning Status$N****","OTE(BO1Breaker.Status.RunningForward)","5"
RCOMMENT,"BO1Program","BO1Breaker","****$NIf the motor does not start when commanded, it has failed to run$N****","OTL(BO1Breaker.Status.FailedToStart)","6"
RCOMMENT,"BO1Program","BO1Breaker","****$NIf a motor continues to run when the run command has been removed,$Nit has failed to stop.$N****$N","OTL(BO1Breaker.Status.FailedToStop)","7"
RCOMMENT,"BO1Program","BO1Breaker","****$NGeneral Faulted Status$N****","OTE(BO1Breaker.Status.Faulted)","8"
RCOMMENT,"BO1Program","BO1Breaker","****$NReset Fault Latches$N****","OTU(BO1Breaker.Status.FailedToStop)","9"
RCOMMENT,"BO1Program","BO1Control","****$NPermissive to Operate Manually$N****","OTE(BO1.Internal.Permissive)","0"
RCOMMENT,"BO1Program","BO1Control","****$NEnable the Hopper for Operation$N****","OTU(BO1.Command.Enable)","1"
RCOMMENT,"BO1Program","BO1Control","****$NDisable the Hopper$N****","OTU(BO1.Command.Disable)","2"
RCOMMENT,"BO1Program","BO1Control","****$NDisable the hopper if it is neither enabled or disabled.$N****","OTL(BO1.Status.Disabled)","3"
RCOMMENT,"BO1Program","BO1Control","****$NIf the blend line is not running or the hopper is not enabled, enable manual controls.$N****","OTE(BO1.Internal.EnableManualControls)","4"
RCOMMENT,"BO1Program","BO1Control","****$NCheck the setpoint against limits$N****","SUB(BO1.Command.WeightSetpoint,BO1.Command.AnticipationWeight,BO1.Internal.StopWeight)","5"
RCOMMENT,"BO1Program","BO1Control","****$NScale the analog input to determine weight.$N****","MOV(BO1.Internal.WeightScaler.ScaledOutput,BO1.Status.CurrentWeight)","6"
RCOMMENT,"BO1Program","BO1Control","****$NWhen the blend line is in weigh mode, the lift apron slows when the weight gets$Nabove the slow down ratio.$N****","OTE(BO1.Status.SlowDownActive)","7"
RCOMMENT,"BO1Program","BO1Control","****$NWhen the blend line is in weigh mode the lift apron stops$Nand the door closes when the pan reaches setpoint.$N****","OTL(BO1.Status.WeightSetpointReached)","8"
RCOMMENT,"BO1Program","BO1Control","****$NSet up the values for the upper and lower weights that will cause an alarm$N(OUT OF TOLERANCE VALUES)$N****","SUB(BO1.Command.WeightSetpoint,BO1.Internal.WeightAlarmValue,BO1.Status.AlarmWeightLowerWindow)","9"
RCOMMENT,"BO1Program","BO1Control","****$NWhen the settling timer is done, shift the array numbers down and move the latest$Nweight into array 9.  Array 9 will be the latest value. 8 will be previous then 7, etc.$N****","OTL(BO1.Status.LowWeightAlarm)","10"
RCOMMENT,"BO1Program","BO1Control","****$NReset the setpoint reached bit.$N****","OTU(BO1.Status.WeightSetpointReached)","11"
RCOMMENT,"BO1Program","BO1Control","****$NThe photoeye should control the extended apron.  If the lift apron is running for too long$Nwithout anything blocking the eye, there is a problem.  Perhaps the hopper is empty.$N****","OTE(BO1.Internal.HopperPETooLong)","12"
RCOMMENT,"BO1Program","BO1Control","****$NHopper filling status.$N****","OTE(BO1.Status.Filling)","13"
RCOMMENT,"BO1Program","BO1Control","****$NIf the weight is not reached in a certain amount of time...alarm.$N****","TON(BO1FillTooLongTmr,?,?)","14"
RCOMMENT,"BO1Program","BO1Control","****$NGeneral alarm for HMI display.$N****","OTE(BO1.Status.WeightAlarm)","15"
RCOMMENT,"BO1Program","BO1Control","****$NReset the alarm latches.$N****","OTU(BO1.Status.LowWeightAlarm)","16"
RCOMMENT,"BO1Program","BO1Control","****$NThe RunLiftAprons bit comes from the blend control routine.$NAfter the appropriate drives are running and the call for fiber is on, this$Nbit comes on.  If the hopper is enabled, run the lift apron.$N****","OTE(BO1.Internal.RunLiftApron)","17"
RCOMMENT,"BO1Program","BO1Control","****$NThe restart pushbutton needs to reset the safety zone and the drive before restarting the system.$N****","OTE(BO1RestartSystem)","18"
RCOMMENT,"BO1Program","BO1Damper","****$NPermissive to operate$N****","OTE(BO1Damper.Internal.Permissive)","0"
RCOMMENT,"BO1Program","BO1Damper","****$NSolenoid to Automatic Mode$N****","OTU(BO1Damper.Command.ToAuto)","1"
RCOMMENT,"BO1Program","BO1Damper","****$NSolenoid to Manua Mode$N****","OTU(BO1Damper.Command.ToManual)","2"
RCOMMENT,"BO1Program","BO1Damper","****$NIf the solenoid is not in either mode, put in manual mode.$N****","OTL(BO1Damper.Status.InManual)","3"
RCOMMENT,"BO1Program","BO1Damper","****$NManual Run Control$N****","OTE(BO1Damper.Internal.ManualOpen)","4"
RCOMMENT,"BO1Program","BO1Damper","****$NAutomatic mode controls.$N****","TOF(BO1Damper.Internal.DelayCloseTimer,?,?)","5"
RCOMMENT,"BO1Program","BO1Damper","****$NControl of the solenoid.$N****","OTE(BO1Damper.Internal.IntermediateOpen)","6"
RCOMMENT,"BO1Program","BO1Damper","****$NIf not open command, then close command.$N****","OTE(BO1WeighPanDamperCloseSol)","7"
RCOMMENT,"BO1Program","BO1Damper","****$NOpen Status$N****","OTE(BO1Damper.Status.Open)","8"
RCOMMENT,"BO1Program","BO1Damper","****$NClosed Status$N****","OTE(BO1Damper.Status.Closed)","9"
RCOMMENT,"BO1Program","BO1Doffer","****$NPermissive to Operate$N****","OTE(BO1Doffer.Internal.Permissive)","0"
RCOMMENT,"BO1Program","BO1Doffer","****$NManual Run Control$N****","OTE(BO1Doffer.Internal.IntermediateRunForward)","1"
RCOMMENT,"BO1Program","BO1Doffer","****$NManual Jog Control$N****","OTE(BO1Doffer.Internal.IntermediateJogForward)","2"
RCOMMENT,"BO1Program","BO1Doffer","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(BO1Doffer.Internal.AutoOffDelayTimer,?,?)","3"
RCOMMENT,"BO1Program","BO1Doffer","****$NIf the permissive is lost, reset the TOF for immediate stop.$N****","RES(BO1Doffer.Internal.AutoOffDelayTimer)","4"
RCOMMENT,"BO1Program","BO1Doffer","****$NMotor Starter Control$N****","OTE(BO1DofferCont)","5"
RCOMMENT,"BO1Program","BO1Doffer","****$NRunning Status$N****","OTE(BO1Doffer.Status.RunningForward)","6"
RCOMMENT,"BO1Program","BO1Doffer","****$NIf the motor does not start when commanded, it has failed to run$N****","OTL(BO1Doffer.Status.FailedToStart)","7"
RCOMMENT,"BO1Program","BO1Doffer","****$NIf a motor continues to run when the run command has been removed,$Nit has failed to stop.$N****$N","OTL(BO1Doffer.Status.FailedToStop)","8"
RCOMMENT,"BO1Program","BO1Doffer","****$NGeneral Faulted Status$N****","OTE(BO1Doffer.Status.Faulted)","9"
RCOMMENT,"BO1Program","BO1Doffer","****$NReset Fault Latches$N****","OTU(BO1Doffer.Status.FailedToStop)","10"
RCOMMENT,"BO1Program","BO1DoorLocks","****$NThe permissive to lock is delayed by the timer.$N****","OTE(BO1DoorLocks.Internal.LockPermissive)","0"
RCOMMENT,"BO1Program","BO1DoorLocks","****$NThe permissive to unlock is delayed by the timer.$N****","OTE(BO1DoorLocks.Internal.UnlockPermissive)","1"
RCOMMENT,"BO1Program","BO1DoorLocks","****$NThe unlock command works if the permissive above is satisfied.$N****","OTE(BO1DoorLocks.Internal.IntermediateUnlock)","2"
RCOMMENT,"BO1Program","BO1DoorLocks","****$NStatus for the HMI$N****","OTE(BO1DoorLocks.Status.Locked)","3"
RCOMMENT,"BO1Program","BO1DoorLocks","****$NStatus for the HMI$N****","OTE(BO1DoorLocks.Status.Unlocked)","4"
RCOMMENT,"BO1Program","BO1DoorLocks","****$NFire the Outputs$N****","OTE(BO1TopAccessHatchReleaseSol)","5"
RCOMMENT,"BO1Program","BO1Dump","****$NPermissive to operate$N****","OTE(BO1Dump.Internal.Permissive)","0"
RCOMMENT,"BO1Program","BO1Dump","****$NSolenoid to Automatic Mode$N****","OTU(BO1Dump.Command.ToAuto)","1"
RCOMMENT,"BO1Program","BO1Dump","****$NSolenoid to Manua Mode$N****","OTU(BO1Dump.Command.ToManual)","2"
RCOMMENT,"BO1Program","BO1Dump","****$NIf the solenoid is not in either mode, put in manual mode.$N****","OTL(BO1Dump.Status.InManual)","3"
RCOMMENT,"BO1Program","BO1Dump","****$NManual Run Control$N****","OTE(BO1Dump.Internal.ManualOpen)","4"
RCOMMENT,"BO1Program","BO1Dump","****$NAutomatic mode controls.$N****","TOF(BO1Dump.Internal.DelayOpenTimer,?,?)","5"
RCOMMENT,"BO1Program","BO1Dump","****$NControl of the solenoid.$N****","OTE(BO1Dump.Status.Open)","6"
RCOMMENT,"BO1Program","BO1Dump","****$NOpen Status$N****","OTE(BO1Dump.Status.Closed)","7"
RCOMMENT,"BO1Program","BO1ExtendedApron","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(BO1ExtendedApron.Internal.Permissive)","0"
RCOMMENT,"BO1Program","BO1ExtendedApron","****$NJog Command$N****","OTE(BO1ExtendedApron.Internal.IntermediateJog)","1"
RCOMMENT,"BO1Program","BO1ExtendedApron","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(BO1ExtendedApron.Internal.DriveReverse)","2"
RCOMMENT,"BO1Program","BO1ExtendedApron","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(BO1ExtendedApron.Internal.MaintModeRun)","3"
RCOMMENT,"BO1Program","BO1ExtendedApron","****$NAutomatic control.  The TON is dalay for start while the TOF is $Nthe delay for stop.$N****","OTE(BO1ExtendedApron.Internal.AutoModeRun)","4"
RCOMMENT,"BO1Program","BO1ExtendedApron","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(BO1ExtendedApron.Internal.ReleaseRamp)","5"
RCOMMENT,"BO1Program","BO1ExtendedApron","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(BO1ExtendedApron.Internal.DecelTime,BO1ExtendedApron.Internal.DecelTime)","6"
RCOMMENT,"BO1Program","BO1ExtendedApron","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(BO1ExtendedApron.Internal.SpeedReference.ScaledOutput,BO1ExtendedApron:O.FreqCommand)","7"
RCOMMENT,"BO1Program","BO1ExtendedApron","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(BO1ExtendedApron:O.Start)","8"
RCOMMENT,"BO1Program","BO1ExtendedApron","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(BO1ExtendedApron:O.Stop)","9"
RCOMMENT,"BO1Program","BO1ExtendedApron","****$NThe reverse command is set above.$N****","OTE(BO1ExtendedApron:O.Reverse)","10"
RCOMMENT,"BO1Program","BO1ExtendedApron","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(BO1ExtendedApron:O.Forward)","11"
RCOMMENT,"BO1Program","BO1ExtendedApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO1ExtendedApron.Internal.ActualSpeedScaler.ScaledOutput,BO1ExtendedApron.Status.ActualSpeed)","12"
RCOMMENT,"BO1Program","BO1ExtendedApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO1ExtendedApron.Internal.LoadScaler.ScaledOutput,BO1ExtendedApron.Status.MotorLoad)","13"
RCOMMENT,"BO1Program","BO1ExtendedApron","****$NDrive Running Status$N****","OTE(BO1ExtendedApron.Status.Running)","14"
RCOMMENT,"BO1Program","BO1ExtendedApron","****$NJogging Forward Status$N****","OTE(BO1ExtendedApron.Status.JoggingFwd)","15"
RCOMMENT,"BO1Program","BO1ExtendedApron","****$NJogging Reverse Status$N****","OTE(BO1ExtendedApron.Status.JoggingRev)","16"
RCOMMENT,"BO1Program","BO1ExtendedApron","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(BO1ExtendedApron.Status.FailedToStart)","17"
RCOMMENT,"BO1Program","BO1ExtendedApron","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(BO1ExtendedApron.Status.FailedToStop)","18"
RCOMMENT,"BO1Program","BO1ExtendedApron","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(BO1ExtendedApron.Status.Faulted)","19"
RCOMMENT,"BO1Program","BO1ExtendedApron","****$NUnlatch the Drive Faulted Status$N****","OTU(BO1ExtendedApron.Status.FailedToStop)","20"
RCOMMENT,"BO1Program","BO1LiftApron","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(BO1LiftApron.Internal.Permissive)","0"
RCOMMENT,"BO1Program","BO1LiftApron","****$NJog Command$N****","OTE(BO1LiftApron.Internal.IntermediateJog)","1"
RCOMMENT,"BO1Program","BO1LiftApron","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(BO1LiftApron.Internal.DriveReverse)","2"
RCOMMENT,"BO1Program","BO1LiftApron","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(BO1LiftApron.Internal.MaintModeRun)","3"
RCOMMENT,"BO1Program","BO1LiftApron","****$NThis timer makes sure the doffer is running and up to speed$Nbefore the lfit apron starts.$N****","TON(BO1.Internal.DofferRunningTimer,?,?)","4"
RCOMMENT,"BO1Program","BO1LiftApron","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(BO1LiftApron.Internal.ReleaseRamp)","5"
RCOMMENT,"BO1Program","BO1LiftApron","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(BO1LiftApron.Internal.DecelTime,BO1LiftApron.Internal.DecelTime)","6"
RCOMMENT,"BO1Program","BO1LiftApron","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(BO1LiftApron.Internal.SpeedReference.ScaledOutput,BO1LiftApron:O.FreqCommand)","7"
RCOMMENT,"BO1Program","BO1LiftApron","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(BO1LiftApron:O.Start)","8"
RCOMMENT,"BO1Program","BO1LiftApron","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(BO1LiftApron:O.Stop)","9"
RCOMMENT,"BO1Program","BO1LiftApron","****$NThe reverse command is set above.$N****","OTE(BO1LiftApron:O.Reverse)","10"
RCOMMENT,"BO1Program","BO1LiftApron","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(BO1LiftApron:O.Forward)","11"
RCOMMENT,"BO1Program","BO1LiftApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO1LiftApron.Internal.ActualSpeedScaler.ScaledOutput,BO1LiftApron.Status.ActualSpeed)","12"
RCOMMENT,"BO1Program","BO1LiftApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO1LiftApron.Internal.LoadScaler.ScaledOutput,BO1LiftApron.Status.MotorLoad)","13"
RCOMMENT,"BO1Program","BO1LiftApron","****$NDrive Running Status$N****","OTE(BO1LiftApron.Status.Running)","14"
RCOMMENT,"BO1Program","BO1LiftApron","****$NJogging Forward Status$N****","OTE(BO1LiftApron.Status.JoggingFwd)","15"
RCOMMENT,"BO1Program","BO1LiftApron","****$NJogging Reverse Status$N****","OTE(BO1LiftApron.Status.JoggingRev)","16"
RCOMMENT,"BO1Program","BO1LiftApron","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(BO1LiftApron.Status.FailedToStart)","17"
RCOMMENT,"BO1Program","BO1LiftApron","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(BO1LiftApron.Status.FailedToStop)","18"
RCOMMENT,"BO1Program","BO1LiftApron","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(BO1LiftApron.Status.Faulted)","19"
RCOMMENT,"BO1Program","BO1LiftApron","****$NUnlatch the Drive Faulted Status$N****","OTU(BO1LiftApron.Status.FailedToStop)","20"
RCOMMENT,"BO1Program","BO1LoadApron","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(BO1LoadApron.Internal.Permissive)","0"
RCOMMENT,"BO1Program","BO1LoadApron","****$NJog Command$N****","OTE(BO1LoadApron.Internal.IntermediateJog)","1"
RCOMMENT,"BO1Program","BO1LoadApron","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(BO1LoadApron.Internal.DriveReverse)","2"
RCOMMENT,"BO1Program","BO1LoadApron","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(BO1LoadApron.Internal.MaintModeRun)","3"
RCOMMENT,"BO1Program","BO1LoadApron","****$NRestart Control$N****","OTE(BO1LoadApron.Internal.IntermediateAutoRun)","4"
RCOMMENT,"BO1Program","BO1LoadApron","****$NControl the Restart Horn$N****","OTE(BO1BaleOpenerRestartHorn)","5"
RCOMMENT,"BO1Program","BO1LoadApron","****$NAutomatic control.  The TON is dalay for start while the TOF is $Nthe delay for stop.$N****","OTE(BO1LoadApron.Internal.AutoModeRun)","6"
RCOMMENT,"BO1Program","BO1LoadApron","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(BO1LoadApron.Internal.ReleaseRamp)","7"
RCOMMENT,"BO1Program","BO1LoadApron","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(BO1LoadApron.Internal.DecelTime,BO1LoadApron.Internal.DecelTime)","8"
RCOMMENT,"BO1Program","BO1LoadApron","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(BO1LoadApron.Internal.SpeedReference.ScaledOutput,BO1LoadApron:O.FreqCommand)","9"
RCOMMENT,"BO1Program","BO1LoadApron","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(BO1LoadApron:O.Start)","10"
RCOMMENT,"BO1Program","BO1LoadApron","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(BO1LoadApron:O.Stop)","11"
RCOMMENT,"BO1Program","BO1LoadApron","****$NThe reverse command is set above.$N****","OTE(BO1LoadApron:O.Reverse)","12"
RCOMMENT,"BO1Program","BO1LoadApron","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(BO1LoadApron:O.Forward)","13"
RCOMMENT,"BO1Program","BO1LoadApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO1LoadApron.Internal.ActualSpeedScaler.ScaledOutput,BO1LoadApron.Status.ActualSpeed)","14"
RCOMMENT,"BO1Program","BO1LoadApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO1LoadApron.Internal.LoadScaler.ScaledOutput,BO1LoadApron.Status.MotorLoad)","15"
RCOMMENT,"BO1Program","BO1LoadApron","****$NDrive Running Status$N****","OTE(BO1LoadApron.Status.Running)","16"
RCOMMENT,"BO1Program","BO1LoadApron","****$NJogging Forward Status$N****","OTE(BO1LoadApron.Status.JoggingFwd)","17"
RCOMMENT,"BO1Program","BO1LoadApron","****$NJogging Reverse Status$N****","OTE(BO1LoadApron.Status.JoggingRev)","18"
RCOMMENT,"BO1Program","BO1LoadApron","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(BO1LoadApron.Status.FailedToStart)","19"
RCOMMENT,"BO1Program","BO1LoadApron","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(BO1LoadApron.Status.FailedToStop)","20"
RCOMMENT,"BO1Program","BO1LoadApron","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(BO1LoadApron.Status.Faulted)","21"
RCOMMENT,"BO1Program","BO1LoadApron","****$NUnlatch the Drive Faulted Status$N****","OTU(BO1LoadApron.Status.FailedToStop)","22"
RCOMMENT,"BO1Program","BO1LoadDoor","****$NPermissive to operate$N****","OTE(BO1LoadDoor.Internal.Permissive)","0"
RCOMMENT,"BO1Program","BO1LoadDoor","****$NSolenoid to Automatic Mode$N****","OTU(BO1LoadDoor.Command.ToAuto)","1"
RCOMMENT,"BO1Program","BO1LoadDoor","****$NSolenoid to Manua Mode$N****","OTU(BO1LoadDoor.Command.ToManual)","2"
RCOMMENT,"BO1Program","BO1LoadDoor","****$NIf the solenoid is not in either mode, put in manual mode.$N****","OTL(BO1LoadDoor.Status.InManual)","3"
RCOMMENT,"BO1Program","BO1LoadDoor","****$NManual Run Control$N****","OTE(BO1LoadDoor.Internal.ManualClose)","4"
RCOMMENT,"BO1Program","BO1LoadDoor","****$NManual Run Control$N****","OTE(BO1LoadDoor.Internal.ManualOpen)","5"
RCOMMENT,"BO1Program","BO1LoadDoor","****$NControl of the solenoid.$N****","OTE(BO1LoadDoorCloseSol)","6"
RCOMMENT,"BO1Program","BO1LoadDoor","****$NControl of the solenoid.$N****","OTE(BO1LoadDoorOpenSol)","7"
RCOMMENT,"BO1Program","BO1LoadDoor","****$NOpen Status$N****","OTE(BO1LoadDoor.Status.Open)","8"
RCOMMENT,"BO1Program","BO1LoadDoor","****$NControl for the gate open pilot light.$N****","OTE(BO1LoadDoorClosedPL)","9"
RCOMMENT,"BO1Program","BO1LoadDoor","****$NOpen beacon control$N****","OTE(BO1LoadDoorOpenBeacon)","11"
RCOMMENT,"BO1Program","BO1LoadDoor","****$NThe pushbutton will unlock the gate above the load door if$Nthe conditions are met.$N****","OTE(BO1LoadGateReleaseSol)","12"
RCOMMENT,"BO1Program","BO1ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO1Control,0)","0"
RCOMMENT,"BO1Program","BO1ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO1Breaker,0)","1"
RCOMMENT,"BO1Program","BO1ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO1Damper,0)","2"
RCOMMENT,"BO1Program","BO1ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO1Doffer,0)","3"
RCOMMENT,"BO1Program","BO1ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO1DoorLocks,0)","4"
RCOMMENT,"BO1Program","BO1ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO1Dump,0)","5"
RCOMMENT,"BO1Program","BO1ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO1ExtendedApron,0)","6"
RCOMMENT,"BO1Program","BO1ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO1LiftApron,0)","7"
RCOMMENT,"BO1Program","BO1ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO1LoadApron,0)","8"
RCOMMENT,"BO1Program","BO1ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO1LoadDoor,0)","9"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"BO2Program","BO2Breaker","****$NPermissive to Operate$N****","OTE(BO2Breaker.Internal.Permissive)","0"
RCOMMENT,"BO2Program","BO2Breaker","****$NManual Run Control$N****","OTE(BO2Breaker.Internal.IntermediateRunForward)","1"
RCOMMENT,"BO2Program","BO2Breaker","****$NManual Jog Control$N****","OTE(BO2Breaker.Internal.IntermediateJogForward)","2"
RCOMMENT,"BO2Program","BO2Breaker","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(BO2Breaker.Internal.AutoOffDelayTimer,?,?)","3"
RCOMMENT,"BO2Program","BO2Breaker","****$NMotor Starter Control$N****","OTE(BO2BreakerCont)","4"
RCOMMENT,"BO2Program","BO2Breaker","****$NRunning Status$N****","OTE(BO2Breaker.Status.RunningForward)","5"
RCOMMENT,"BO2Program","BO2Breaker","****$NIf the motor does not start when commanded, it has failed to run$N****","OTL(BO2Breaker.Status.FailedToStart)","6"
RCOMMENT,"BO2Program","BO2Breaker","****$NIf a motor continues to run when the run command has been removed,$Nit has failed to stop.$N****$N","OTL(BO2Breaker.Status.FailedToStop)","7"
RCOMMENT,"BO2Program","BO2Breaker","****$NGeneral Faulted Status$N****","OTE(BO2Breaker.Status.Faulted)","8"
RCOMMENT,"BO2Program","BO2Breaker","****$NReset Fault Latches$N****","OTU(BO2Breaker.Status.FailedToStop)","9"
RCOMMENT,"BO2Program","BO2Control","****$NPermissive to Operate Manually$N****","OTE(BO2.Internal.Permissive)","0"
RCOMMENT,"BO2Program","BO2Control","****$NEnable the Hopper for Operation$N****","OTU(BO2.Command.Enable)","1"
RCOMMENT,"BO2Program","BO2Control","****$NDisable the Hopper$N****","OTU(BO2.Command.Disable)","2"
RCOMMENT,"BO2Program","BO2Control","****$NDisable the hopper if it is neither enabled or disabled.$N****","OTL(BO2.Status.Disabled)","3"
RCOMMENT,"BO2Program","BO2Control","****$NIf the blend line is not running or the hopper is not enabled, enable manual controls.$N****","OTE(BO2.Internal.EnableManualControls)","4"
RCOMMENT,"BO2Program","BO2Control","****$NCheck the setpoint against limits$N****","SUB(BO2.Command.WeightSetpoint,BO2.Command.AnticipationWeight,BO2.Internal.StopWeight)","5"
RCOMMENT,"BO2Program","BO2Control","****$NScale the analog input to determine weight.$N****","MOV(BO2.Internal.WeightScaler.ScaledOutput,BO2.Status.CurrentWeight)","6"
RCOMMENT,"BO2Program","BO2Control","****$NWhen the blend line is in weigh mode, the lift apron slows when the weight gets$Nabove the slow down ratio.$N****","OTE(BO2.Status.SlowDownActive)","7"
RCOMMENT,"BO2Program","BO2Control","****$NWhen the blend line is in weigh mode the lift apron stops$Nand the door closes when the pan reaches setpoint.$N****","OTL(BO2.Status.WeightSetpointReached)","8"
RCOMMENT,"BO2Program","BO2Control","****$NSet up the values for the upper and lower weights that will cause an alarm$N(OUT OF TOLERANCE VALUES)$N****","SUB(BO2.Command.WeightSetpoint,BO2.Internal.WeightAlarmValue,BO2.Status.AlarmWeightLowerWindow)","9"
RCOMMENT,"BO2Program","BO2Control","****$NWhen the settling timer is done, shift the array numbers down and move the latest$Nweight into array 9.  Array 9 will be the latest value. 8 will be previous then 7, etc.$N****","OTL(BO2.Status.LowWeightAlarm)","10"
RCOMMENT,"BO2Program","BO2Control","****$NReset the setpoint reached bit.$N****","OTU(BO2.Status.WeightSetpointReached)","11"
RCOMMENT,"BO2Program","BO2Control","****$NThe photoeye should control the extended apron.  If the lift apron is running for too long$Nwithout anything blocking the eye, there is a problem.  Perhaps the hopper is empty.$N****","OTE(BO2.Internal.HopperPETooLong)","12"
RCOMMENT,"BO2Program","BO2Control","****$NHopper filling status.$N****","OTE(BO2.Status.Filling)","13"
RCOMMENT,"BO2Program","BO2Control","****$NIf the weight is not reached in a certain amount of time...alarm.$N****","TON(BO2FillTooLongTmr,?,?)","14"
RCOMMENT,"BO2Program","BO2Control","****$NGeneral alarm for HMI display.$N****","OTE(BO2.Status.WeightAlarm)","15"
RCOMMENT,"BO2Program","BO2Control","****$NReset the alarm latches.$N****","OTU(BO2.Status.LowWeightAlarm)","16"
RCOMMENT,"BO2Program","BO2Control","****$NThe RunLiftAprons bit comes from the blend control routine.$NAfter the appropriate drives are running and the call for fiber is on, this$Nbit comes on.  If the hopper is enabled, run the lift apron.$N****","OTE(BO2.Internal.RunLiftApron)","17"
RCOMMENT,"BO2Program","BO2Control","****$NThe restart pushbutton needs to reset the safety zone and the drive before restarting the system.$N****","OTE(BO2RestartSystem)","18"
RCOMMENT,"BO2Program","BO2Damper","****$NPermissive to operate$N****","OTE(BO2Damper.Internal.Permissive)","0"
RCOMMENT,"BO2Program","BO2Damper","****$NSolenoid to Automatic Mode$N****","OTU(BO2Damper.Command.ToAuto)","1"
RCOMMENT,"BO2Program","BO2Damper","****$NSolenoid to Manua Mode$N****","OTU(BO2Damper.Command.ToManual)","2"
RCOMMENT,"BO2Program","BO2Damper","****$NIf the solenoid is not in either mode, put in manual mode.$N****","OTL(BO2Damper.Status.InManual)","3"
RCOMMENT,"BO2Program","BO2Damper","****$NManual Run Control$N****","OTE(BO2Damper.Internal.ManualOpen)","4"
RCOMMENT,"BO2Program","BO2Damper","****$NAutomatic mode controls.$N****","TOF(BO2Damper.Internal.DelayCloseTimer,?,?)","5"
RCOMMENT,"BO2Program","BO2Damper","****$NControl of the solenoid.$N****","OTE(BO2Damper.Internal.IntermediateOpen)","6"
RCOMMENT,"BO2Program","BO2Damper","****$NIf not open command, then close command.$N****","OTE(BO2WeighPanDamperCloseSol)","7"
RCOMMENT,"BO2Program","BO2Damper","****$NOpen Status$N****","OTE(BO2Damper.Status.Open)","8"
RCOMMENT,"BO2Program","BO2Damper","****$NClosed Status$N****","OTE(BO2Damper.Status.Closed)","9"
RCOMMENT,"BO2Program","BO2Doffer","****$NPermissive to Operate$N****","OTE(BO2Doffer.Internal.Permissive)","0"
RCOMMENT,"BO2Program","BO2Doffer","****$NManual Run Control$N****","OTE(BO2Doffer.Internal.IntermediateRunForward)","1"
RCOMMENT,"BO2Program","BO2Doffer","****$NManual Jog Control$N****","OTE(BO2Doffer.Internal.IntermediateJogForward)","2"
RCOMMENT,"BO2Program","BO2Doffer","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(BO2Doffer.Internal.AutoOffDelayTimer,?,?)","3"
RCOMMENT,"BO2Program","BO2Doffer","****$NIf the permissive is lost, reset the TOF for immediate stop.$N****","RES(BO2Doffer.Internal.AutoOffDelayTimer)","4"
RCOMMENT,"BO2Program","BO2Doffer","****$NMotor Starter Control$N****","OTE(BO2DofferCont)","5"
RCOMMENT,"BO2Program","BO2Doffer","****$NRunning Status$N****","OTE(BO2Doffer.Status.RunningForward)","6"
RCOMMENT,"BO2Program","BO2Doffer","****$NIf the motor does not start when commanded, it has failed to run$N****","OTL(BO2Doffer.Status.FailedToStart)","7"
RCOMMENT,"BO2Program","BO2Doffer","****$NIf a motor continues to run when the run command has been removed,$Nit has failed to stop.$N****$N","OTL(BO2Doffer.Status.FailedToStop)","8"
RCOMMENT,"BO2Program","BO2Doffer","****$NGeneral Faulted Status$N****","OTE(BO2Doffer.Status.Faulted)","9"
RCOMMENT,"BO2Program","BO2Doffer","****$NReset Fault Latches$N****","OTU(BO2Doffer.Status.FailedToStop)","10"
RCOMMENT,"BO2Program","BO2DoorLocks","****$NThe permissive to lock is delayed by the timer.$N****","OTE(BO2DoorLocks.Internal.LockPermissive)","0"
RCOMMENT,"BO2Program","BO2DoorLocks","****$NThe permissive to unlock is delayed by the timer.$N****","OTE(BO2DoorLocks.Internal.UnlockPermissive)","1"
RCOMMENT,"BO2Program","BO2DoorLocks","****$NThe unlock command works if the permissive above is satisfied.$N****","OTE(BO2DoorLocks.Internal.IntermediateUnlock)","2"
RCOMMENT,"BO2Program","BO2DoorLocks","****$NStatus for the HMI$N****","OTE(BO2DoorLocks.Status.Locked)","3"
RCOMMENT,"BO2Program","BO2DoorLocks","****$NStatus for the HMI$N****","OTE(BO2DoorLocks.Status.Unlocked)","4"
RCOMMENT,"BO2Program","BO2DoorLocks","****$NFire the Outputs$N****","OTE(BO2TopAccessHatchReleaseSol)","5"
RCOMMENT,"BO2Program","BO2Dump","****$NPermissive to operate$N****","OTE(BO2Dump.Internal.Permissive)","0"
RCOMMENT,"BO2Program","BO2Dump","****$NSolenoid to Automatic Mode$N****","OTU(BO2Dump.Command.ToAuto)","1"
RCOMMENT,"BO2Program","BO2Dump","****$NSolenoid to Manua Mode$N****","OTU(BO2Dump.Command.ToManual)","2"
RCOMMENT,"BO2Program","BO2Dump","****$NIf the solenoid is not in either mode, put in manual mode.$N****","OTL(BO2Dump.Status.InManual)","3"
RCOMMENT,"BO2Program","BO2Dump","****$NManual Run Control$N****","OTE(BO2Dump.Internal.ManualOpen)","4"
RCOMMENT,"BO2Program","BO2Dump","****$NAutomatic mode controls.$N****","TOF(BO2Dump.Internal.DelayOpenTimer,?,?)","5"
RCOMMENT,"BO2Program","BO2Dump","****$NControl of the solenoid.$N****","OTE(BO2Dump.Status.Open)","6"
RCOMMENT,"BO2Program","BO2Dump","****$NOpen Status$N****","OTE(BO2Dump.Status.Closed)","7"
RCOMMENT,"BO2Program","BO2ExtendedApron","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(BO2ExtendedApron.Internal.Permissive)","0"
RCOMMENT,"BO2Program","BO2ExtendedApron","****$NJog Command$N****","OTE(BO2ExtendedApron.Internal.IntermediateJog)","1"
RCOMMENT,"BO2Program","BO2ExtendedApron","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(BO2ExtendedApron.Internal.DriveReverse)","2"
RCOMMENT,"BO2Program","BO2ExtendedApron","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(BO2ExtendedApron.Internal.MaintModeRun)","3"
RCOMMENT,"BO2Program","BO2ExtendedApron","****$NAutomatic control.  The TON is dalay for start while the TOF is $Nthe delay for stop.$N****","OTE(BO2ExtendedApron.Internal.AutoModeRun)","4"
RCOMMENT,"BO2Program","BO2ExtendedApron","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(BO2ExtendedApron.Internal.ReleaseRamp)","5"
RCOMMENT,"BO2Program","BO2ExtendedApron","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(BO2ExtendedApron.Internal.DecelTime,BO2ExtendedApron.Internal.DecelTime)","6"
RCOMMENT,"BO2Program","BO2ExtendedApron","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(BO2ExtendedApron.Internal.SpeedReference.ScaledOutput,BO2ExtendedApron:O.FreqCommand)","7"
RCOMMENT,"BO2Program","BO2ExtendedApron","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(BO2ExtendedApron:O.Start)","8"
RCOMMENT,"BO2Program","BO2ExtendedApron","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(BO2ExtendedApron:O.Stop)","9"
RCOMMENT,"BO2Program","BO2ExtendedApron","****$NThe reverse command is set above.$N****","OTE(BO2ExtendedApron:O.Reverse)","10"
RCOMMENT,"BO2Program","BO2ExtendedApron","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(BO2ExtendedApron:O.Forward)","11"
RCOMMENT,"BO2Program","BO2ExtendedApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO2ExtendedApron.Internal.ActualSpeedScaler.ScaledOutput,BO2ExtendedApron.Status.ActualSpeed)","12"
RCOMMENT,"BO2Program","BO2ExtendedApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO2ExtendedApron.Internal.LoadScaler.ScaledOutput,BO2ExtendedApron.Status.MotorLoad)","13"
RCOMMENT,"BO2Program","BO2ExtendedApron","****$NDrive Running Status$N****","OTE(BO2ExtendedApron.Status.Running)","14"
RCOMMENT,"BO2Program","BO2ExtendedApron","****$NJogging Forward Status$N****","OTE(BO2ExtendedApron.Status.JoggingFwd)","15"
RCOMMENT,"BO2Program","BO2ExtendedApron","****$NJogging Reverse Status$N****","OTE(BO2ExtendedApron.Status.JoggingRev)","16"
RCOMMENT,"BO2Program","BO2ExtendedApron","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(BO2ExtendedApron.Status.FailedToStart)","17"
RCOMMENT,"BO2Program","BO2ExtendedApron","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(BO2ExtendedApron.Status.FailedToStop)","18"
RCOMMENT,"BO2Program","BO2ExtendedApron","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(BO2ExtendedApron.Status.Faulted)","19"
RCOMMENT,"BO2Program","BO2ExtendedApron","****$NUnlatch the Drive Faulted Status$N****","OTU(BO2ExtendedApron.Status.FailedToStop)","20"
RCOMMENT,"BO2Program","BO2LiftApron","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(BO2LiftApron.Internal.Permissive)","0"
RCOMMENT,"BO2Program","BO2LiftApron","****$NJog Command$N****","OTE(BO2LiftApron.Internal.IntermediateJog)","1"
RCOMMENT,"BO2Program","BO2LiftApron","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(BO2LiftApron.Internal.DriveReverse)","2"
RCOMMENT,"BO2Program","BO2LiftApron","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(BO2LiftApron.Internal.MaintModeRun)","3"
RCOMMENT,"BO2Program","BO2LiftApron","****$NThis timer makes sure the doffer is running and up to speed$Nbefore the lfit apron starts.$N****","TON(BO2.Internal.DofferRunningTimer,?,?)","4"
RCOMMENT,"BO2Program","BO2LiftApron","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(BO2LiftApron.Internal.ReleaseRamp)","5"
RCOMMENT,"BO2Program","BO2LiftApron","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(BO2LiftApron.Internal.DecelTime,BO2LiftApron.Internal.DecelTime)","6"
RCOMMENT,"BO2Program","BO2LiftApron","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(BO2LiftApron.Internal.SpeedReference.ScaledOutput,BO2LiftApron:O.FreqCommand)","7"
RCOMMENT,"BO2Program","BO2LiftApron","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(BO2LiftApron:O.Start)","8"
RCOMMENT,"BO2Program","BO2LiftApron","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(BO2LiftApron:O.Stop)","9"
RCOMMENT,"BO2Program","BO2LiftApron","****$NThe reverse command is set above.$N****","OTE(BO2LiftApron:O.Reverse)","10"
RCOMMENT,"BO2Program","BO2LiftApron","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(BO2LiftApron:O.Forward)","11"
RCOMMENT,"BO2Program","BO2LiftApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO2LiftApron.Internal.ActualSpeedScaler.ScaledOutput,BO2LiftApron.Status.ActualSpeed)","12"
RCOMMENT,"BO2Program","BO2LiftApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO2LiftApron.Internal.LoadScaler.ScaledOutput,BO2LiftApron.Status.MotorLoad)","13"
RCOMMENT,"BO2Program","BO2LiftApron","****$NDrive Running Status$N****","OTE(BO2LiftApron.Status.Running)","14"
RCOMMENT,"BO2Program","BO2LiftApron","****$NJogging Forward Status$N****","OTE(BO2LiftApron.Status.JoggingFwd)","15"
RCOMMENT,"BO2Program","BO2LiftApron","****$NJogging Reverse Status$N****","OTE(BO2LiftApron.Status.JoggingRev)","16"
RCOMMENT,"BO2Program","BO2LiftApron","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(BO2LiftApron.Status.FailedToStart)","17"
RCOMMENT,"BO2Program","BO2LiftApron","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(BO2LiftApron.Status.FailedToStop)","18"
RCOMMENT,"BO2Program","BO2LiftApron","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(BO2LiftApron.Status.Faulted)","19"
RCOMMENT,"BO2Program","BO2LiftApron","****$NUnlatch the Drive Faulted Status$N****","OTU(BO2LiftApron.Status.FailedToStop)","20"
RCOMMENT,"BO2Program","BO2LoadApron","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(BO2LoadApron.Internal.Permissive)","0"
RCOMMENT,"BO2Program","BO2LoadApron","****$NJog Command$N****","OTE(BO2LoadApron.Internal.IntermediateJog)","1"
RCOMMENT,"BO2Program","BO2LoadApron","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(BO2LoadApron.Internal.DriveReverse)","2"
RCOMMENT,"BO2Program","BO2LoadApron","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(BO2LoadApron.Internal.MaintModeRun)","3"
RCOMMENT,"BO2Program","BO2LoadApron","****$NRestart Control$N****","OTE(BO2LoadApron.Internal.IntermediateAutoRun)","4"
RCOMMENT,"BO2Program","BO2LoadApron","****$NControl the Restart Horn$N****","OTE(BO2BaleOpenerRestartHorn)","5"
RCOMMENT,"BO2Program","BO2LoadApron","****$NAutomatic control.  The TON is dalay for start while the TOF is $Nthe delay for stop.$N****","OTE(BO2LoadApron.Internal.AutoModeRun)","6"
RCOMMENT,"BO2Program","BO2LoadApron","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(BO2LoadApron.Internal.ReleaseRamp)","7"
RCOMMENT,"BO2Program","BO2LoadApron","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(BO2LoadApron.Internal.DecelTime,BO2LoadApron.Internal.DecelTime)","8"
RCOMMENT,"BO2Program","BO2LoadApron","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(BO2LoadApron.Internal.SpeedReference.ScaledOutput,BO2LoadApron:O.FreqCommand)","9"
RCOMMENT,"BO2Program","BO2LoadApron","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(BO2LoadApron:O.Start)","10"
RCOMMENT,"BO2Program","BO2LoadApron","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(BO2LoadApron:O.Stop)","11"
RCOMMENT,"BO2Program","BO2LoadApron","****$NThe reverse command is set above.$N****","OTE(BO2LoadApron:O.Reverse)","12"
RCOMMENT,"BO2Program","BO2LoadApron","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(BO2LoadApron:O.Forward)","13"
RCOMMENT,"BO2Program","BO2LoadApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO2LoadApron.Internal.ActualSpeedScaler.ScaledOutput,BO2LoadApron.Status.ActualSpeed)","14"
RCOMMENT,"BO2Program","BO2LoadApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO2LoadApron.Internal.LoadScaler.ScaledOutput,BO2LoadApron.Status.MotorLoad)","15"
RCOMMENT,"BO2Program","BO2LoadApron","****$NDrive Running Status$N****","OTE(BO2LoadApron.Status.Running)","16"
RCOMMENT,"BO2Program","BO2LoadApron","****$NJogging Forward Status$N****","OTE(BO2LoadApron.Status.JoggingFwd)","17"
RCOMMENT,"BO2Program","BO2LoadApron","****$NJogging Reverse Status$N****","OTE(BO2LoadApron.Status.JoggingRev)","18"
RCOMMENT,"BO2Program","BO2LoadApron","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(BO2LoadApron.Status.FailedToStart)","19"
RCOMMENT,"BO2Program","BO2LoadApron","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(BO2LoadApron.Status.FailedToStop)","20"
RCOMMENT,"BO2Program","BO2LoadApron","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(BO2LoadApron.Status.Faulted)","21"
RCOMMENT,"BO2Program","BO2LoadApron","****$NUnlatch the Drive Faulted Status$N****","OTU(BO2LoadApron.Status.FailedToStop)","22"
RCOMMENT,"BO2Program","BO2LoadDoor","****$NPermissive to operate$N****","OTE(BO2LoadDoor.Internal.Permissive)","0"
RCOMMENT,"BO2Program","BO2LoadDoor","****$NSolenoid to Automatic Mode$N****","OTU(BO2LoadDoor.Command.ToAuto)","1"
RCOMMENT,"BO2Program","BO2LoadDoor","****$NSolenoid to Manua Mode$N****","OTU(BO2LoadDoor.Command.ToManual)","2"
RCOMMENT,"BO2Program","BO2LoadDoor","****$NIf the solenoid is not in either mode, put in manual mode.$N****","OTL(BO2LoadDoor.Status.InManual)","3"
RCOMMENT,"BO2Program","BO2LoadDoor","****$NManual Run Control$N****","OTE(BO2LoadDoor.Internal.ManualClose)","4"
RCOMMENT,"BO2Program","BO2LoadDoor","****$NManual Run Control$N****","OTE(BO2LoadDoor.Internal.ManualOpen)","5"
RCOMMENT,"BO2Program","BO2LoadDoor","****$NControl of the solenoid.$N****","OTE(BO2LoadDoorCloseSol)","6"
RCOMMENT,"BO2Program","BO2LoadDoor","****$NControl of the solenoid.$N****","OTE(BO2LoadDoorOpenSol)","7"
RCOMMENT,"BO2Program","BO2LoadDoor","****$NOpen Status$N****","OTE(BO2LoadDoor.Status.Open)","8"
RCOMMENT,"BO2Program","BO2LoadDoor","****$NControl for the gate open pilot light.$N****","OTE(BO2LoadDoorClosedPL)","9"
RCOMMENT,"BO2Program","BO2LoadDoor","****$NOpen beacon control$N****","OTE(BO2LoadDoorOpenBeacon)","11"
RCOMMENT,"BO2Program","BO2LoadDoor","****$NThe pushbutton will unlock the gate above the load door if$Nthe conditions are met.$N****","OTE(BO2LoadGateReleaseSol)","12"
RCOMMENT,"BO2Program","BO2ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO2Control,0)","0"
RCOMMENT,"BO2Program","BO2ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO2Breaker,0)","1"
RCOMMENT,"BO2Program","BO2ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO2Damper,0)","2"
RCOMMENT,"BO2Program","BO2ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO2Doffer,0)","3"
RCOMMENT,"BO2Program","BO2ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO2DoorLocks,0)","4"
RCOMMENT,"BO2Program","BO2ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO2Dump,0)","5"
RCOMMENT,"BO2Program","BO2ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO2ExtendedApron,0)","6"
RCOMMENT,"BO2Program","BO2ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO2LiftApron,0)","7"
RCOMMENT,"BO2Program","BO2ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO2LoadApron,0)","8"
RCOMMENT,"BO2Program","BO2ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO2LoadDoor,0)","9"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"BO3Program","BO3Breaker","****$NPermissive to Operate$N****","OTE(BO3Breaker.Internal.Permissive)","0"
RCOMMENT,"BO3Program","BO3Breaker","****$NManual Run Control$N****","OTE(BO3Breaker.Internal.IntermediateRunForward)","1"
RCOMMENT,"BO3Program","BO3Breaker","****$NManual Jog Control$N****","OTE(BO3Breaker.Internal.IntermediateJogForward)","2"
RCOMMENT,"BO3Program","BO3Breaker","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(BO3Breaker.Internal.AutoOffDelayTimer,?,?)","3"
RCOMMENT,"BO3Program","BO3Breaker","****$NMotor Starter Control$N****","OTE(BO3BreakerCont)","4"
RCOMMENT,"BO3Program","BO3Breaker","****$NRunning Status$N****","OTE(BO3Breaker.Status.RunningForward)","5"
RCOMMENT,"BO3Program","BO3Breaker","****$NIf the motor does not start when commanded, it has failed to run$N****","OTL(BO3Breaker.Status.FailedToStart)","6"
RCOMMENT,"BO3Program","BO3Breaker","****$NIf a motor continues to run when the run command has been removed,$Nit has failed to stop.$N****$N","OTL(BO3Breaker.Status.FailedToStop)","7"
RCOMMENT,"BO3Program","BO3Breaker","****$NGeneral Faulted Status$N****","OTE(BO3Breaker.Status.Faulted)","8"
RCOMMENT,"BO3Program","BO3Breaker","****$NReset Fault Latches$N****","OTU(BO3Breaker.Status.FailedToStop)","9"
RCOMMENT,"BO3Program","BO3Control","****$NPermissive to Operate Manually$N****","OTE(BO3.Internal.Permissive)","0"
RCOMMENT,"BO3Program","BO3Control","****$NEnable the Hopper for Operation$N****","OTU(BO3.Command.Enable)","1"
RCOMMENT,"BO3Program","BO3Control","****$NDisable the Hopper$N****","OTU(BO3.Command.Disable)","2"
RCOMMENT,"BO3Program","BO3Control","****$NDisable the hopper if it is neither enabled or disabled.$N****","OTL(BO3.Status.Disabled)","3"
RCOMMENT,"BO3Program","BO3Control","****$NIf the blend line is not running or the hopper is not enabled, enable manual controls.$N****","OTE(BO3.Internal.EnableManualControls)","4"
RCOMMENT,"BO3Program","BO3Control","****$NCheck the setpoint against limits$N****","SUB(BO3.Command.WeightSetpoint,BO3.Command.AnticipationWeight,BO3.Internal.StopWeight)","5"
RCOMMENT,"BO3Program","BO3Control","****$NScale the analog input to determine weight.$N****","MOV(BO3.Internal.WeightScaler.ScaledOutput,BO3.Status.CurrentWeight)","6"
RCOMMENT,"BO3Program","BO3Control","****$NWhen the blend line is in weigh mode, the lift apron slows when the weight gets$Nabove the slow down ratio.$N****","OTE(BO3.Status.SlowDownActive)","7"
RCOMMENT,"BO3Program","BO3Control","****$NWhen the blend line is in weigh mode the lift apron stops$Nand the door closes when the pan reaches setpoint.$N****","OTL(BO3.Status.WeightSetpointReached)","8"
RCOMMENT,"BO3Program","BO3Control","****$NSet up the values for the upper and lower weights that will cause an alarm$N(OUT OF TOLERANCE VALUES)$N****","SUB(BO3.Command.WeightSetpoint,BO3.Internal.WeightAlarmValue,BO3.Status.AlarmWeightLowerWindow)","9"
RCOMMENT,"BO3Program","BO3Control","****$NWhen the settling timer is done, shift the array numbers down and move the latest$Nweight into array 9.  Array 9 will be the latest value. 8 will be previous then 7, etc.$N****","OTL(BO3.Status.LowWeightAlarm)","10"
RCOMMENT,"BO3Program","BO3Control","****$NReset the setpoint reached bit.$N****","OTU(BO3.Status.WeightSetpointReached)","11"
RCOMMENT,"BO3Program","BO3Control","****$NThe photoeye should control the extended apron.  If the lift apron is running for too long$Nwithout anything blocking the eye, there is a problem.  Perhaps the hopper is empty.$N****","OTE(BO3.Internal.HopperPETooLong)","12"
RCOMMENT,"BO3Program","BO3Control","****$NHopper filling status.$N****","OTE(BO3.Status.Filling)","13"
RCOMMENT,"BO3Program","BO3Control","****$NIf the weight is not reached in a certain amount of time...alarm.$N****","TON(BO3FillTooLongTmr,?,?)","14"
RCOMMENT,"BO3Program","BO3Control","****$NGeneral alarm for HMI display.$N****","OTE(BO3.Status.WeightAlarm)","15"
RCOMMENT,"BO3Program","BO3Control","****$NReset the alarm latches.$N****","OTU(BO3.Status.LowWeightAlarm)","16"
RCOMMENT,"BO3Program","BO3Control","****$NThe RunLiftAprons bit comes from the blend control routine.$NAfter the appropriate drives are running and the call for fiber is on, this$Nbit comes on.  If the hopper is enabled, run the lift apron.$N****","OTE(BO3.Internal.RunLiftApron)","17"
RCOMMENT,"BO3Program","BO3Control","****$NThe restart pushbutton needs to reset the safety zone and the drive before restarting the system.$N****","OTE(BO3RestartSystem)","18"
RCOMMENT,"BO3Program","BO3Damper","****$NPermissive to operate$N****","OTE(BO3Damper.Internal.Permissive)","0"
RCOMMENT,"BO3Program","BO3Damper","****$NSolenoid to Automatic Mode$N****","OTU(BO3Damper.Command.ToAuto)","1"
RCOMMENT,"BO3Program","BO3Damper","****$NSolenoid to Manua Mode$N****","OTU(BO3Damper.Command.ToManual)","2"
RCOMMENT,"BO3Program","BO3Damper","****$NIf the solenoid is not in either mode, put in manual mode.$N****","OTL(BO3Damper.Status.InManual)","3"
RCOMMENT,"BO3Program","BO3Damper","****$NManual Run Control$N****","OTE(BO3Damper.Internal.ManualOpen)","4"
RCOMMENT,"BO3Program","BO3Damper","****$NAutomatic mode controls.$N****","TOF(BO3Damper.Internal.DelayCloseTimer,?,?)","5"
RCOMMENT,"BO3Program","BO3Damper","****$NControl of the solenoid.$N****","OTE(BO3Damper.Internal.IntermediateOpen)","6"
RCOMMENT,"BO3Program","BO3Damper","****$NIf not open command, then close command.$N****","OTE(BO3WeighPanDamperCloseSol)","7"
RCOMMENT,"BO3Program","BO3Damper","****$NOpen Status$N****","OTE(BO3Damper.Status.Open)","8"
RCOMMENT,"BO3Program","BO3Damper","****$NClosed Status$N****","OTE(BO3Damper.Status.Closed)","9"
RCOMMENT,"BO3Program","BO3Doffer","****$NPermissive to Operate$N****","OTE(BO3Doffer.Internal.Permissive)","0"
RCOMMENT,"BO3Program","BO3Doffer","****$NManual Run Control$N****","OTE(BO3Doffer.Internal.IntermediateRunForward)","1"
RCOMMENT,"BO3Program","BO3Doffer","****$NManual Jog Control$N****","OTE(BO3Doffer.Internal.IntermediateJogForward)","2"
RCOMMENT,"BO3Program","BO3Doffer","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(BO3Doffer.Internal.AutoOffDelayTimer,?,?)","3"
RCOMMENT,"BO3Program","BO3Doffer","****$NIf the permissive is lost, reset the TOF for immediate stop.$N****","RES(BO3Doffer.Internal.AutoOffDelayTimer)","4"
RCOMMENT,"BO3Program","BO3Doffer","****$NMotor Starter Control$N****","OTE(BO3DofferCont)","5"
RCOMMENT,"BO3Program","BO3Doffer","****$NRunning Status$N****","OTE(BO3Doffer.Status.RunningForward)","6"
RCOMMENT,"BO3Program","BO3Doffer","****$NIf the motor does not start when commanded, it has failed to run$N****","OTL(BO3Doffer.Status.FailedToStart)","7"
RCOMMENT,"BO3Program","BO3Doffer","****$NIf a motor continues to run when the run command has been removed,$Nit has failed to stop.$N****$N","OTL(BO3Doffer.Status.FailedToStop)","8"
RCOMMENT,"BO3Program","BO3Doffer","****$NGeneral Faulted Status$N****","OTE(BO3Doffer.Status.Faulted)","9"
RCOMMENT,"BO3Program","BO3Doffer","****$NReset Fault Latches$N****","OTU(BO3Doffer.Status.FailedToStop)","10"
RCOMMENT,"BO3Program","BO3DoorLocks","****$NThe permissive to lock is delayed by the timer.$N****","OTE(BO3DoorLocks.Internal.LockPermissive)","0"
RCOMMENT,"BO3Program","BO3DoorLocks","****$NThe permissive to unlock is delayed by the timer.$N****","OTE(BO3DoorLocks.Internal.UnlockPermissive)","1"
RCOMMENT,"BO3Program","BO3DoorLocks","****$NThe unlock command works if the permissive above is satisfied.$N****","OTE(BO3DoorLocks.Internal.IntermediateUnlock)","2"
RCOMMENT,"BO3Program","BO3DoorLocks","****$NStatus for the HMI$N****","OTE(BO3DoorLocks.Status.Locked)","3"
RCOMMENT,"BO3Program","BO3DoorLocks","****$NStatus for the HMI$N****","OTE(BO3DoorLocks.Status.Unlocked)","4"
RCOMMENT,"BO3Program","BO3DoorLocks","****$NFire the Outputs$N****","OTE(BO3TopAccessHatchReleaseSol)","5"
RCOMMENT,"BO3Program","BO3Dump","****$NPermissive to operate$N****","OTE(BO3Dump.Internal.Permissive)","0"
RCOMMENT,"BO3Program","BO3Dump","****$NSolenoid to Automatic Mode$N****","OTU(BO3Dump.Command.ToAuto)","1"
RCOMMENT,"BO3Program","BO3Dump","****$NSolenoid to Manua Mode$N****","OTU(BO3Dump.Command.ToManual)","2"
RCOMMENT,"BO3Program","BO3Dump","****$NIf the solenoid is not in either mode, put in manual mode.$N****","OTL(BO3Dump.Status.InManual)","3"
RCOMMENT,"BO3Program","BO3Dump","****$NManual Run Control$N****","OTE(BO3Dump.Internal.ManualOpen)","4"
RCOMMENT,"BO3Program","BO3Dump","****$NAutomatic mode controls.$N****","TOF(BO3Dump.Internal.DelayOpenTimer,?,?)","5"
RCOMMENT,"BO3Program","BO3Dump","****$NControl of the solenoid.$N****","OTE(BO3Dump.Status.Open)","6"
RCOMMENT,"BO3Program","BO3Dump","****$NOpen Status$N****","OTE(BO3Dump.Status.Closed)","7"
RCOMMENT,"BO3Program","BO3ExtendedApron","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(BO3ExtendedApron.Internal.Permissive)","0"
RCOMMENT,"BO3Program","BO3ExtendedApron","****$NJog Command$N****","OTE(BO3ExtendedApron.Internal.IntermediateJog)","1"
RCOMMENT,"BO3Program","BO3ExtendedApron","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(BO3ExtendedApron.Internal.DriveReverse)","2"
RCOMMENT,"BO3Program","BO3ExtendedApron","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(BO3ExtendedApron.Internal.MaintModeRun)","3"
RCOMMENT,"BO3Program","BO3ExtendedApron","****$NAutomatic control.  The TON is dalay for start while the TOF is $Nthe delay for stop.$N****","OTE(BO3ExtendedApron.Internal.AutoModeRun)","4"
RCOMMENT,"BO3Program","BO3ExtendedApron","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(BO3ExtendedApron.Internal.ReleaseRamp)","5"
RCOMMENT,"BO3Program","BO3ExtendedApron","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(BO3ExtendedApron.Internal.DecelTime,BO3ExtendedApron.Internal.DecelTime)","6"
RCOMMENT,"BO3Program","BO3ExtendedApron","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(BO3ExtendedApron.Internal.SpeedReference.ScaledOutput,BO3ExtendedApron:O.FreqCommand)","7"
RCOMMENT,"BO3Program","BO3ExtendedApron","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(BO3ExtendedApron:O.Start)","8"
RCOMMENT,"BO3Program","BO3ExtendedApron","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(BO3ExtendedApron:O.Stop)","9"
RCOMMENT,"BO3Program","BO3ExtendedApron","****$NThe reverse command is set above.$N****","OTE(BO3ExtendedApron:O.Reverse)","10"
RCOMMENT,"BO3Program","BO3ExtendedApron","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(BO3ExtendedApron:O.Forward)","11"
RCOMMENT,"BO3Program","BO3ExtendedApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO3ExtendedApron.Internal.ActualSpeedScaler.ScaledOutput,BO3ExtendedApron.Status.ActualSpeed)","12"
RCOMMENT,"BO3Program","BO3ExtendedApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO3ExtendedApron.Internal.LoadScaler.ScaledOutput,BO3ExtendedApron.Status.MotorLoad)","13"
RCOMMENT,"BO3Program","BO3ExtendedApron","****$NDrive Running Status$N****","OTE(BO3ExtendedApron.Status.Running)","14"
RCOMMENT,"BO3Program","BO3ExtendedApron","****$NJogging Forward Status$N****","OTE(BO3ExtendedApron.Status.JoggingFwd)","15"
RCOMMENT,"BO3Program","BO3ExtendedApron","****$NJogging Reverse Status$N****","OTE(BO3ExtendedApron.Status.JoggingRev)","16"
RCOMMENT,"BO3Program","BO3ExtendedApron","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(BO3ExtendedApron.Status.FailedToStart)","17"
RCOMMENT,"BO3Program","BO3ExtendedApron","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(BO3ExtendedApron.Status.FailedToStop)","18"
RCOMMENT,"BO3Program","BO3ExtendedApron","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(BO3ExtendedApron.Status.Faulted)","19"
RCOMMENT,"BO3Program","BO3ExtendedApron","****$NUnlatch the Drive Faulted Status$N****","OTU(BO3ExtendedApron.Status.FailedToStop)","20"
RCOMMENT,"BO3Program","BO3LiftApron","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(BO3LiftApron.Internal.Permissive)","0"
RCOMMENT,"BO3Program","BO3LiftApron","****$NJog Command$N****","OTE(BO3LiftApron.Internal.IntermediateJog)","1"
RCOMMENT,"BO3Program","BO3LiftApron","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(BO3LiftApron.Internal.DriveReverse)","2"
RCOMMENT,"BO3Program","BO3LiftApron","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(BO3LiftApron.Internal.MaintModeRun)","3"
RCOMMENT,"BO3Program","BO3LiftApron","****$NThis timer makes sure the doffer is running and up to speed$Nbefore the lfit apron starts.$N****","TON(BO3.Internal.DofferRunningTimer,?,?)","4"
RCOMMENT,"BO3Program","BO3LiftApron","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(BO3LiftApron.Internal.ReleaseRamp)","5"
RCOMMENT,"BO3Program","BO3LiftApron","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(BO3LiftApron.Internal.DecelTime,BO3LiftApron.Internal.DecelTime)","6"
RCOMMENT,"BO3Program","BO3LiftApron","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(BO3LiftApron.Internal.SpeedReference.ScaledOutput,BO3LiftApron:O.FreqCommand)","7"
RCOMMENT,"BO3Program","BO3LiftApron","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(BO3LiftApron:O.Start)","8"
RCOMMENT,"BO3Program","BO3LiftApron","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(BO3LiftApron:O.Stop)","9"
RCOMMENT,"BO3Program","BO3LiftApron","****$NThe reverse command is set above.$N****","OTE(BO3LiftApron:O.Reverse)","10"
RCOMMENT,"BO3Program","BO3LiftApron","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(BO3LiftApron:O.Forward)","11"
RCOMMENT,"BO3Program","BO3LiftApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO3LiftApron.Internal.ActualSpeedScaler.ScaledOutput,BO3LiftApron.Status.ActualSpeed)","12"
RCOMMENT,"BO3Program","BO3LiftApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO3LiftApron.Internal.LoadScaler.ScaledOutput,BO3LiftApron.Status.MotorLoad)","13"
RCOMMENT,"BO3Program","BO3LiftApron","****$NDrive Running Status$N****","OTE(BO3LiftApron.Status.Running)","14"
RCOMMENT,"BO3Program","BO3LiftApron","****$NJogging Forward Status$N****","OTE(BO3LiftApron.Status.JoggingFwd)","15"
RCOMMENT,"BO3Program","BO3LiftApron","****$NJogging Reverse Status$N****","OTE(BO3LiftApron.Status.JoggingRev)","16"
RCOMMENT,"BO3Program","BO3LiftApron","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(BO3LiftApron.Status.FailedToStart)","17"
RCOMMENT,"BO3Program","BO3LiftApron","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(BO3LiftApron.Status.FailedToStop)","18"
RCOMMENT,"BO3Program","BO3LiftApron","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(BO3LiftApron.Status.Faulted)","19"
RCOMMENT,"BO3Program","BO3LiftApron","****$NUnlatch the Drive Faulted Status$N****","OTU(BO3LiftApron.Status.FailedToStop)","20"
RCOMMENT,"BO3Program","BO3LoadApron","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(BO3LoadApron.Internal.Permissive)","0"
RCOMMENT,"BO3Program","BO3LoadApron","****$NJog Command$N****","OTE(BO3LoadApron.Internal.IntermediateJog)","1"
RCOMMENT,"BO3Program","BO3LoadApron","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(BO3LoadApron.Internal.DriveReverse)","2"
RCOMMENT,"BO3Program","BO3LoadApron","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(BO3LoadApron.Internal.MaintModeRun)","3"
RCOMMENT,"BO3Program","BO3LoadApron","****$NRestart Control$N****","OTE(BO3LoadApron.Internal.IntermediateAutoRun)","4"
RCOMMENT,"BO3Program","BO3LoadApron","****$NControl the Restart Horn$N****","OTE(BO3BaleOpenerRestartHorn)","5"
RCOMMENT,"BO3Program","BO3LoadApron","****$NAutomatic control.  The TON is dalay for start while the TOF is $Nthe delay for stop.$N****","OTE(BO3LoadApron.Internal.AutoModeRun)","6"
RCOMMENT,"BO3Program","BO3LoadApron","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(BO3LoadApron.Internal.ReleaseRamp)","7"
RCOMMENT,"BO3Program","BO3LoadApron","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(BO3LoadApron.Internal.DecelTime,BO3LoadApron.Internal.DecelTime)","8"
RCOMMENT,"BO3Program","BO3LoadApron","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(BO3LoadApron.Internal.SpeedReference.ScaledOutput,BO3LoadApron:O.FreqCommand)","9"
RCOMMENT,"BO3Program","BO3LoadApron","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(BO3LoadApron:O.Start)","10"
RCOMMENT,"BO3Program","BO3LoadApron","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(BO3LoadApron:O.Stop)","11"
RCOMMENT,"BO3Program","BO3LoadApron","****$NThe reverse command is set above.$N****","OTE(BO3LoadApron:O.Reverse)","12"
RCOMMENT,"BO3Program","BO3LoadApron","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(BO3LoadApron:O.Forward)","13"
RCOMMENT,"BO3Program","BO3LoadApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO3LoadApron.Internal.ActualSpeedScaler.ScaledOutput,BO3LoadApron.Status.ActualSpeed)","14"
RCOMMENT,"BO3Program","BO3LoadApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO3LoadApron.Internal.LoadScaler.ScaledOutput,BO3LoadApron.Status.MotorLoad)","15"
RCOMMENT,"BO3Program","BO3LoadApron","****$NDrive Running Status$N****","OTE(BO3LoadApron.Status.Running)","16"
RCOMMENT,"BO3Program","BO3LoadApron","****$NJogging Forward Status$N****","OTE(BO3LoadApron.Status.JoggingFwd)","17"
RCOMMENT,"BO3Program","BO3LoadApron","****$NJogging Reverse Status$N****","OTE(BO3LoadApron.Status.JoggingRev)","18"
RCOMMENT,"BO3Program","BO3LoadApron","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(BO3LoadApron.Status.FailedToStart)","19"
RCOMMENT,"BO3Program","BO3LoadApron","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(BO3LoadApron.Status.FailedToStop)","20"
RCOMMENT,"BO3Program","BO3LoadApron","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(BO3LoadApron.Status.Faulted)","21"
RCOMMENT,"BO3Program","BO3LoadApron","****$NUnlatch the Drive Faulted Status$N****","OTU(BO3LoadApron.Status.FailedToStop)","22"
RCOMMENT,"BO3Program","BO3LoadDoor","****$NPermissive to operate$N****","OTE(BO3LoadDoor.Internal.Permissive)","0"
RCOMMENT,"BO3Program","BO3LoadDoor","****$NSolenoid to Automatic Mode$N****","OTU(BO3LoadDoor.Command.ToAuto)","1"
RCOMMENT,"BO3Program","BO3LoadDoor","****$NSolenoid to Manua Mode$N****","OTU(BO3LoadDoor.Command.ToManual)","2"
RCOMMENT,"BO3Program","BO3LoadDoor","****$NIf the solenoid is not in either mode, put in manual mode.$N****","OTL(BO3LoadDoor.Status.InManual)","3"
RCOMMENT,"BO3Program","BO3LoadDoor","****$NManual Run Control$N****","OTE(BO3LoadDoor.Internal.ManualClose)","4"
RCOMMENT,"BO3Program","BO3LoadDoor","****$NManual Run Control$N****","OTE(BO3LoadDoor.Internal.ManualOpen)","5"
RCOMMENT,"BO3Program","BO3LoadDoor","****$NControl of the solenoid.$N****","OTE(BO3LoadDoorCloseSol)","6"
RCOMMENT,"BO3Program","BO3LoadDoor","****$NControl of the solenoid.$N****","OTE(BO3LoadDoorOpenSol)","7"
RCOMMENT,"BO3Program","BO3LoadDoor","****$NOpen Status$N****","OTE(BO3LoadDoor.Status.Open)","8"
RCOMMENT,"BO3Program","BO3LoadDoor","****$NControl for the gate open pilot light.$N****","OTE(BO3LoadDoorClosedPL)","9"
RCOMMENT,"BO3Program","BO3LoadDoor","****$NOpen beacon control$N****","OTE(BO3LoadDoorOpenBeacon)","11"
RCOMMENT,"BO3Program","BO3LoadDoor","****$NThe pushbutton will unlock the gate above the load door if$Nthe conditions are met.$N****","OTE(BO3LoadGateReleaseSol)","12"
RCOMMENT,"BO3Program","BO3ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO3Control,0)","0"
RCOMMENT,"BO3Program","BO3ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO3Breaker,0)","1"
RCOMMENT,"BO3Program","BO3ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO3Damper,0)","2"
RCOMMENT,"BO3Program","BO3ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO3Doffer,0)","3"
RCOMMENT,"BO3Program","BO3ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO3DoorLocks,0)","4"
RCOMMENT,"BO3Program","BO3ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO3Dump,0)","5"
RCOMMENT,"BO3Program","BO3ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO3ExtendedApron,0)","6"
RCOMMENT,"BO3Program","BO3ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO3LiftApron,0)","7"
RCOMMENT,"BO3Program","BO3ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO3LoadApron,0)","8"
RCOMMENT,"BO3Program","BO3ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO3LoadDoor,0)","9"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"BO4Program","BO4Breaker","****$NPermissive to Operate$N****","OTE(BO4Breaker.Internal.Permissive)","0"
RCOMMENT,"BO4Program","BO4Breaker","****$NManual Run Control$N****","OTE(BO4Breaker.Internal.IntermediateRunForward)","1"
RCOMMENT,"BO4Program","BO4Breaker","****$NManual Jog Control$N****","OTE(BO4Breaker.Internal.IntermediateJogForward)","2"
RCOMMENT,"BO4Program","BO4Breaker","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(BO4Breaker.Internal.AutoOffDelayTimer,?,?)","3"
RCOMMENT,"BO4Program","BO4Breaker","****$NMotor Starter Control$N****","OTE(BO4BreakerCont)","4"
RCOMMENT,"BO4Program","BO4Breaker","****$NRunning Status$N****","OTE(BO4Breaker.Status.RunningForward)","5"
RCOMMENT,"BO4Program","BO4Breaker","****$NIf the motor does not start when commanded, it has failed to run$N****","OTL(BO4Breaker.Status.FailedToStart)","6"
RCOMMENT,"BO4Program","BO4Breaker","****$NIf a motor continues to run when the run command has been removed,$Nit has failed to stop.$N****$N","OTL(BO4Breaker.Status.FailedToStop)","7"
RCOMMENT,"BO4Program","BO4Breaker","****$NGeneral Faulted Status$N****","OTE(BO4Breaker.Status.Faulted)","8"
RCOMMENT,"BO4Program","BO4Breaker","****$NReset Fault Latches$N****","OTU(BO4Breaker.Status.FailedToStop)","9"
RCOMMENT,"BO4Program","BO4Control","****$NPermissive to Operate Manually$N****","OTE(BO4.Internal.Permissive)","0"
RCOMMENT,"BO4Program","BO4Control","****$NEnable the Hopper for Operation$N****","OTU(BO4.Command.Enable)","1"
RCOMMENT,"BO4Program","BO4Control","****$NDisable the Hopper$N****","OTU(BO4.Command.Disable)","2"
RCOMMENT,"BO4Program","BO4Control","****$NDisable the hopper if it is neither enabled or disabled.$N****","OTL(BO4.Status.Disabled)","3"
RCOMMENT,"BO4Program","BO4Control","****$NIf the blend line is not running or the hopper is not enabled, enable manual controls.$N****","OTE(BO4.Internal.EnableManualControls)","4"
RCOMMENT,"BO4Program","BO4Control","****$NCheck the setpoint against limits$N****","SUB(BO4.Command.WeightSetpoint,BO4.Command.AnticipationWeight,BO4.Internal.StopWeight)","5"
RCOMMENT,"BO4Program","BO4Control","****$NScale the analog input to determine weight.$N****","MOV(BO4.Internal.WeightScaler.ScaledOutput,BO4.Status.CurrentWeight)","6"
RCOMMENT,"BO4Program","BO4Control","****$NWhen the blend line is in weigh mode, the lift apron slows when the weight gets$Nabove the slow down ratio.$N****","OTE(BO4.Status.SlowDownActive)","7"
RCOMMENT,"BO4Program","BO4Control","****$NWhen the blend line is in weigh mode the lift apron stops$Nand the door closes when the pan reaches setpoint.$N****","OTL(BO4.Status.WeightSetpointReached)","8"
RCOMMENT,"BO4Program","BO4Control","****$NSet up the values for the upper and lower weights that will cause an alarm$N(OUT OF TOLERANCE VALUES)$N****","SUB(BO4.Command.WeightSetpoint,BO4.Internal.WeightAlarmValue,BO4.Status.AlarmWeightLowerWindow)","9"
RCOMMENT,"BO4Program","BO4Control","****$NWhen the settling timer is done, shift the array numbers down and move the latest$Nweight into array 9.  Array 9 will be the latest value. 8 will be previous then 7, etc.$N****","OTL(BO4.Status.LowWeightAlarm)","10"
RCOMMENT,"BO4Program","BO4Control","****$NReset the setpoint reached bit.$N****","OTU(BO4.Status.WeightSetpointReached)","11"
RCOMMENT,"BO4Program","BO4Control","****$NThe photoeye should control the extended apron.  If the lift apron is running for too long$Nwithout anything blocking the eye, there is a problem.  Perhaps the hopper is empty.$N****","OTE(BO4.Internal.HopperPETooLong)","12"
RCOMMENT,"BO4Program","BO4Control","****$NHopper filling status.$N****","OTE(BO4.Status.Filling)","13"
RCOMMENT,"BO4Program","BO4Control","****$NIf the weight is not reached in a certain amount of time...alarm.$N****","TON(BO4FillTooLongTmr,?,?)","14"
RCOMMENT,"BO4Program","BO4Control","****$NGeneral alarm for HMI display.$N****","OTE(BO4.Status.WeightAlarm)","15"
RCOMMENT,"BO4Program","BO4Control","****$NReset the alarm latches.$N****","OTU(BO4.Status.LowWeightAlarm)","16"
RCOMMENT,"BO4Program","BO4Control","****$NThe RunLiftAprons bit comes from the blend control routine.$NAfter the appropriate drives are running and the call for fiber is on, this$Nbit comes on.  If the hopper is enabled, run the lift apron.$N****","OTE(BO4.Internal.RunLiftApron)","17"
RCOMMENT,"BO4Program","BO4Control","****$NThe restart pushbutton needs to reset the safety zone and the drive before restarting the system.$N****","OTE(BO4RestartSystem)","18"
RCOMMENT,"BO4Program","BO4Damper","****$NPermissive to operate$N****","OTE(BO4Damper.Internal.Permissive)","0"
RCOMMENT,"BO4Program","BO4Damper","****$NSolenoid to Automatic Mode$N****","OTU(BO4Damper.Command.ToAuto)","1"
RCOMMENT,"BO4Program","BO4Damper","****$NSolenoid to Manua Mode$N****","OTU(BO4Damper.Command.ToManual)","2"
RCOMMENT,"BO4Program","BO4Damper","****$NIf the solenoid is not in either mode, put in manual mode.$N****","OTL(BO4Damper.Status.InManual)","3"
RCOMMENT,"BO4Program","BO4Damper","****$NManual Run Control$N****","OTE(BO4Damper.Internal.ManualOpen)","4"
RCOMMENT,"BO4Program","BO4Damper","****$NAutomatic mode controls.$N****","TOF(BO4Damper.Internal.DelayCloseTimer,?,?)","5"
RCOMMENT,"BO4Program","BO4Damper","****$NControl of the solenoid.$N****","OTE(BO4Damper.Internal.IntermediateOpen)","6"
RCOMMENT,"BO4Program","BO4Damper","****$NIf not open command, then close command.$N****","OTE(BO4WeighPanDamperCloseSol)","7"
RCOMMENT,"BO4Program","BO4Damper","****$NOpen Status$N****","OTE(BO4Damper.Status.Open)","8"
RCOMMENT,"BO4Program","BO4Damper","****$NClosed Status$N****","OTE(BO4Damper.Status.Closed)","9"
RCOMMENT,"BO4Program","BO4Doffer","****$NPermissive to Operate$N****","OTE(BO4Doffer.Internal.Permissive)","0"
RCOMMENT,"BO4Program","BO4Doffer","****$NManual Run Control$N****","OTE(BO4Doffer.Internal.IntermediateRunForward)","1"
RCOMMENT,"BO4Program","BO4Doffer","****$NManual Jog Control$N****","OTE(BO4Doffer.Internal.IntermediateJogForward)","2"
RCOMMENT,"BO4Program","BO4Doffer","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(BO4Doffer.Internal.AutoOffDelayTimer,?,?)","3"
RCOMMENT,"BO4Program","BO4Doffer","****$NIf the permissive is lost, reset the TOF for immediate stop.$N****","RES(BO4Doffer.Internal.AutoOffDelayTimer)","4"
RCOMMENT,"BO4Program","BO4Doffer","****$NMotor Starter Control$N****","OTE(BO4DofferCont)","5"
RCOMMENT,"BO4Program","BO4Doffer","****$NRunning Status$N****","OTE(BO4Doffer.Status.RunningForward)","6"
RCOMMENT,"BO4Program","BO4Doffer","****$NIf the motor does not start when commanded, it has failed to run$N****","OTL(BO4Doffer.Status.FailedToStart)","7"
RCOMMENT,"BO4Program","BO4Doffer","****$NIf a motor continues to run when the run command has been removed,$Nit has failed to stop.$N****$N","OTL(BO4Doffer.Status.FailedToStop)","8"
RCOMMENT,"BO4Program","BO4Doffer","****$NGeneral Faulted Status$N****","OTE(BO4Doffer.Status.Faulted)","9"
RCOMMENT,"BO4Program","BO4Doffer","****$NReset Fault Latches$N****","OTU(BO4Doffer.Status.FailedToStop)","10"
RCOMMENT,"BO4Program","BO4DoorLocks","****$NThe permissive to lock is delayed by the timer.$N****","OTE(BO4DoorLocks.Internal.LockPermissive)","0"
RCOMMENT,"BO4Program","BO4DoorLocks","****$NThe permissive to unlock is delayed by the timer.$N****","OTE(BO4DoorLocks.Internal.UnlockPermissive)","1"
RCOMMENT,"BO4Program","BO4DoorLocks","****$NThe unlock command works if the permissive above is satisfied.$N****","OTE(BO4DoorLocks.Internal.IntermediateUnlock)","2"
RCOMMENT,"BO4Program","BO4DoorLocks","****$NStatus for the HMI$N****","OTE(BO4DoorLocks.Status.Locked)","3"
RCOMMENT,"BO4Program","BO4DoorLocks","****$NStatus for the HMI$N****","OTE(BO4DoorLocks.Status.Unlocked)","4"
RCOMMENT,"BO4Program","BO4DoorLocks","****$NFire the Outputs$N****","OTE(BO4TopAccessHatchReleaseSol)","5"
RCOMMENT,"BO4Program","BO4Dump","****$NPermissive to operate$N****","OTE(BO4Dump.Internal.Permissive)","0"
RCOMMENT,"BO4Program","BO4Dump","****$NSolenoid to Automatic Mode$N****","OTU(BO4Dump.Command.ToAuto)","1"
RCOMMENT,"BO4Program","BO4Dump","****$NSolenoid to Manua Mode$N****","OTU(BO4Dump.Command.ToManual)","2"
RCOMMENT,"BO4Program","BO4Dump","****$NIf the solenoid is not in either mode, put in manual mode.$N****","OTL(BO4Dump.Status.InManual)","3"
RCOMMENT,"BO4Program","BO4Dump","****$NManual Run Control$N****","OTE(BO4Dump.Internal.ManualOpen)","4"
RCOMMENT,"BO4Program","BO4Dump","****$NAutomatic mode controls.$N****","TOF(BO4Dump.Internal.DelayOpenTimer,?,?)","5"
RCOMMENT,"BO4Program","BO4Dump","****$NControl of the solenoid.$N****","OTE(BO4Dump.Status.Open)","6"
RCOMMENT,"BO4Program","BO4Dump","****$NOpen Status$N****","OTE(BO4Dump.Status.Closed)","7"
RCOMMENT,"BO4Program","BO4ExtendedApron","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(BO4ExtendedApron.Internal.Permissive)","0"
RCOMMENT,"BO4Program","BO4ExtendedApron","****$NJog Command$N****","OTE(BO4ExtendedApron.Internal.IntermediateJog)","1"
RCOMMENT,"BO4Program","BO4ExtendedApron","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(BO4ExtendedApron.Internal.DriveReverse)","2"
RCOMMENT,"BO4Program","BO4ExtendedApron","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(BO4ExtendedApron.Internal.MaintModeRun)","3"
RCOMMENT,"BO4Program","BO4ExtendedApron","****$NAutomatic control.  The TON is dalay for start while the TOF is $Nthe delay for stop.$N****","OTE(BO4ExtendedApron.Internal.AutoModeRun)","4"
RCOMMENT,"BO4Program","BO4ExtendedApron","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(BO4ExtendedApron.Internal.ReleaseRamp)","5"
RCOMMENT,"BO4Program","BO4ExtendedApron","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(BO4ExtendedApron.Internal.DecelTime,BO4ExtendedApron.Internal.DecelTime)","6"
RCOMMENT,"BO4Program","BO4ExtendedApron","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(BO4ExtendedApron.Internal.SpeedReference.ScaledOutput,BO4ExtendedApron:O.FreqCommand)","7"
RCOMMENT,"BO4Program","BO4ExtendedApron","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(BO4ExtendedApron:O.Start)","8"
RCOMMENT,"BO4Program","BO4ExtendedApron","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(BO4ExtendedApron:O.Stop)","9"
RCOMMENT,"BO4Program","BO4ExtendedApron","****$NThe reverse command is set above.$N****","OTE(BO4ExtendedApron:O.Reverse)","10"
RCOMMENT,"BO4Program","BO4ExtendedApron","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(BO4ExtendedApron:O.Forward)","11"
RCOMMENT,"BO4Program","BO4ExtendedApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO4ExtendedApron.Internal.ActualSpeedScaler.ScaledOutput,BO4ExtendedApron.Status.ActualSpeed)","12"
RCOMMENT,"BO4Program","BO4ExtendedApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO4ExtendedApron.Internal.LoadScaler.ScaledOutput,BO4ExtendedApron.Status.MotorLoad)","13"
RCOMMENT,"BO4Program","BO4ExtendedApron","****$NDrive Running Status$N****","OTE(BO4ExtendedApron.Status.Running)","14"
RCOMMENT,"BO4Program","BO4ExtendedApron","****$NJogging Forward Status$N****","OTE(BO4ExtendedApron.Status.JoggingFwd)","15"
RCOMMENT,"BO4Program","BO4ExtendedApron","****$NJogging Reverse Status$N****","OTE(BO4ExtendedApron.Status.JoggingRev)","16"
RCOMMENT,"BO4Program","BO4ExtendedApron","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(BO4ExtendedApron.Status.FailedToStart)","17"
RCOMMENT,"BO4Program","BO4ExtendedApron","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(BO4ExtendedApron.Status.FailedToStop)","18"
RCOMMENT,"BO4Program","BO4ExtendedApron","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(BO4ExtendedApron.Status.Faulted)","19"
RCOMMENT,"BO4Program","BO4ExtendedApron","****$NUnlatch the Drive Faulted Status$N****","OTU(BO4ExtendedApron.Status.FailedToStop)","20"
RCOMMENT,"BO4Program","BO4LiftApron","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(BO4LiftApron.Internal.Permissive)","0"
RCOMMENT,"BO4Program","BO4LiftApron","****$NJog Command$N****","OTE(BO4LiftApron.Internal.IntermediateJog)","1"
RCOMMENT,"BO4Program","BO4LiftApron","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(BO4LiftApron.Internal.DriveReverse)","2"
RCOMMENT,"BO4Program","BO4LiftApron","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(BO4LiftApron.Internal.MaintModeRun)","3"
RCOMMENT,"BO4Program","BO4LiftApron","****$NThis timer makes sure the doffer is running and up to speed$Nbefore the lfit apron starts.$N****","TON(BO4.Internal.DofferRunningTimer,?,?)","4"
RCOMMENT,"BO4Program","BO4LiftApron","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(BO4LiftApron.Internal.ReleaseRamp)","5"
RCOMMENT,"BO4Program","BO4LiftApron","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(BO4LiftApron.Internal.DecelTime,BO4LiftApron.Internal.DecelTime)","6"
RCOMMENT,"BO4Program","BO4LiftApron","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(BO4LiftApron.Internal.SpeedReference.ScaledOutput,BO4LiftApron:O.FreqCommand)","7"
RCOMMENT,"BO4Program","BO4LiftApron","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(BO4LiftApron:O.Start)","8"
RCOMMENT,"BO4Program","BO4LiftApron","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(BO4LiftApron:O.Stop)","9"
RCOMMENT,"BO4Program","BO4LiftApron","****$NThe reverse command is set above.$N****","OTE(BO4LiftApron:O.Reverse)","10"
RCOMMENT,"BO4Program","BO4LiftApron","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(BO4LiftApron:O.Forward)","11"
RCOMMENT,"BO4Program","BO4LiftApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO4LiftApron.Internal.ActualSpeedScaler.ScaledOutput,BO4LiftApron.Status.ActualSpeed)","12"
RCOMMENT,"BO4Program","BO4LiftApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO4LiftApron.Internal.LoadScaler.ScaledOutput,BO4LiftApron.Status.MotorLoad)","13"
RCOMMENT,"BO4Program","BO4LiftApron","****$NDrive Running Status$N****","OTE(BO4LiftApron.Status.Running)","14"
RCOMMENT,"BO4Program","BO4LiftApron","****$NJogging Forward Status$N****","OTE(BO4LiftApron.Status.JoggingFwd)","15"
RCOMMENT,"BO4Program","BO4LiftApron","****$NJogging Reverse Status$N****","OTE(BO4LiftApron.Status.JoggingRev)","16"
RCOMMENT,"BO4Program","BO4LiftApron","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(BO4LiftApron.Status.FailedToStart)","17"
RCOMMENT,"BO4Program","BO4LiftApron","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(BO4LiftApron.Status.FailedToStop)","18"
RCOMMENT,"BO4Program","BO4LiftApron","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(BO4LiftApron.Status.Faulted)","19"
RCOMMENT,"BO4Program","BO4LiftApron","****$NUnlatch the Drive Faulted Status$N****","OTU(BO4LiftApron.Status.FailedToStop)","20"
RCOMMENT,"BO4Program","BO4LoadApron","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(BO4LoadApron.Internal.Permissive)","0"
RCOMMENT,"BO4Program","BO4LoadApron","****$NJog Command$N****","OTE(BO4LoadApron.Internal.IntermediateJog)","1"
RCOMMENT,"BO4Program","BO4LoadApron","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(BO4LoadApron.Internal.DriveReverse)","2"
RCOMMENT,"BO4Program","BO4LoadApron","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(BO4LoadApron.Internal.MaintModeRun)","3"
RCOMMENT,"BO4Program","BO4LoadApron","****$NRestart Control$N****","OTE(BO4LoadApron.Internal.IntermediateAutoRun)","4"
RCOMMENT,"BO4Program","BO4LoadApron","****$NControl the Restart Horn$N****","OTE(BO4BaleOpenerRestartHorn)","5"
RCOMMENT,"BO4Program","BO4LoadApron","****$NAutomatic control.  The TON is dalay for start while the TOF is $Nthe delay for stop.$N****","OTE(BO4LoadApron.Internal.AutoModeRun)","6"
RCOMMENT,"BO4Program","BO4LoadApron","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(BO4LoadApron.Internal.ReleaseRamp)","7"
RCOMMENT,"BO4Program","BO4LoadApron","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(BO4LoadApron.Internal.DecelTime,BO4LoadApron.Internal.DecelTime)","8"
RCOMMENT,"BO4Program","BO4LoadApron","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(BO4LoadApron.Internal.SpeedReference.ScaledOutput,BO4LoadApron:O.FreqCommand)","9"
RCOMMENT,"BO4Program","BO4LoadApron","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(BO4LoadApron:O.Start)","10"
RCOMMENT,"BO4Program","BO4LoadApron","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(BO4LoadApron:O.Stop)","11"
RCOMMENT,"BO4Program","BO4LoadApron","****$NThe reverse command is set above.$N****","OTE(BO4LoadApron:O.Reverse)","12"
RCOMMENT,"BO4Program","BO4LoadApron","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(BO4LoadApron:O.Forward)","13"
RCOMMENT,"BO4Program","BO4LoadApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO4LoadApron.Internal.ActualSpeedScaler.ScaledOutput,BO4LoadApron.Status.ActualSpeed)","14"
RCOMMENT,"BO4Program","BO4LoadApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO4LoadApron.Internal.LoadScaler.ScaledOutput,BO4LoadApron.Status.MotorLoad)","15"
RCOMMENT,"BO4Program","BO4LoadApron","****$NDrive Running Status$N****","OTE(BO4LoadApron.Status.Running)","16"
RCOMMENT,"BO4Program","BO4LoadApron","****$NJogging Forward Status$N****","OTE(BO4LoadApron.Status.JoggingFwd)","17"
RCOMMENT,"BO4Program","BO4LoadApron","****$NJogging Reverse Status$N****","OTE(BO4LoadApron.Status.JoggingRev)","18"
RCOMMENT,"BO4Program","BO4LoadApron","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(BO4LoadApron.Status.FailedToStart)","19"
RCOMMENT,"BO4Program","BO4LoadApron","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(BO4LoadApron.Status.FailedToStop)","20"
RCOMMENT,"BO4Program","BO4LoadApron","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(BO4LoadApron.Status.Faulted)","21"
RCOMMENT,"BO4Program","BO4LoadApron","****$NUnlatch the Drive Faulted Status$N****","OTU(BO4LoadApron.Status.FailedToStop)","22"
RCOMMENT,"BO4Program","BO4LoadDoor","****$NPermissive to operate$N****","OTE(BO4LoadDoor.Internal.Permissive)","0"
RCOMMENT,"BO4Program","BO4LoadDoor","****$NSolenoid to Automatic Mode$N****","OTU(BO4LoadDoor.Command.ToAuto)","1"
RCOMMENT,"BO4Program","BO4LoadDoor","****$NSolenoid to Manua Mode$N****","OTU(BO4LoadDoor.Command.ToManual)","2"
RCOMMENT,"BO4Program","BO4LoadDoor","****$NIf the solenoid is not in either mode, put in manual mode.$N****","OTL(BO4LoadDoor.Status.InManual)","3"
RCOMMENT,"BO4Program","BO4LoadDoor","****$NManual Run Control$N****","OTE(BO4LoadDoor.Internal.ManualClose)","4"
RCOMMENT,"BO4Program","BO4LoadDoor","****$NManual Run Control$N****","OTE(BO4LoadDoor.Internal.ManualOpen)","5"
RCOMMENT,"BO4Program","BO4LoadDoor","****$NControl of the solenoid.$N****","OTE(BO4LoadDoorCloseSol)","6"
RCOMMENT,"BO4Program","BO4LoadDoor","****$NControl of the solenoid.$N****","OTE(BO4LoadDoorOpenSol)","7"
RCOMMENT,"BO4Program","BO4LoadDoor","****$NOpen Status$N****","OTE(BO4LoadDoor.Status.Open)","8"
RCOMMENT,"BO4Program","BO4LoadDoor","****$NControl for the gate open pilot light.$N****","OTE(BO4LoadDoorClosedPL)","9"
RCOMMENT,"BO4Program","BO4LoadDoor","****$NOpen beacon control$N****","OTE(BO4LoadDoorOpenBeacon)","11"
RCOMMENT,"BO4Program","BO4LoadDoor","****$NThe pushbutton will unlock the gate above the load door if$Nthe conditions are met.$N****","OTE(BO4GateDoorReleaseSol)","12"
RCOMMENT,"BO4Program","BO4ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO4Control,0)","0"
RCOMMENT,"BO4Program","BO4ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO4Breaker,0)","1"
RCOMMENT,"BO4Program","BO4ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO4Damper,0)","2"
RCOMMENT,"BO4Program","BO4ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO4Doffer,0)","3"
RCOMMENT,"BO4Program","BO4ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO4DoorLocks,0)","4"
RCOMMENT,"BO4Program","BO4ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO4Dump,0)","5"
RCOMMENT,"BO4Program","BO4ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO4ExtendedApron,0)","6"
RCOMMENT,"BO4Program","BO4ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO4LiftApron,0)","7"
RCOMMENT,"BO4Program","BO4ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO4LoadApron,0)","8"
RCOMMENT,"BO4Program","BO4ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO4LoadDoor,0)","9"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"BO5Program","BO5Breaker","****$NPermissive to Operate$N****","OTE(BO5Breaker.Internal.Permissive)","0"
RCOMMENT,"BO5Program","BO5Breaker","****$NManual Run Control$N****","OTE(BO5Breaker.Internal.IntermediateRunForward)","1"
RCOMMENT,"BO5Program","BO5Breaker","****$NManual Jog Control$N****","OTE(BO5Breaker.Internal.IntermediateJogForward)","2"
RCOMMENT,"BO5Program","BO5Breaker","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(BO5Breaker.Internal.AutoOffDelayTimer,?,?)","3"
RCOMMENT,"BO5Program","BO5Breaker","****$NMotor Starter Control$N****","OTE(BO5BreakerCont)","4"
RCOMMENT,"BO5Program","BO5Breaker","****$NRunning Status$N****","OTE(BO5Breaker.Status.RunningForward)","5"
RCOMMENT,"BO5Program","BO5Breaker","****$NIf the motor does not start when commanded, it has failed to run$N****","OTL(BO5Breaker.Status.FailedToStart)","6"
RCOMMENT,"BO5Program","BO5Breaker","****$NIf a motor continues to run when the run command has been removed,$Nit has failed to stop.$N****$N","OTL(BO5Breaker.Status.FailedToStop)","7"
RCOMMENT,"BO5Program","BO5Breaker","****$NGeneral Faulted Status$N****","OTE(BO5Breaker.Status.Faulted)","8"
RCOMMENT,"BO5Program","BO5Breaker","****$NReset Fault Latches$N****","OTU(BO5Breaker.Status.FailedToStop)","9"
RCOMMENT,"BO5Program","BO5Control","****$NPermissive to Operate Manually$N****","OTE(BO5.Internal.Permissive)","0"
RCOMMENT,"BO5Program","BO5Control","****$NEnable the Hopper for Operation$N****","OTU(BO5.Command.Enable)","1"
RCOMMENT,"BO5Program","BO5Control","****$NDisable the Hopper$N****","OTU(BO5.Command.Disable)","2"
RCOMMENT,"BO5Program","BO5Control","****$NDisable the hopper if it is neither enabled or disabled.$N****","OTL(BO5.Status.Disabled)","3"
RCOMMENT,"BO5Program","BO5Control","****$NIf the blend line is not running or the hopper is not enabled, enable manual controls.$N****","OTE(BO5.Internal.EnableManualControls)","4"
RCOMMENT,"BO5Program","BO5Control","****$NCheck the setpoint against limits$N****","SUB(BO5.Command.WeightSetpoint,BO5.Command.AnticipationWeight,BO5.Internal.StopWeight)","5"
RCOMMENT,"BO5Program","BO5Control","****$NScale the analog input to determine weight.$N****","MOV(BO5.Internal.WeightScaler.ScaledOutput,BO5.Status.CurrentWeight)","6"
RCOMMENT,"BO5Program","BO5Control","****$NWhen the blend line is in weigh mode, the lift apron slows when the weight gets$Nabove the slow down ratio.$N****","OTE(BO5.Status.SlowDownActive)","7"
RCOMMENT,"BO5Program","BO5Control","****$NWhen the blend line is in weigh mode the lift apron stops$Nand the door closes when the pan reaches setpoint.$N****","OTL(BO5.Status.WeightSetpointReached)","8"
RCOMMENT,"BO5Program","BO5Control","****$NSet up the values for the upper and lower weights that will cause an alarm$N(OUT OF TOLERANCE VALUES)$N****","SUB(BO5.Command.WeightSetpoint,BO5.Internal.WeightAlarmValue,BO5.Status.AlarmWeightLowerWindow)","9"
RCOMMENT,"BO5Program","BO5Control","****$NWhen the settling timer is done, shift the array numbers down and move the latest$Nweight into array 9.  Array 9 will be the latest value. 8 will be previous then 7, etc.$N****","OTL(BO5.Status.LowWeightAlarm)","10"
RCOMMENT,"BO5Program","BO5Control","****$NReset the setpoint reached bit.$N****","OTU(BO5.Status.WeightSetpointReached)","11"
RCOMMENT,"BO5Program","BO5Control","****$NThe photoeye should control the extended apron.  If the lift apron is running for too long$Nwithout anything blocking the eye, there is a problem.  Perhaps the hopper is empty.$N****","OTE(BO5.Internal.HopperPETooLong)","12"
RCOMMENT,"BO5Program","BO5Control","****$NHopper filling status.$N****","OTE(BO5.Status.Filling)","13"
RCOMMENT,"BO5Program","BO5Control","****$NIf the weight is not reached in a certain amount of time...alarm.$N****","TON(BO5FillTooLongTmr,?,?)","14"
RCOMMENT,"BO5Program","BO5Control","****$NGeneral alarm for HMI display.$N****","OTE(BO5.Status.WeightAlarm)","15"
RCOMMENT,"BO5Program","BO5Control","****$NReset the alarm latches.$N****","OTU(BO5.Status.LowWeightAlarm)","16"
RCOMMENT,"BO5Program","BO5Control","****$NThe RunLiftAprons bit comes from the blend control routine.$NAfter the appropriate drives are running and the call for fiber is on, this$Nbit comes on.  If the hopper is enabled, run the lift apron.$N****","OTE(BO5.Internal.RunLiftApron)","17"
RCOMMENT,"BO5Program","BO5Control","****$NThe restart pushbutton needs to reset the safety zone and the drive before restarting the system.$N****","OTE(BO5RestartSystem)","18"
RCOMMENT,"BO5Program","BO5Damper","****$NPermissive to operate$N****","OTE(BO5Damper.Internal.Permissive)","0"
RCOMMENT,"BO5Program","BO5Damper","****$NSolenoid to Automatic Mode$N****","OTU(BO5Damper.Command.ToAuto)","1"
RCOMMENT,"BO5Program","BO5Damper","****$NSolenoid to Manua Mode$N****","OTU(BO5Damper.Command.ToManual)","2"
RCOMMENT,"BO5Program","BO5Damper","****$NIf the solenoid is not in either mode, put in manual mode.$N****","OTL(BO5Damper.Status.InManual)","3"
RCOMMENT,"BO5Program","BO5Damper","****$NManual Run Control$N****","OTE(BO5Damper.Internal.ManualOpen)","4"
RCOMMENT,"BO5Program","BO5Damper","****$NAutomatic mode controls.$N****","TOF(BO5Damper.Internal.DelayCloseTimer,?,?)","5"
RCOMMENT,"BO5Program","BO5Damper","****$NControl of the solenoid.$N****","OTE(BO5Damper.Internal.IntermediateOpen)","6"
RCOMMENT,"BO5Program","BO5Damper","****$NIf not open command, then close command.$N****","OTE(BO5WeighPanDamperCloseSol)","7"
RCOMMENT,"BO5Program","BO5Damper","****$NOpen Status$N****","OTE(BO5Damper.Status.Open)","8"
RCOMMENT,"BO5Program","BO5Damper","****$NClosed Status$N****","OTE(BO5Damper.Status.Closed)","9"
RCOMMENT,"BO5Program","BO5Doffer","****$NPermissive to Operate$N****","OTE(BO5Doffer.Internal.Permissive)","0"
RCOMMENT,"BO5Program","BO5Doffer","****$NManual Run Control$N****","OTE(BO5Doffer.Internal.IntermediateRunForward)","1"
RCOMMENT,"BO5Program","BO5Doffer","****$NManual Jog Control$N****","OTE(BO5Doffer.Internal.IntermediateJogForward)","2"
RCOMMENT,"BO5Program","BO5Doffer","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(BO5Doffer.Internal.AutoOffDelayTimer,?,?)","3"
RCOMMENT,"BO5Program","BO5Doffer","****$NIf the permissive is lost, reset the TOF for immediate stop.$N****","RES(BO5Doffer.Internal.AutoOffDelayTimer)","4"
RCOMMENT,"BO5Program","BO5Doffer","****$NMotor Starter Control$N****","OTE(BO5DofferCont)","5"
RCOMMENT,"BO5Program","BO5Doffer","****$NRunning Status$N****","OTE(BO5Doffer.Status.RunningForward)","6"
RCOMMENT,"BO5Program","BO5Doffer","****$NIf the motor does not start when commanded, it has failed to run$N****","OTL(BO5Doffer.Status.FailedToStart)","7"
RCOMMENT,"BO5Program","BO5Doffer","****$NIf a motor continues to run when the run command has been removed,$Nit has failed to stop.$N****$N","OTL(BO5Doffer.Status.FailedToStop)","8"
RCOMMENT,"BO5Program","BO5Doffer","****$NGeneral Faulted Status$N****","OTE(BO5Doffer.Status.Faulted)","9"
RCOMMENT,"BO5Program","BO5Doffer","****$NReset Fault Latches$N****","OTU(BO5Doffer.Status.FailedToStop)","10"
RCOMMENT,"BO5Program","BO5DoorLocks","****$NThe permissive to lock is delayed by the timer.$N****","OTE(BO5DoorLocks.Internal.LockPermissive)","0"
RCOMMENT,"BO5Program","BO5DoorLocks","****$NThe permissive to unlock is delayed by the timer.$N****","OTE(BO5DoorLocks.Internal.UnlockPermissive)","1"
RCOMMENT,"BO5Program","BO5DoorLocks","****$NThe unlock command works if the permissive above is satisfied.$N****","OTE(BO5DoorLocks.Internal.IntermediateUnlock)","2"
RCOMMENT,"BO5Program","BO5DoorLocks","****$NStatus for the HMI$N****","OTE(BO5DoorLocks.Status.Locked)","3"
RCOMMENT,"BO5Program","BO5DoorLocks","****$NStatus for the HMI$N****","OTE(BO5DoorLocks.Status.Unlocked)","4"
RCOMMENT,"BO5Program","BO5DoorLocks","****$NFire the Outputs$N****","OTE(BO5TopAccessHatchReleaseSol)","5"
RCOMMENT,"BO5Program","BO5Dump","****$NPermissive to operate$N****","OTE(BO5Dump.Internal.Permissive)","0"
RCOMMENT,"BO5Program","BO5Dump","****$NSolenoid to Automatic Mode$N****","OTU(BO5Dump.Command.ToAuto)","1"
RCOMMENT,"BO5Program","BO5Dump","****$NSolenoid to Manua Mode$N****","OTU(BO5Dump.Command.ToManual)","2"
RCOMMENT,"BO5Program","BO5Dump","****$NIf the solenoid is not in either mode, put in manual mode.$N****","OTL(BO5Dump.Status.InManual)","3"
RCOMMENT,"BO5Program","BO5Dump","****$NManual Run Control$N****","OTE(BO5Dump.Internal.ManualOpen)","4"
RCOMMENT,"BO5Program","BO5Dump","****$NAutomatic mode controls.$N****","TOF(BO5Dump.Internal.DelayOpenTimer,?,?)","5"
RCOMMENT,"BO5Program","BO5Dump","****$NControl of the solenoid.$N****","OTE(BO5Dump.Status.Open)","6"
RCOMMENT,"BO5Program","BO5Dump","****$NOpen Status$N****","OTE(BO5Dump.Status.Closed)","7"
RCOMMENT,"BO5Program","BO5ExtendedApron","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(BO5ExtendedApron.Internal.Permissive)","0"
RCOMMENT,"BO5Program","BO5ExtendedApron","****$NJog Command$N****","OTE(BO5ExtendedApron.Internal.IntermediateJog)","1"
RCOMMENT,"BO5Program","BO5ExtendedApron","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(BO5ExtendedApron.Internal.DriveReverse)","2"
RCOMMENT,"BO5Program","BO5ExtendedApron","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(BO5ExtendedApron.Internal.MaintModeRun)","3"
RCOMMENT,"BO5Program","BO5ExtendedApron","****$NAutomatic control.  The TON is dalay for start while the TOF is $Nthe delay for stop.$N****","OTE(BO5ExtendedApron.Internal.AutoModeRun)","4"
RCOMMENT,"BO5Program","BO5ExtendedApron","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(BO5ExtendedApron.Internal.ReleaseRamp)","5"
RCOMMENT,"BO5Program","BO5ExtendedApron","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(BO5ExtendedApron.Internal.DecelTime,BO5ExtendedApron.Internal.DecelTime)","6"
RCOMMENT,"BO5Program","BO5ExtendedApron","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(BO5ExtendedApron.Internal.SpeedReference.ScaledOutput,BO5ExtendedApron:O.FreqCommand)","7"
RCOMMENT,"BO5Program","BO5ExtendedApron","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(BO5ExtendedApron:O.Start)","8"
RCOMMENT,"BO5Program","BO5ExtendedApron","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(BO5ExtendedApron:O.Stop)","9"
RCOMMENT,"BO5Program","BO5ExtendedApron","****$NThe reverse command is set above.$N****","OTE(BO5ExtendedApron:O.Reverse)","10"
RCOMMENT,"BO5Program","BO5ExtendedApron","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(BO5ExtendedApron:O.Forward)","11"
RCOMMENT,"BO5Program","BO5ExtendedApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO5ExtendedApron.Internal.ActualSpeedScaler.ScaledOutput,BO5ExtendedApron.Status.ActualSpeed)","12"
RCOMMENT,"BO5Program","BO5ExtendedApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO5ExtendedApron.Internal.LoadScaler.ScaledOutput,BO5ExtendedApron.Status.MotorLoad)","13"
RCOMMENT,"BO5Program","BO5ExtendedApron","****$NDrive Running Status$N****","OTE(BO5ExtendedApron.Status.Running)","14"
RCOMMENT,"BO5Program","BO5ExtendedApron","****$NJogging Forward Status$N****","OTE(BO5ExtendedApron.Status.JoggingFwd)","15"
RCOMMENT,"BO5Program","BO5ExtendedApron","****$NJogging Reverse Status$N****","OTE(BO5ExtendedApron.Status.JoggingRev)","16"
RCOMMENT,"BO5Program","BO5ExtendedApron","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(BO5ExtendedApron.Status.FailedToStart)","17"
RCOMMENT,"BO5Program","BO5ExtendedApron","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(BO5ExtendedApron.Status.FailedToStop)","18"
RCOMMENT,"BO5Program","BO5ExtendedApron","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(BO5ExtendedApron.Status.Faulted)","19"
RCOMMENT,"BO5Program","BO5ExtendedApron","****$NUnlatch the Drive Faulted Status$N****","OTU(BO5ExtendedApron.Status.FailedToStop)","20"
RCOMMENT,"BO5Program","BO5LiftApron","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(BO5LiftApron.Internal.Permissive)","0"
RCOMMENT,"BO5Program","BO5LiftApron","****$NJog Command$N****","OTE(BO5LiftApron.Internal.IntermediateJog)","1"
RCOMMENT,"BO5Program","BO5LiftApron","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(BO5LiftApron.Internal.DriveReverse)","2"
RCOMMENT,"BO5Program","BO5LiftApron","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(BO5LiftApron.Internal.MaintModeRun)","3"
RCOMMENT,"BO5Program","BO5LiftApron","****$NThis timer makes sure the doffer is running and up to speed$Nbefore the lfit apron starts.$N****","TON(BO5.Internal.DofferRunningTimer,?,?)","4"
RCOMMENT,"BO5Program","BO5LiftApron","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(BO5LiftApron.Internal.ReleaseRamp)","5"
RCOMMENT,"BO5Program","BO5LiftApron","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(BO5LiftApron.Internal.DecelTime,BO5LiftApron.Internal.DecelTime)","6"
RCOMMENT,"BO5Program","BO5LiftApron","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(BO5LiftApron.Internal.SpeedReference.ScaledOutput,BO5LiftApron:O.FreqCommand)","7"
RCOMMENT,"BO5Program","BO5LiftApron","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(BO5LiftApron:O.Start)","8"
RCOMMENT,"BO5Program","BO5LiftApron","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(BO5LiftApron:O.Stop)","9"
RCOMMENT,"BO5Program","BO5LiftApron","****$NThe reverse command is set above.$N****","OTE(BO5LiftApron:O.Reverse)","10"
RCOMMENT,"BO5Program","BO5LiftApron","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(BO5LiftApron:O.Forward)","11"
RCOMMENT,"BO5Program","BO5LiftApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO5LiftApron.Internal.ActualSpeedScaler.ScaledOutput,BO5LiftApron.Status.ActualSpeed)","12"
RCOMMENT,"BO5Program","BO5LiftApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO5LiftApron.Internal.LoadScaler.ScaledOutput,BO5LiftApron.Status.MotorLoad)","13"
RCOMMENT,"BO5Program","BO5LiftApron","****$NDrive Running Status$N****","OTE(BO5LiftApron.Status.Running)","14"
RCOMMENT,"BO5Program","BO5LiftApron","****$NJogging Forward Status$N****","OTE(BO5LiftApron.Status.JoggingFwd)","15"
RCOMMENT,"BO5Program","BO5LiftApron","****$NJogging Reverse Status$N****","OTE(BO5LiftApron.Status.JoggingRev)","16"
RCOMMENT,"BO5Program","BO5LiftApron","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(BO5LiftApron.Status.FailedToStart)","17"
RCOMMENT,"BO5Program","BO5LiftApron","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(BO5LiftApron.Status.FailedToStop)","18"
RCOMMENT,"BO5Program","BO5LiftApron","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(BO5LiftApron.Status.Faulted)","19"
RCOMMENT,"BO5Program","BO5LiftApron","****$NUnlatch the Drive Faulted Status$N****","OTU(BO5LiftApron.Status.FailedToStop)","20"
RCOMMENT,"BO5Program","BO5LoadApron","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(BO5LoadApron.Internal.Permissive)","0"
RCOMMENT,"BO5Program","BO5LoadApron","****$NJog Command$N****","OTE(BO5LoadApron.Internal.IntermediateJog)","1"
RCOMMENT,"BO5Program","BO5LoadApron","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(BO5LoadApron.Internal.DriveReverse)","2"
RCOMMENT,"BO5Program","BO5LoadApron","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(BO5LoadApron.Internal.MaintModeRun)","3"
RCOMMENT,"BO5Program","BO5LoadApron","****$NRestart Control$N****","OTE(BO5LoadApron.Internal.IntermediateAutoRun)","4"
RCOMMENT,"BO5Program","BO5LoadApron","****$NControl the Restart Horn$N****","OTE(BO5BaleOpenerRestartHorn)","5"
RCOMMENT,"BO5Program","BO5LoadApron","****$NAutomatic control.  The TON is dalay for start while the TOF is $Nthe delay for stop.$N****","OTE(BO5LoadApron.Internal.AutoModeRun)","6"
RCOMMENT,"BO5Program","BO5LoadApron","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(BO5LoadApron.Internal.ReleaseRamp)","7"
RCOMMENT,"BO5Program","BO5LoadApron","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(BO5LoadApron.Internal.DecelTime,BO5LoadApron.Internal.DecelTime)","8"
RCOMMENT,"BO5Program","BO5LoadApron","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(BO5LoadApron.Internal.SpeedReference.ScaledOutput,BO5LoadApron:O.FreqCommand)","9"
RCOMMENT,"BO5Program","BO5LoadApron","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(BO5LoadApron:O.Start)","10"
RCOMMENT,"BO5Program","BO5LoadApron","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(BO5LoadApron:O.Stop)","11"
RCOMMENT,"BO5Program","BO5LoadApron","****$NThe reverse command is set above.$N****","OTE(BO5LoadApron:O.Reverse)","12"
RCOMMENT,"BO5Program","BO5LoadApron","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(BO5LoadApron:O.Forward)","13"
RCOMMENT,"BO5Program","BO5LoadApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO5LoadApron.Internal.ActualSpeedScaler.ScaledOutput,BO5LoadApron.Status.ActualSpeed)","14"
RCOMMENT,"BO5Program","BO5LoadApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BO5LoadApron.Internal.LoadScaler.ScaledOutput,BO5LoadApron.Status.MotorLoad)","15"
RCOMMENT,"BO5Program","BO5LoadApron","****$NDrive Running Status$N****","OTE(BO5LoadApron.Status.Running)","16"
RCOMMENT,"BO5Program","BO5LoadApron","****$NJogging Forward Status$N****","OTE(BO5LoadApron.Status.JoggingFwd)","17"
RCOMMENT,"BO5Program","BO5LoadApron","****$NJogging Reverse Status$N****","OTE(BO5LoadApron.Status.JoggingRev)","18"
RCOMMENT,"BO5Program","BO5LoadApron","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(BO5LoadApron.Status.FailedToStart)","19"
RCOMMENT,"BO5Program","BO5LoadApron","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(BO5LoadApron.Status.FailedToStop)","20"
RCOMMENT,"BO5Program","BO5LoadApron","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(BO5LoadApron.Status.Faulted)","21"
RCOMMENT,"BO5Program","BO5LoadApron","****$NUnlatch the Drive Faulted Status$N****","OTU(BO5LoadApron.Status.FailedToStop)","22"
RCOMMENT,"BO5Program","BO5LoadDoor","****$NPermissive to operate$N****","OTE(BO5LoadDoor.Internal.Permissive)","0"
RCOMMENT,"BO5Program","BO5LoadDoor","****$NSolenoid to Automatic Mode$N****","OTU(BO5LoadDoor.Command.ToAuto)","1"
RCOMMENT,"BO5Program","BO5LoadDoor","****$NSolenoid to Manua Mode$N****","OTU(BO5LoadDoor.Command.ToManual)","2"
RCOMMENT,"BO5Program","BO5LoadDoor","****$NIf the solenoid is not in either mode, put in manual mode.$N****","OTL(BO5LoadDoor.Status.InManual)","3"
RCOMMENT,"BO5Program","BO5LoadDoor","****$NManual Run Control$N****","OTE(BO5LoadDoor.Internal.ManualClose)","4"
RCOMMENT,"BO5Program","BO5LoadDoor","****$NManual Run Control$N****","OTE(BO5LoadDoor.Internal.ManualOpen)","5"
RCOMMENT,"BO5Program","BO5LoadDoor","****$NControl of the solenoid.$N****","OTE(BO5LoadDoorCloseSol)","6"
RCOMMENT,"BO5Program","BO5LoadDoor","****$NControl of the solenoid.$N****","OTE(BO5LoadDoorOpenSol)","7"
RCOMMENT,"BO5Program","BO5LoadDoor","****$NOpen Status$N****","OTE(BO5LoadDoor.Status.Open)","8"
RCOMMENT,"BO5Program","BO5LoadDoor","****$NControl for the gate open pilot light.$N****","OTE(BO5LoadDoorClosedPL)","9"
RCOMMENT,"BO5Program","BO5LoadDoor","****$NOpen beacon control$N****","OTE(BO5LoadDoorOpenBeacon)","11"
RCOMMENT,"BO5Program","BO5LoadDoor","****$NThe pushbutton will unlock the gate above the load door if$Nthe conditions are met.$N****","OTE(BO5LoadGateReleaseSol)","12"
RCOMMENT,"BO5Program","BO5ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO5Control,0)","0"
RCOMMENT,"BO5Program","BO5ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO5Breaker,0)","1"
RCOMMENT,"BO5Program","BO5ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO5Damper,0)","2"
RCOMMENT,"BO5Program","BO5ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO5Doffer,0)","3"
RCOMMENT,"BO5Program","BO5ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO5DoorLocks,0)","4"
RCOMMENT,"BO5Program","BO5ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO5Dump,0)","5"
RCOMMENT,"BO5Program","BO5ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO5ExtendedApron,0)","6"
RCOMMENT,"BO5Program","BO5ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO5LiftApron,0)","7"
RCOMMENT,"BO5Program","BO5ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO5LoadApron,0)","8"
RCOMMENT,"BO5Program","BO5ProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BO5LoadDoor,0)","9"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"CardCovers","CardCover1","****$NThe master permissive prevents all movement.$N****","OTE(CardCover1.Internal.MasterPermissive)","0"
RCOMMENT,"CardCovers","CardCover1","****$NPermissive to Move the Cover$N****","OTE(CardCover1.Internal.LeftUpPermissive)","1"
RCOMMENT,"CardCovers","CardCover1","****$NPermissive to Move the Cover$N****","OTE(CardCover1.Internal.LeftDownPermissive)","2"
RCOMMENT,"CardCovers","CardCover1","****$NPermissive to Move the Cover$N****","OTE(CardCover1.Internal.RightUpPermissive)","3"
RCOMMENT,"CardCovers","CardCover1","****$NPermissive to Move the Cover$N****","OTE(CardCover1.Internal.RightDownPermissive)","4"
RCOMMENT,"CardCovers","CardCover1","****$NThe internal commands are used later to control the contactors.$N****","OTE(CardCover1.Internal.LeftUpCommand)","5"
RCOMMENT,"CardCovers","CardCover1","****$NThe internal commands are used later to control the contactors.$N****","OTE(CardCover1.Internal.RightUpCommand)","6"
RCOMMENT,"CardCovers","CardCover1","****$NThe internal commands are used later to control the contactors.$N****","OTE(CardCover1.Internal.LeftDownCommand)","7"
RCOMMENT,"CardCovers","CardCover1","****$NThe internal commands are used later to control the contactors.$N****","OTE(CardCover1.Internal.RightDownCommand)","8"
RCOMMENT,"CardCovers","CardCover1","****$NIf the cover is being commanded to move, it is assumed it is in motion.$NThe timer is a delay to allow other covers to move.$N****","TOF(CardCover1.Internal.InMotionTimer,?,?)","9"
RCOMMENT,"CardCovers","CardCover1","****$NOnly 1 cover should move at a time since the$Nrelays are interlocked and the same power supply is used.$N****","OTE(CardCover1.Internal.InMotion)","10"
RCOMMENT,"CardCovers","CardCover1","****$NThis contactor operates the side.  The direction (Up/Down) is controlled$Nby a master reversing contactor.$N****","OTE(CardCover1LeftCont)","11"
RCOMMENT,"CardCovers","CardCover1","****$NThis contactor operates the side.  The direction (Up/Down) is controlled$Nby a master reversing contactor.$N****","OTE(CardCover1RightCont)","12"
RCOMMENT,"CardCovers","CardCover1","****$NIf the contactor is commanded to engage and it does not$Nit has failed to run.$N****","OTL(CardCover1.Status.LeftFailedToRun)","13"
RCOMMENT,"CardCovers","CardCover1","****$NIf the contactor is commanded to engage and it does not$Nit has failed to run.$N****","OTL(CardCover1.Status.RightFailedToRun)","14"
RCOMMENT,"CardCovers","CardCover1","****$NIf the contactor failed to open when the command$Nis removed, it has failed to stop.$N****","OTL(CardCover1.Status.LeftFailedToStop)","15"
RCOMMENT,"CardCovers","CardCover1","****$NIf the contactor failed to open when the command$Nis removed, it has failed to stop.$N****","OTL(CardCover1.Status.RightFailedToStop)","16"
RCOMMENT,"CardCovers","CardCover1","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover1.Status.RightClosedLimit)","17"
RCOMMENT,"CardCovers","CardCover1","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover1.Status.RightOpenLimit)","18"
RCOMMENT,"CardCovers","CardCover1","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover1.Status.LeftClosedLimit)","19"
RCOMMENT,"CardCovers","CardCover1","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover1.Status.LeftOpenLimit)","20"
RCOMMENT,"CardCovers","CardCover1","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover1.Status.LeftAndRightClosedLimit)","21"
RCOMMENT,"CardCovers","CardCover1","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover1.Status.LeftAndRightOpenLimit)","22"
RCOMMENT,"CardCovers","CardCover1","****$NFaulted status for HMI display.$N****","OTE(CardCover1.Status.Faulted)","23"
RCOMMENT,"CardCovers","CardCover1","****$NReset the faults.$N****","OTU(CardCover1.Status.RightFailedToStop)","24"
RCOMMENT,"CardCovers","CardCover2","****$NThe master permissive prevents all movement.$N****","OTE(CardCover2.Internal.MasterPermissive)","0"
RCOMMENT,"CardCovers","CardCover2","****$NPermissive to Move the Cover$N****","OTE(CardCover2.Internal.LeftUpPermissive)","1"
RCOMMENT,"CardCovers","CardCover2","****$NPermissive to Move the Cover$N****","OTE(CardCover2.Internal.LeftDownPermissive)","2"
RCOMMENT,"CardCovers","CardCover2","****$NPermissive to Move the Cover$N****","OTE(CardCover2.Internal.RightUpPermissive)","3"
RCOMMENT,"CardCovers","CardCover2","****$NPermissive to Move the Cover$N****","OTE(CardCover2.Internal.RightDownPermissive)","4"
RCOMMENT,"CardCovers","CardCover2","****$NThe internal commands are used later to control the contactors.$N****","OTE(CardCover2.Internal.LeftUpCommand)","5"
RCOMMENT,"CardCovers","CardCover2","****$NThe internal commands are used later to control the contactors.$N****","OTE(CardCover2.Internal.RightUpCommand)","6"
RCOMMENT,"CardCovers","CardCover2","****$NThe internal commands are used later to control the contactors.$N****","OTE(CardCover2.Internal.LeftDownCommand)","7"
RCOMMENT,"CardCovers","CardCover2","****$NThe internal commands are used later to control the contactors.$N****","OTE(CardCover2.Internal.RightDownCommand)","8"
RCOMMENT,"CardCovers","CardCover2","****$NIf the cover is being commanded to move, it is assumed it is in motion.$NThe timer is a delay to allow other covers to move.$N****","TOF(CardCover2.Internal.InMotionTimer,?,?)","9"
RCOMMENT,"CardCovers","CardCover2","****$NOnly 1 cover should move at a time since the$Nrelays are interlocked and the same power supply is used.$N****","OTE(CardCover2.Internal.InMotion)","10"
RCOMMENT,"CardCovers","CardCover2","****$NThis contactor operates the side.  The direction (Up/Down) is controlled$Nby a master reversing contactor.$N****","OTE(CardCover2LeftCont)","11"
RCOMMENT,"CardCovers","CardCover2","****$NThis contactor operates the side.  The direction (Up/Down) is controlled$Nby a master reversing contactor.$N****","OTE(CardCover2RightCont)","12"
RCOMMENT,"CardCovers","CardCover2","****$NIf the contactor is commanded to engage and it does not$Nit has failed to run.$N****","OTL(CardCover2.Status.LeftFailedToRun)","13"
RCOMMENT,"CardCovers","CardCover2","****$NIf the contactor is commanded to engage and it does not$Nit has failed to run.$N****","OTL(CardCover2.Status.RightFailedToRun)","14"
RCOMMENT,"CardCovers","CardCover2","****$NIf the contactor failed to open when the command$Nis removed, it has failed to stop.$N****","OTL(CardCover2.Status.LeftFailedToStop)","15"
RCOMMENT,"CardCovers","CardCover2","****$NIf the contactor failed to open when the command$Nis removed, it has failed to stop.$N****","OTL(CardCover2.Status.RightFailedToStop)","16"
RCOMMENT,"CardCovers","CardCover2","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover2.Status.RightClosedLimit)","17"
RCOMMENT,"CardCovers","CardCover2","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover2.Status.RightOpenLimit)","18"
RCOMMENT,"CardCovers","CardCover2","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover2.Status.LeftClosedLimit)","19"
RCOMMENT,"CardCovers","CardCover2","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover2.Status.LeftOpenLimit)","20"
RCOMMENT,"CardCovers","CardCover2","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover2.Status.LeftAndRightClosedLimit)","21"
RCOMMENT,"CardCovers","CardCover2","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover2.Status.LeftAndRightOpenLimit)","22"
RCOMMENT,"CardCovers","CardCover2","****$NFaulted status for HMI display.$N****","OTE(CardCover2.Status.Faulted)","23"
RCOMMENT,"CardCovers","CardCover2","****$NReset the faults.$N****","OTU(CardCover2.Status.RightFailedToStop)","24"
RCOMMENT,"CardCovers","CardCover3","****$NThe master permissive prevents all movement.$N****","OTE(CardCover3.Internal.MasterPermissive)","0"
RCOMMENT,"CardCovers","CardCover3","****$NPermissive to Move the Cover$N****","OTE(CardCover3.Internal.LeftUpPermissive)","1"
RCOMMENT,"CardCovers","CardCover3","****$NPermissive to Move the Cover$N****","OTE(CardCover3.Internal.LeftDownPermissive)","2"
RCOMMENT,"CardCovers","CardCover3","****$NPermissive to Move the Cover$N****","OTE(CardCover3.Internal.RightUpPermissive)","3"
RCOMMENT,"CardCovers","CardCover3","****$NPermissive to Move the Cover$N****","OTE(CardCover3.Internal.RightDownPermissive)","4"
RCOMMENT,"CardCovers","CardCover3","****$NThe internal commands are used later to control the contactors.$N****","OTE(CardCover3.Internal.LeftUpCommand)","5"
RCOMMENT,"CardCovers","CardCover3","****$NThe internal commands are used later to control the contactors.$N****","OTE(CardCover3.Internal.RightUpCommand)","6"
RCOMMENT,"CardCovers","CardCover3","****$NThe internal commands are used later to control the contactors.$N****","OTE(CardCover3.Internal.LeftDownCommand)","7"
RCOMMENT,"CardCovers","CardCover3","****$NThe internal commands are used later to control the contactors.$N****","OTE(CardCover3.Internal.RightDownCommand)","8"
RCOMMENT,"CardCovers","CardCover3","****$NIf the cover is being commanded to move, it is assumed it is in motion.$NThe timer is a delay to allow other covers to move.$N****","TOF(CardCover3.Internal.InMotionTimer,?,?)","9"
RCOMMENT,"CardCovers","CardCover3","****$NOnly 1 cover should move at a time since the$Nrelays are interlocked and the same power supply is used.$N****","OTE(CardCover3.Internal.InMotion)","10"
RCOMMENT,"CardCovers","CardCover3","****$NThis contactor operates the side.  The direction (Up/Down) is controlled$Nby a master reversing contactor.$N****","OTE(CardCover3LeftCont)","11"
RCOMMENT,"CardCovers","CardCover3","****$NThis contactor operates the side.  The direction (Up/Down) is controlled$Nby a master reversing contactor.$N****","OTE(CardCover3RightCont)","12"
RCOMMENT,"CardCovers","CardCover3","****$NIf the contactor is commanded to engage and it does not$Nit has failed to run.$N****","OTL(CardCover3.Status.LeftFailedToRun)","13"
RCOMMENT,"CardCovers","CardCover3","****$NIf the contactor is commanded to engage and it does not$Nit has failed to run.$N****","OTL(CardCover3.Status.RightFailedToRun)","14"
RCOMMENT,"CardCovers","CardCover3","****$NIf the contactor failed to open when the command$Nis removed, it has failed to stop.$N****","OTL(CardCover3.Status.LeftFailedToStop)","15"
RCOMMENT,"CardCovers","CardCover3","****$NIf the contactor failed to open when the command$Nis removed, it has failed to stop.$N****","OTL(CardCover3.Status.RightFailedToStop)","16"
RCOMMENT,"CardCovers","CardCover3","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover3.Status.RightClosedLimit)","17"
RCOMMENT,"CardCovers","CardCover3","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover3.Status.RightOpenLimit)","18"
RCOMMENT,"CardCovers","CardCover3","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover3.Status.LeftClosedLimit)","19"
RCOMMENT,"CardCovers","CardCover3","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover3.Status.LeftOpenLimit)","20"
RCOMMENT,"CardCovers","CardCover3","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover3.Status.LeftAndRightClosedLimit)","21"
RCOMMENT,"CardCovers","CardCover3","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover3.Status.LeftAndRightOpenLimit)","22"
RCOMMENT,"CardCovers","CardCover3","****$NFaulted status for HMI display.$N****","OTE(CardCover3.Status.Faulted)","23"
RCOMMENT,"CardCovers","CardCover3","****$NReset the faults.$N****","OTU(CardCover3.Status.RightFailedToStop)","24"
RCOMMENT,"CardCovers","CardCover4","****$NThe master permissive prevents all movement.$N****","OTE(CardCover4.Internal.MasterPermissive)","0"
RCOMMENT,"CardCovers","CardCover4","****$NPermissive to Move the Cover$N****","OTE(CardCover4.Internal.LeftUpPermissive)","1"
RCOMMENT,"CardCovers","CardCover4","****$NPermissive to Move the Cover$N****","OTE(CardCover4.Internal.LeftDownPermissive)","2"
RCOMMENT,"CardCovers","CardCover4","****$NPermissive to Move the Cover$N****","OTE(CardCover4.Internal.RightUpPermissive)","3"
RCOMMENT,"CardCovers","CardCover4","****$NPermissive to Move the Cover$N****","OTE(CardCover4.Internal.RightDownPermissive)","4"
RCOMMENT,"CardCovers","CardCover4","****$NThe internal commands are used later to control the contactors.$N****","OTE(CardCover4.Internal.LeftUpCommand)","5"
RCOMMENT,"CardCovers","CardCover4","****$NThe internal commands are used later to control the contactors.$N****","OTE(CardCover4.Internal.RightUpCommand)","6"
RCOMMENT,"CardCovers","CardCover4","****$NThe internal commands are used later to control the contactors.$N****","OTE(CardCover4.Internal.LeftDownCommand)","7"
RCOMMENT,"CardCovers","CardCover4","****$NThe internal commands are used later to control the contactors.$N****","OTE(CardCover4.Internal.RightDownCommand)","8"
RCOMMENT,"CardCovers","CardCover4","****$NIf the cover is being commanded to move, it is assumed it is in motion.$NThe timer is a delay to allow other covers to move.$N****","TOF(CardCover4.Internal.InMotionTimer,?,?)","9"
RCOMMENT,"CardCovers","CardCover4","****$NOnly 1 cover should move at a time since the$Nrelays are interlocked and the same power supply is used.$N****","OTE(CardCover4.Internal.InMotion)","10"
RCOMMENT,"CardCovers","CardCover4","****$NThis contactor operates the side.  The direction (Up/Down) is controlled$Nby a master reversing contactor.$N****","OTE(CardCover4LeftCont)","11"
RCOMMENT,"CardCovers","CardCover4","****$NThis contactor operates the side.  The direction (Up/Down) is controlled$Nby a master reversing contactor.$N****","OTE(CardCover4RightCont)","12"
RCOMMENT,"CardCovers","CardCover4","****$NIf the contactor is commanded to engage and it does not$Nit has failed to run.$N****","OTL(CardCover4.Status.LeftFailedToRun)","13"
RCOMMENT,"CardCovers","CardCover4","****$NIf the contactor is commanded to engage and it does not$Nit has failed to run.$N****","OTL(CardCover4.Status.RightFailedToRun)","14"
RCOMMENT,"CardCovers","CardCover4","****$NIf the contactor failed to open when the command$Nis removed, it has failed to stop.$N****","OTL(CardCover4.Status.LeftFailedToStop)","15"
RCOMMENT,"CardCovers","CardCover4","****$NIf the contactor failed to open when the command$Nis removed, it has failed to stop.$N****","OTL(CardCover4.Status.RightFailedToStop)","16"
RCOMMENT,"CardCovers","CardCover4","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover4.Status.RightClosedLimit)","17"
RCOMMENT,"CardCovers","CardCover4","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover4.Status.RightOpenLimit)","18"
RCOMMENT,"CardCovers","CardCover4","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover4.Status.LeftClosedLimit)","19"
RCOMMENT,"CardCovers","CardCover4","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover4.Status.LeftOpenLimit)","20"
RCOMMENT,"CardCovers","CardCover4","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover4.Status.LeftAndRightClosedLimit)","21"
RCOMMENT,"CardCovers","CardCover4","****$NMap limits to status bits for HMI Display.$N****","OTE(CardCover4.Status.LeftAndRightOpenLimit)","22"
RCOMMENT,"CardCovers","CardCover4","****$NFaulted status for HMI display.$N****","OTE(CardCover4.Status.Faulted)","23"
RCOMMENT,"CardCovers","CardCover4","****$NReset the faults.$N****","OTU(CardCover4.Status.RightFailedToStop)","24"
RCOMMENT,"CardCovers","CardCoversMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(CardCover1,0)","0"
RCOMMENT,"CardCovers","CardCoversMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(CardCover2,0)","1"
RCOMMENT,"CardCovers","CardCoversMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(CardCover3,0)","2"
RCOMMENT,"CardCovers","CardCoversMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(CardCover4,0)","3"
RCOMMENT,"CardCovers","CardCoversMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(DirectionControl,0)","4"
RCOMMENT,"CardCovers","DirectionControl","****$NIf any of the covers are commanded up, the $QUP$Q contactor$Nshould activate.  Because the output is a safety output,$Nthe actual output must be controlled from the safety task.  This bit$Nis linked to a bit in the safety task.$N****","OTE(CardCoverCylindersUpControl)","0"
RCOMMENT,"CardCovers","DirectionControl","****$NIf any of the covers are commanded down, the $QDOWN$Q contactor$Nshould activate.  Because the output is a safety output,$Nthe actual output must be controlled from the safety task.  This bit$Nis linked to a bit in the safety task.$N****","OTE(CardCoverCylindersDownControl)","1"
RCOMMENT,"CardCovers","DirectionControl","****$NReset the faults.$N****","OTU(CardCoverFailedToStop)","2"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"Chutefeed","ChutefeedBeater","****$NPermissive to operate the motor.$N****","OTE(ChutefeedBeater.Internal.Permissive)","0"
RCOMMENT,"Chutefeed","ChutefeedBeater","****$NManual Run Control$N****","OTE(ChutefeedBeater.Internal.IntermediateRunForward)","1"
RCOMMENT,"Chutefeed","ChutefeedBeater","****$NManual Jog Control$N****","OTE(ChutefeedBeater.Internal.IntermediateJogForward)","2"
RCOMMENT,"Chutefeed","ChutefeedBeater","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(ChutefeedBeater.Internal.AutoOffDelayTimer,?,?)","3"
RCOMMENT,"Chutefeed","ChutefeedBeater","****$NMotor Starter Control$N****","OTE(ChutefeedBeaterCont)","4"
RCOMMENT,"Chutefeed","ChutefeedBeater","****$NRunning Status$N****","OTE(ChutefeedBeater.Status.RunningForward)","5"
RCOMMENT,"Chutefeed","ChutefeedBeater","****$NIf the motor does not start when commanded, it has failed to run$N****","OTL(ChutefeedBeater.Status.FailedToStart)","6"
RCOMMENT,"Chutefeed","ChutefeedBeater","****$NIf a motor continues to run when the run command has been removed,$Nit has failed to stop.$N****$N","OTL(ChutefeedBeater.Status.FailedToStop)","7"
RCOMMENT,"Chutefeed","ChutefeedBeater","****$NGeneral Faulted Status$N****","OTE(ChutefeedBeater.Status.Faulted)","8"
RCOMMENT,"Chutefeed","ChutefeedBeater","****$NReset Fault Latches$N****","OTU(ChutefeedBeater.Status.FailedToStop)","9"
RCOMMENT,"Chutefeed","ChutefeedCompaction","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(ChutefeedCompaction.Internal.Permissive)","0"
RCOMMENT,"Chutefeed","ChutefeedCompaction","****$NJog Command$N****","OTE(ChutefeedCompaction.Internal.IntermediateJog)","1"
RCOMMENT,"Chutefeed","ChutefeedCompaction","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(ChutefeedCompaction.Internal.DriveReverse)","2"
RCOMMENT,"Chutefeed","ChutefeedCompaction","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(ChutefeedCompaction.Internal.MaintModeRun)","3"
RCOMMENT,"Chutefeed","ChutefeedCompaction","****$NAutomatic control.  The TON is dalay for start while the TOF is $Nthe delay for stop.$N****","OTE(ChutefeedCompaction.Internal.AutoModeRun)","4"
RCOMMENT,"Chutefeed","ChutefeedCompaction","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(ChutefeedCompaction.Internal.ReleaseRamp)","5"
RCOMMENT,"Chutefeed","ChutefeedCompaction","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(ChutefeedCompaction.Internal.DecelTime,ChutefeedCompaction.Internal.DecelTime)","6"
RCOMMENT,"Chutefeed","ChutefeedCompaction","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(ChutefeedCompaction.Internal.SpeedReference.ScaledOutput,ChutefeedCompactionSpeedRef)","7"
RCOMMENT,"Chutefeed","ChutefeedCompaction","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(ChutefeedCompactionRun)","8"
RCOMMENT,"Chutefeed","ChutefeedCompaction","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(ChutefeedCompaction.Internal.ActualSpeedScaler.ScaledOutput,ChutefeedCompaction.Status.ActualSpeed)","9"
RCOMMENT,"Chutefeed","ChutefeedCompaction","****$NDrive Running Status$N****","OTE(ChutefeedCompaction.Status.Running)","10"
RCOMMENT,"Chutefeed","ChutefeedCompaction","****$NJogging Forward Status$N****","OTE(ChutefeedCompaction.Status.JoggingFwd)","11"
RCOMMENT,"Chutefeed","ChutefeedCompaction","****$NJogging Reverse Status$N****","OTE(ChutefeedCompaction.Status.JoggingRev)","12"
RCOMMENT,"Chutefeed","ChutefeedCompaction","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(ChutefeedCompaction.Status.FailedToStart)","13"
RCOMMENT,"Chutefeed","ChutefeedCompaction","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(ChutefeedCompaction.Status.FailedToStop)","14"
RCOMMENT,"Chutefeed","ChutefeedCompaction","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(ChutefeedCompaction.Status.Faulted)","15"
RCOMMENT,"Chutefeed","ChutefeedCompaction","****$NUnlatch the Drive Faulted Status$N****","OTU(ChutefeedCompaction.Status.FailedToStop)","16"
RCOMMENT,"Chutefeed","ChutefeedControl","****$NPermissive to operate the system.$N****","OTE(Chutefeed.Internal.Permissive)","0"
RCOMMENT,"Chutefeed","ChutefeedControl","****$NSystem to Automatic Mode$N****","OTU(Chutefeed.Command.ToAutomatic)","1"
RCOMMENT,"Chutefeed","ChutefeedControl","****$NSystem to Manual Mode$N****","OTU(Chutefeed.Command.ToManual)","2"
RCOMMENT,"Chutefeed","ChutefeedControl","****$NAutomatic Mode Run Control$N****","TOF(Chutefeed.Internal.StopDelay,?,?)","3"
RCOMMENT,"Chutefeed","ChutefeedControl","****$NAutomatic Mode Run Command$NThe run command follows the timers above.$N****","OTE(Chutefeed.Internal.IntermediateAutoModeRun)","4"
RCOMMENT,"Chutefeed","ChutefeedControl","****$NManul Mode Run Command$N****","OTE(Chutefeed.Internal.IntermediateManualModeRun)","5"
RCOMMENT,"Chutefeed","ChutefeedControl","****$NIf the system is being told to run in either mode, the status is $Qrunning$Q.$N****","OTE(Chutefeed.Status.Running)","6"
RCOMMENT,"Chutefeed","ChutefeedControl","****$NThe input is used to trigger two timers for debounce.  The resulting state$Nwill be used in the program.$N****","OTE(Chutefeed.Internal.PEState)","9"
RCOMMENT,"Chutefeed","ChutefeedControl","****$NCall for Fiber to Blending$N****","OTE(Chutefeed.Status.CallForFiber)","10"
RCOMMENT,"Chutefeed","ChutefeedDeliveryRoll","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(ChutefeedDeliveryRoll.Internal.Permissive)","0"
RCOMMENT,"Chutefeed","ChutefeedDeliveryRoll","****$NJog Command$N****","OTE(ChutefeedDeliveryRoll.Internal.IntermediateJog)","1"
RCOMMENT,"Chutefeed","ChutefeedDeliveryRoll","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(ChutefeedDeliveryRoll.Internal.DriveReverse)","2"
RCOMMENT,"Chutefeed","ChutefeedDeliveryRoll","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(ChutefeedDeliveryRoll.Internal.MaintModeRun)","3"
RCOMMENT,"Chutefeed","ChutefeedDeliveryRoll","****$NAutomatic control.  The TON is dalay for start while the TOF is $Nthe delay for stop.$N****","OTE(ChutefeedDeliveryRoll.Internal.AutoModeRun)","4"
RCOMMENT,"Chutefeed","ChutefeedDeliveryRoll","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(ChutefeedDeliveryRoll.Internal.ReleaseRamp)","5"
RCOMMENT,"Chutefeed","ChutefeedDeliveryRoll","****$NThe speed may be incremented/decremented$Nby the step change value.  It is then checked against pre-determined values.$N****","MOV(ChutefeedDeliveryRoll.Command.DrawSetpointMin,ChutefeedDeliveryRoll.Command.DrawSetpoint)","6"
RCOMMENT,"Chutefeed","ChutefeedDeliveryRoll","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(ChutefeedDeliveryRoll.Internal.DecelTime,ChutefeedDeliveryRoll.Internal.DecelTime)","7"
RCOMMENT,"Chutefeed","ChutefeedDeliveryRoll","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(ChutefeedDeliveryRoll.Internal.SpeedReference.ScaledOutput,DeliveryRoll:O.FreqCommand)","8"
RCOMMENT,"Chutefeed","ChutefeedDeliveryRoll","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(DeliveryRoll:O.Start)","9"
RCOMMENT,"Chutefeed","ChutefeedDeliveryRoll","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(DeliveryRoll:O.Stop)","10"
RCOMMENT,"Chutefeed","ChutefeedDeliveryRoll","****$NThe reverse command is set above.$N****","OTE(DeliveryRoll:O.Reverse)","11"
RCOMMENT,"Chutefeed","ChutefeedDeliveryRoll","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(DeliveryRoll:O.Forward)","12"
RCOMMENT,"Chutefeed","ChutefeedDeliveryRoll","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(ChutefeedDeliveryRoll.Internal.ActualSpeedScaler.ScaledOutput,ChutefeedDeliveryRoll.Status.ActualSpeed)","13"
RCOMMENT,"Chutefeed","ChutefeedDeliveryRoll","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(ChutefeedDeliveryRoll.Internal.LoadScaler.ScaledOutput,ChutefeedDeliveryRoll.Status.MotorLoad)","14"
RCOMMENT,"Chutefeed","ChutefeedDeliveryRoll","****$NDrive Running Status$N****","OTE(ChutefeedDeliveryRoll.Status.Running)","15"
RCOMMENT,"Chutefeed","ChutefeedDeliveryRoll","****$NJogging Forward Status$N****","OTE(ChutefeedDeliveryRoll.Status.JoggingFwd)","16"
RCOMMENT,"Chutefeed","ChutefeedDeliveryRoll","****$NJogging Reverse Status$N****","OTE(ChutefeedDeliveryRoll.Status.JoggingRev)","17"
RCOMMENT,"Chutefeed","ChutefeedDeliveryRoll","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(ChutefeedDeliveryRoll.Status.FailedToStart)","18"
RCOMMENT,"Chutefeed","ChutefeedDeliveryRoll","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(ChutefeedDeliveryRoll.Status.FailedToStop)","19"
RCOMMENT,"Chutefeed","ChutefeedDeliveryRoll","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(ChutefeedDeliveryRoll.Status.Faulted)","20"
RCOMMENT,"Chutefeed","ChutefeedDeliveryRoll","****$NUnlatch the Drive Faulted Status$N****","OTU(ChutefeedDeliveryRoll.Status.FailedToStop)","21"
RCOMMENT,"Chutefeed","ChutefeedFeedroll","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(ChutefeedFeedroll.Internal.Permissive)","0"
RCOMMENT,"Chutefeed","ChutefeedFeedroll","****$NJog Command$N****","OTE(ChutefeedFeedroll.Internal.IntermediateJog)","1"
RCOMMENT,"Chutefeed","ChutefeedFeedroll","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(ChutefeedFeedroll.Internal.DriveReverse)","2"
RCOMMENT,"Chutefeed","ChutefeedFeedroll","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(ChutefeedFeedroll.Internal.MaintModeRun)","3"
RCOMMENT,"Chutefeed","ChutefeedFeedroll","****$NDebounce the photo eyes for control.$N****","OTE(ChutefeedPEStatus)","4"
RCOMMENT,"Chutefeed","ChutefeedFeedroll","****$NAutomatic control.  The TON is dalay for start while the TOF is $Nthe delay for stop.$N****","OTE(ChutefeedFeedroll.Internal.AutoModeRun)","5"
RCOMMENT,"Chutefeed","ChutefeedFeedroll","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(ChutefeedFeedroll.Internal.ReleaseRamp)","6"
RCOMMENT,"Chutefeed","ChutefeedFeedroll","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(ChutefeedFeedroll.Internal.DecelTime,ChutefeedFeedroll.Internal.DecelTime)","7"
RCOMMENT,"Chutefeed","ChutefeedFeedroll","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","NEG(ChutefeedFeedroll.Internal.SpeedReference.ScaledOutput,ChutefeedFeedroll.Outputs.SetSpeed)","8"
RCOMMENT,"Chutefeed","ChutefeedFeedroll","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(ChutefeedFeedroll.Outputs.DriveCommandWord.Enable2)","9"
RCOMMENT,"Chutefeed","ChutefeedFeedroll","****$NInhibit the drive when it is not being told to run.$N****","OTE(ChutefeedFeedroll.Outputs.DriveCommandWord.ControllerInhibit)","10"
RCOMMENT,"Chutefeed","ChutefeedFeedroll","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(ChutefeedFeedroll.Internal.ActualSpeedScaler.ScaledOutput,ChutefeedFeedroll.Status.ActualSpeed)","11"
RCOMMENT,"Chutefeed","ChutefeedFeedroll","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(ChutefeedFeedroll.Internal.LoadScaler.ScaledOutput,ChutefeedFeedroll.Status.MotorLoad)","12"
RCOMMENT,"Chutefeed","ChutefeedFeedroll","****$NDrive Running Status$N****","OTE(ChutefeedFeedroll.Status.Running)","13"
RCOMMENT,"Chutefeed","ChutefeedFeedroll","****$NJogging Forward Status$N****","OTE(ChutefeedFeedroll.Status.JoggingFwd)","14"
RCOMMENT,"Chutefeed","ChutefeedFeedroll","****$NJogging Reverse Status$N****","OTE(ChutefeedFeedroll.Status.JoggingRev)","15"
RCOMMENT,"Chutefeed","ChutefeedFeedroll","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(ChutefeedFeedroll.Status.FailedToStart)","16"
RCOMMENT,"Chutefeed","ChutefeedFeedroll","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(ChutefeedFeedroll.Status.FailedToStop)","17"
RCOMMENT,"Chutefeed","ChutefeedFeedroll","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(ChutefeedFeedroll.Status.Faulted)","18"
RCOMMENT,"Chutefeed","ChutefeedFeedroll","****$NUnlatch the Drive Faulted Status$N****","OTU(ChutefeedFeedroll.Status.FailedToStop)","19"
RCOMMENT,"Chutefeed","ChutefeedMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(ChutefeedBeater,0)","0"
RCOMMENT,"Chutefeed","ChutefeedMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(ChutefeedCompaction,0)","1"
RCOMMENT,"Chutefeed","ChutefeedMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(ChutefeedDeliveryRoll,0)","2"
RCOMMENT,"Chutefeed","ChutefeedMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(ChutefeedFeedroll,0)","3"
RCOMMENT,"Chutefeed","ChutefeedMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(ChutefeedVentilators,0)","4"
RCOMMENT,"Chutefeed","ChutefeedVentilators","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(ChutefeedVentilators.Internal.Permissive)","0"
RCOMMENT,"Chutefeed","ChutefeedVentilators","****$NJog Command$N****","OTE(ChutefeedVentilators.Internal.IntermediateJog)","1"
RCOMMENT,"Chutefeed","ChutefeedVentilators","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(ChutefeedVentilators.Internal.DriveReverse)","2"
RCOMMENT,"Chutefeed","ChutefeedVentilators","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(ChutefeedVentilators.Internal.MaintModeRun)","3"
RCOMMENT,"Chutefeed","ChutefeedVentilators","****$NAutomatic control.  The TON is dalay for start while the TOF is $Nthe delay for stop.$N****","OTE(ChutefeedVentilators.Internal.AutoModeRun)","4"
RCOMMENT,"Chutefeed","ChutefeedVentilators","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(ChutefeedVentilators.Internal.ReleaseRamp)","5"
RCOMMENT,"Chutefeed","ChutefeedVentilators","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(ChutefeedVentilators.Internal.DecelTime,ChutefeedVentilators.Internal.DecelTime)","6"
RCOMMENT,"Chutefeed","ChutefeedVentilators","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(ChutefeedVentilators.Internal.SpeedReference.ScaledOutput,ChutefeedVentilators:O.FreqCommand)","7"
RCOMMENT,"Chutefeed","ChutefeedVentilators","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(ChutefeedVentilators:O.Start)","8"
RCOMMENT,"Chutefeed","ChutefeedVentilators","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(ChutefeedVentilators:O.Stop)","9"
RCOMMENT,"Chutefeed","ChutefeedVentilators","****$NThe reverse command is set above.$N****","OTE(ChutefeedVentilators:O.Reverse)","10"
RCOMMENT,"Chutefeed","ChutefeedVentilators","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(ChutefeedVentilators:O.Forward)","11"
RCOMMENT,"Chutefeed","ChutefeedVentilators","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(ChutefeedVentilators.Internal.ActualSpeedScaler.ScaledOutput,ChutefeedVentilators.Status.ActualSpeed)","12"
RCOMMENT,"Chutefeed","ChutefeedVentilators","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(ChutefeedVentilators.Internal.LoadScaler.ScaledOutput,ChutefeedVentilators.Status.MotorLoad)","13"
RCOMMENT,"Chutefeed","ChutefeedVentilators","****$NDrive Running Status$N****","OTE(ChutefeedVentilators.Status.Running)","15"
RCOMMENT,"Chutefeed","ChutefeedVentilators","****$NJogging Forward Status$N****","OTE(ChutefeedVentilators.Status.JoggingFwd)","16"
RCOMMENT,"Chutefeed","ChutefeedVentilators","****$NJogging Reverse Status$N****","OTE(ChutefeedVentilators.Status.JoggingRev)","17"
RCOMMENT,"Chutefeed","ChutefeedVentilators","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(ChutefeedVentilators.Status.FailedToStart)","18"
RCOMMENT,"Chutefeed","ChutefeedVentilators","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(ChutefeedVentilators.Status.FailedToStop)","19"
RCOMMENT,"Chutefeed","ChutefeedVentilators","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(ChutefeedVentilators.Status.Faulted)","20"
RCOMMENT,"Chutefeed","ChutefeedVentilators","****$NUnlatch the Drive Faulted Status$N****","OTU(ChutefeedVentilators.Status.FailedToStop)","21"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"Dilo","DiloLoomMinMaxCalc","****$NThe Min/Max limits are read from the Dilo PLC.$NThey are scaled to engineering units to be used as limits to the entered values$Nand also limits to setpoints sent to the Dilo PLC.$N****","MUL(RLM1InfeedApronDraftMax,0.1,HMI_M1InfeedApronDraftMax)","0"
RCOMMENT,"Dilo","DiloLoomMinMaxCalc","****$NThe Min/Max limits are read from the Dilo PLC.$NThey are scaled to engineering units to be used as limits to the entered values$Nand also limits to setpoints sent to the Dilo PLC.$N****","MUL(RLM1FingerRollerDraftMax,0.1,HMI_M1FingerRollerDraftMax)","1"
RCOMMENT,"Dilo","DiloLoomMinMaxCalc","****$NThe Min/Max limits are read from the Dilo PLC.$NThey are scaled to engineering units to be used as limits to the entered values$Nand also limits to setpoints sent to the Dilo PLC.$N****","MUL(RLM1OutfeedDraftMax,0.1,HMI_M1OutfeedDraftMax)","2"
RCOMMENT,"Dilo","DiloLoomMinMaxCalc","****$NThe Min/Max limits are read from the Dilo PLC.$NThey are scaled to engineering units to be used as limits to the entered values$Nand also limits to setpoints sent to the Dilo PLC.$N****","MUL(RLM1AdvancePerStrokeMax,0.01,HMI_M1AdvancePerStrokeMax)","3"
RCOMMENT,"Dilo","DiloLoomMinMaxCalc","****$NThe Min/Max limits are read from the Dilo PLC.$NThey are scaled to engineering units to be used as limits to the entered values$Nand also limits to setpoints sent to the Dilo PLC.$N****","MUL(4,1,HMI_M1NeedleLengthMax)","4"
RCOMMENT,"Dilo","DiloLoomMinMaxCalc","****$NThe Min/Max limits are read from the Dilo PLC.$NThey are scaled to engineering units to be used as limits to the entered values$Nand also limits to setpoints sent to the Dilo PLC.$N****","MUL(RLM1PenetrationMax,0.1,HMI_M1PenetrationMax)","5"
RCOMMENT,"Dilo","DiloLoomMinMaxCalc","****$NThe Min/Max limits are read from the Dilo PLC.$NThey are scaled to engineering units to be used as limits to the entered values$Nand also limits to setpoints sent to the Dilo PLC.$N****","MUL(RLM1GapMax,0.1,HMI_M1GapMax)","6"
RCOMMENT,"Dilo","DiloLoomMinMaxCalc","****$NThe Min/Max limits are read from the Dilo PLC.$NThey are scaled to engineering units to be used as limits to the entered values$Nand also limits to setpoints sent to the Dilo PLC.$N****","MUL(RLM2InfeedDraftMax,0.1,HMI_M2InfeedDraftMax)","7"
RCOMMENT,"Dilo","DiloLoomMinMaxCalc","****$NThe Min/Max limits are read from the Dilo PLC.$NThey are scaled to engineering units to be used as limits to the entered values$Nand also limits to setpoints sent to the Dilo PLC.$N****","MUL(RLM2OutfeedDraftMax,0.1,HMI_M2OutfeedDraftMax)","8"
RCOMMENT,"Dilo","DiloLoomMinMaxCalc","****$NThe Min/Max limits are read from the Dilo PLC.$NThey are scaled to engineering units to be used as limits to the entered values$Nand also limits to setpoints sent to the Dilo PLC.$N****","MUL(RLM2AdvancePerStrokeMax,0.01,HMI_M2AdvancePerStrokeMax)","9"
RCOMMENT,"Dilo","DiloLoomMinMaxCalc","****$NThe Min/Max limits are read from the Dilo PLC.$NThey are scaled to engineering units to be used as limits to the entered values$Nand also limits to setpoints sent to the Dilo PLC.$N****","MUL(4,1,HMI_M2NeedleLengthTopMax)","10"
RCOMMENT,"Dilo","DiloLoomMinMaxCalc","****$NThe Min/Max limits are read from the Dilo PLC.$NThey are scaled to engineering units to be used as limits to the entered values$Nand also limits to setpoints sent to the Dilo PLC.$N****","MUL(4,1,HMI_M2NeedleLengthBottomMax)","11"
RCOMMENT,"Dilo","DiloLoomMinMaxCalc","****$NThe Min/Max limits are read from the Dilo PLC.$NThey are scaled to engineering units to be used as limits to the entered values$Nand also limits to setpoints sent to the Dilo PLC.$N****","MUL(RLM2PenetrationTopMax,0.1,HMI_M2PenetrationTopMax)","12"
RCOMMENT,"Dilo","DiloLoomMinMaxCalc","****$NThe Min/Max limits are read from the Dilo PLC.$NThey are scaled to engineering units to be used as limits to the entered values$Nand also limits to setpoints sent to the Dilo PLC.$N****","MUL(RLM2PenetrationBottomMax,0.1,HMI_M2PenetrationBottomMax)","13"
RCOMMENT,"Dilo","DiloLoomMinMaxCalc","****$NThe Min/Max limits are read from the Dilo PLC.$NThey are scaled to engineering units to be used as limits to the entered values$Nand also limits to setpoints sent to the Dilo PLC.$N****","MUL(RLM2GapMax,0.1,HMI_M2GapMax)","14"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM1SpeedMasterAct,0.01,HMI_M1SpeedMasterActual)","0"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM1InfeedDraftAct,1,HMI_M1InfeedDraftActual)","1"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM1FingerRollerDraftAct,0.1,HMI_M1FingerRollerDraftActual)","2"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM1DrawOffDraftAct,0.1,HMI_M1DrawOffDraftActual)","3"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM1InfeedSpeedAct,0.01,HMI_M1InfeedSpeedActual)","4"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM1FingerRollerSpeedAct,0.01,HMI_M1FingerRollerSpeedActual)","5"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM1DrawOffSpeedAct,0.01,HMI_M1DrawOffSpeedActual)","6"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM1StrokeFreqAct,1,HMI_M1StrokeFrequencyActual)","7"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM1PenetrationAct,0.1,HMI_M1PenetrationAcutal)","8"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM1GapAct,0.1,HMI_M1GapActual)","9"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM1FingerRollersGapAct,0.1,HMI_M1FingerRollerGapActual)","10"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM2InfeedDraftAct,0.1,HMI_M2InfeedDraftActual)","11"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM2DrawOffDraftAct,0.1,HMI_M2DrawOffDraftActual)","12"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM2InfeedSpeedAct,0.01,HMI_M2InfeedSpeedActual)","13"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM2DrawOffSpeedAct,0.01,HMI_M2DrawOffSpeedActual)","14"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM2StrokeFreqAct,1,HMI_M2StrokeFrequencyActual)","15"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM2PenetrationTopAct,0.1,HMI_M2PenetrationTopActual)","16"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM2PenetrationBottomAct,0.1,HMI_M2PenetrationBottomActual)","17"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM2GapAct,0.1,HMI_M2GapActual)","18"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM1InfeedDraftSP,1,HMI_M1InfeedDraftSetpointFB)","19"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM1FingerRollerDraftSP,0.1,HMI_M1FingerRollerDraftSetpointFB)","20"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM1DrawOffDraftSP,0.1,HMI_M1DrawOffDraftSetpointFB)","21"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM1InfeedSpeedSP,0.001,HMI_M1InfeedSpeedSetpointFB)","22"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM1NeedleDensitySP,1,HMI_M1NeedleDensitySetpointFB)","23"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM1AdvancePerStrokeSP,0.01,HMI_M1AdvancePerStrokeSetpointFB)","24"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM1StitchingDensitySP,0.1,HMI_M1StitchingDensitySetpointFB)","25"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM1NeedleLengthSP,0.5,HMI_M1NeedleLengthSetpointFB)","26"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM1PenetrationSP,0.1,HMI_M1PenetrationSetpointFB)","27"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM1GapSP,0.1,HMI_M1GapSetpointFB)","28"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM2InfeedDraftSP,0.01,HMI_M2InfeedDraftSetpointFB)","29"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM2DrawOffDraftSP,0.1,HMI_M2DrawOffDraftSetpointFB)","30"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM2InfeedSpeedSP,0.01,HMI_M2InfeedSpeedSetpointFB)","31"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM2NeedleDensityTopSP,1,HMI_M2NeedleDensityTopSetpointFB)","32"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM2NeedleDensityBottomSP,1,HMI_M2NeedleDensityBottomSetpointFB)","33"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM2AdvancePerStrokeSP,0.01,HMI_M2AdvancePerStrokeSetpointFB)","34"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM2StitchingDensitySP,0.1,HMI_M2StitchingDensitySetpointFB)","35"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM2NeedleLengthTopSP,0.5,HMI_M2NeedleLengthTopSetpointFB)","36"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM2NeedleLengthBottomSP,0.5,HMI_M2NeedleLengthBottomSetpointFB)","37"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM2PenetrationBottomSP,0.1,HMI_M2PenetrationBottomSetpointFB)","38"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM2PenetrationTopSP,0.1,HMI_M2PenetrationTopSetpointFB)","39"
RCOMMENT,"Dilo","DiloLoomReadData","****$NThe $QRL$Q means $QRead from Loom PLC$Q.  The read data gets scaled$Nand moved into a register for the HMI display.$N****","MUL(RLM2GapSP,0.1,HMI_M2GapSetpointFB)","40"
RCOMMENT,"Dilo","DiloLoomWriteData","****$NThe $QWL$Q means $QWrite to Loom PLC$Q.  The data gets scaled$Nand moved the register to be written to the looms$' PLC.$N****","OTL(HMI_LoomSetpointError)","0"
RCOMMENT,"Dilo","DiloLoomWriteData","****$NThe $QWL$Q means $QWrite to Loom PLC$Q.  The data gets scaled$Nand moved the register to be written to the looms$' PLC.$N****","OTL(HMI_LoomSetpointError)","1"
RCOMMENT,"Dilo","DiloLoomWriteData","****$NThe $QWL$Q means $QWrite to Loom PLC$Q.  The data gets scaled$Nand moved the register to be written to the looms$' PLC.$N****","OTL(HMI_LoomSetpointError)","2"
RCOMMENT,"Dilo","DiloLoomWriteData","****$NThe $QWL$Q means $QWrite to Loom PLC$Q.  The data gets scaled$Nand moved the register to be written to the looms$' PLC.$N****","OTL(HMI_LoomSetpointError)","3"
RCOMMENT,"Dilo","DiloLoomWriteData","****$NThe $QWL$Q means $QWrite to Loom PLC$Q.  The data gets scaled$Nand moved the register to be written to the looms$' PLC.$N****","OTL(HMI_LoomSetpointError)","4"
RCOMMENT,"Dilo","DiloLoomWriteData","****$NThe $QWL$Q means $QWrite to Loom PLC$Q.  The data gets scaled$Nand moved the register to be written to the looms$' PLC.$N****","OTL(HMI_LoomSetpointError)","5"
RCOMMENT,"Dilo","DiloLoomWriteData","****$NThe $QWL$Q means $QWrite to Loom PLC$Q.  The data gets scaled$Nand moved the register to be written to the looms$' PLC.$N****","OTL(HMI_LoomSetpointError)","6"
RCOMMENT,"Dilo","DiloLoomWriteData","****$NThe $QWL$Q means $QWrite to Loom PLC$Q.  The data gets scaled$Nand moved the register to be written to the looms$' PLC.$N****","OTL(HMI_LoomSetpointError)","7"
RCOMMENT,"Dilo","DiloLoomWriteData","****$NThe $QWL$Q means $QWrite to Loom PLC$Q.  The data gets scaled$Nand moved the register to be written to the looms$' PLC.$N****","OTL(HMI_LoomSetpointError)","8"
RCOMMENT,"Dilo","DiloLoomWriteData","****$NThe $QWL$Q means $QWrite to Loom PLC$Q.  The data gets scaled$Nand moved the register to be written to the looms$' PLC.$N****","OTL(HMI_LoomSetpointError)","9"
RCOMMENT,"Dilo","DiloLoomWriteData","****$NThe $QWL$Q means $QWrite to Loom PLC$Q.  The data gets scaled$Nand moved the register to be written to the looms$' PLC.$N****","OTL(HMI_LoomSetpointError)","10"
RCOMMENT,"Dilo","DiloLoomWriteData","****$NThe $QWL$Q means $QWrite to Loom PLC$Q.  The data gets scaled$Nand moved the register to be written to the looms$' PLC.$N****","OTL(HMI_LoomSetpointError)","11"
RCOMMENT,"Dilo","DiloLoomWriteData","****$NThe $QWL$Q means $QWrite to Loom PLC$Q.  The data gets scaled$Nand moved the register to be written to the looms$' PLC.$N****","OTL(HMI_LoomSetpointError)","12"
RCOMMENT,"Dilo","DiloLoomWriteData","****$NThe $QWL$Q means $QWrite to Loom PLC$Q.  The data gets scaled$Nand moved the register to be written to the looms$' PLC.$N****","OTL(HMI_LoomSetpointError)","13"
RCOMMENT,"Dilo","DiloLoomWriteData","****$NThe $QWL$Q means $QWrite to Loom PLC$Q.  The data gets scaled$Nand moved the register to be written to the looms$' PLC.$N****","OTL(HMI_LoomSetpointError)","14"
RCOMMENT,"Dilo","DiloMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(DiloLoomMinMaxCalc,0)","0"
RCOMMENT,"Dilo","DiloMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(DiloLoomReadData,0)","1"
RCOMMENT,"Dilo","DiloMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(DiloLoomWriteData,0)","2"
RCOMMENT,"Dilo","DiloMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(DiloXLPRMinMaxCalc,0)","3"
RCOMMENT,"Dilo","DiloMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(DiloXLPRReadData,0)","4"
RCOMMENT,"Dilo","DiloMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(DiloXLPRWriteData,0)","5"
RCOMMENT,"Dilo","DiloXLPRMinMaxCalc","****$NThe Min/Max limits are read from the Dilo PLC.$NThey are scaled to engineering units to be used as limits to the entered values$Nand also limits to setpoints sent to the Dilo PLC.$N****","MUL(RCCrosslapperDraftMax,0.1,HMI_CrosslapperDraftMax)","0"
RCOMMENT,"Dilo","DiloXLPRMinMaxCalc","****$NThe Min/Max limits are read from the Dilo PLC.$NThey are scaled to engineering units to be used as limits to the entered values$Nand also limits to setpoints sent to the Dilo PLC.$N****","MUL(RCCrosslapperProfMax,0.1,HMI_CrosslapperProfMax)","1"
RCOMMENT,"Dilo","DiloXLPRMinMaxCalc","****$NThe Min/Max limits are read from the Dilo PLC.$NThey are scaled to engineering units to be used as limits to the entered values$Nand also limits to setpoints sent to the Dilo PLC.$N****","MUL(RCCrosslapperExitWidthMax,1,HMI_CrosslapperExitWidthMax)","2"
RCOMMENT,"Dilo","DiloXLPRMinMaxCalc","****$NThe Min/Max limits are read from the Dilo PLC.$NThey are scaled to engineering units to be used as limits to the entered values$Nand also limits to setpoints sent to the Dilo PLC.$N****","MUL(RCCrosslapperEntryWidthMax,1,HMI_CrosslapperEntryWidthMax)","3"
RCOMMENT,"Dilo","DiloXLPRMinMaxCalc","****$NThe Min/Max limits are read from the Dilo PLC.$NThey are scaled to engineering units to be used as limits to the entered values$Nand also limits to setpoints sent to the Dilo PLC.$N****","MUL(RCCrosslapperNumberOfLayersMax,1,HMI_CrosslapperNumberOfLayersMax)","4"
RCOMMENT,"Dilo","DiloXLPRMinMaxCalc","****$NThe Min/Max limits are read from the Dilo PLC.$NThey are scaled to engineering units to be used as limits to the entered values$Nand also limits to setpoints sent to the Dilo PLC.$N****","MUL(RCCrosslapperLayerOverlapMax,0.1,HMI_CrosslapperLayerOverlapMax)","5"
RCOMMENT,"Dilo","DiloXLPRMinMaxCalc","****$NThe Min/Max limits are read from the Dilo PLC.$NThey are scaled to engineering units to be used as limits to the entered values$Nand also limits to setpoints sent to the Dilo PLC.$N****","MUL(RCCrosslapperApronHeightMax,1,HMI_CrosslapperApronHeightMax)","6"
RCOMMENT,"Dilo","DiloXLPRReadData","****$NThe WC in the tags stand for $QRead from the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP are scaled before being displayed.$N****","MUL(RCCrosslapperDraft,0.1,HMI_RCCrosslapperDraft)","0"
RCOMMENT,"Dilo","DiloXLPRReadData","****$NThe WC in the tags stand for $QRead from the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP are scaled before being displayed.$N****","MUL(RCProfileFB0,0.1,HMI_RCProfileFB0)","1"
RCOMMENT,"Dilo","DiloXLPRReadData","****$NThe WC in the tags stand for $QRead from the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP are scaled before being displayed.$N****","MUL(RCProfileFB1,0.1,HMI_RCProfileFB1)","2"
RCOMMENT,"Dilo","DiloXLPRReadData","****$NThe WC in the tags stand for $QRead from the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP are scaled before being displayed.$N****","MUL(RCProfileFB2,0.1,HMI_RCProfileFB2)","3"
RCOMMENT,"Dilo","DiloXLPRReadData","****$NThe WC in the tags stand for $QRead from the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP are scaled before being displayed.$N****","MUL(RCProfileFB3,0.1,HMI_RCProfileFB3)","4"
RCOMMENT,"Dilo","DiloXLPRReadData","****$NThe WC in the tags stand for $QRead from the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP are scaled before being displayed.$N****","MUL(RCProfileFB4,0.1,HMI_RCProfileFB4)","5"
RCOMMENT,"Dilo","DiloXLPRReadData","****$NThe WC in the tags stand for $QRead from the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP are scaled before being displayed.$N****","MUL(RCProfileFB5,0.1,HMI_RCProfileFB5)","6"
RCOMMENT,"Dilo","DiloXLPRReadData","****$NThe WC in the tags stand for $QRead from the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP are scaled before being displayed.$N****","MUL(RCProfileFB6,0.1,HMI_RCProfileFB6)","7"
RCOMMENT,"Dilo","DiloXLPRReadData","****$NThe WC in the tags stand for $QRead from the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP are scaled before being displayed.$N****","MUL(RCProfileFB7,0.1,HMI_RCProfileFB7)","8"
RCOMMENT,"Dilo","DiloXLPRReadData","****$NThe WC in the tags stand for $QRead from the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP are scaled before being displayed.$N****","MUL(RCProfileFB8,0.1,HMI_RCProfileFB8)","9"
RCOMMENT,"Dilo","DiloXLPRReadData","****$NThe WC in the tags stand for $QRead from the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP are scaled before being displayed.$N****","MUL(RCApronHeightFBLeft,1,HMI_RCApronHeightFBLeft)","10"
RCOMMENT,"Dilo","DiloXLPRReadData","****$NThe WC in the tags stand for $QRead from the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP are scaled before being displayed.$N****","MUL(RCApronHeightFBRight,1,HMI_RCApronHeightFBRight)","11"
RCOMMENT,"Dilo","DiloXLPRReadData","****$NThe WC in the tags stand for $QRead from the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP are scaled before being displayed.$N****","MUL(RCNumberOfLayers,1,HMI_RCNumberOfLayers)","12"
RCOMMENT,"Dilo","DiloXLPRReadData","****$NThe WC in the tags stand for $QRead from the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP are scaled before being displayed.$N****","MUL(RCLayerOverlap,0.1,HMI_RCLayerOverlap)","13"
RCOMMENT,"Dilo","DiloXLPRReadData","****$NThe WC in the tags stand for $QRead from the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP are scaled before being displayed.$N****","MUL(RCEntryWidth,1,HMI_RCEntryWidth)","14"
RCOMMENT,"Dilo","DiloXLPRReadData","****$NThe WC in the tags stand for $QRead from the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP are scaled before being displayed.$N****","MUL(RCExitWidthLeft,1,HMI_RCExitWidthLeft)","15"
RCOMMENT,"Dilo","DiloXLPRReadData","****$NThe WC in the tags stand for $QRead from the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP are scaled before being displayed.$N****","MUL(RCExitWidthRight,1,HMI_RCExitWidthRight)","16"
RCOMMENT,"Dilo","DiloXLPRWriteData","****$NThe WC in the tags stand for $QWrite to the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP and the values that will show up in the Dilo PLC.  They should$Nbe scaled appropriately.$N****","OTL(WCEnableMahloControl)","2"
RCOMMENT,"Dilo","DiloXLPRWriteData","****$NThe WC in the tags stand for $QWrite to the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP and the values that will show up in the Dilo PLC.  They should$Nbe scaled appropriately.$N****","OTU(WCEnableMahloControl)","3"
RCOMMENT,"Dilo","DiloXLPRWriteData","****$NThe WC in the tags stand for $QWrite to the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP and the values that will show up in the Dilo PLC.  They should$Nbe scaled appropriately.$N****","OTE(WCStartMahloControl)","4"
RCOMMENT,"Dilo","DiloXLPRWriteData","****$NThe WC in the tags stand for $QWrite to the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP and the values that will show up in the Dilo PLC.  They should$Nbe scaled appropriately.$N****","OTE(WCStopMahloControl)","5"
RCOMMENT,"Dilo","DiloXLPRWriteData","****$NThe WC in the tags stand for $QWrite to the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP and the values that will show up in the Dilo PLC.  They should$Nbe scaled appropriately.$N****","OTL(HMI_CrosslapperSetpointError)","6"
RCOMMENT,"Dilo","DiloXLPRWriteData","****$NThe WC in the tags stand for $QWrite to the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP and the values that will show up in the Dilo PLC.  They should$Nbe scaled appropriately.$N****","OTL(HMI_CrosslapperSetpointError)","7"
RCOMMENT,"Dilo","DiloXLPRWriteData","****$NThe WC in the tags stand for $QWrite to the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP and the values that will show up in the Dilo PLC.  They should$Nbe scaled appropriately.$N****","OTL(HMI_CrosslapperSetpointError)","8"
RCOMMENT,"Dilo","DiloXLPRWriteData","****$NThe WC in the tags stand for $QWrite to the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP and the values that will show up in the Dilo PLC.  They should$Nbe scaled appropriately.$N****","OTL(HMI_CrosslapperSetpointError)","9"
RCOMMENT,"Dilo","DiloXLPRWriteData","****$NThe WC in the tags stand for $QWrite to the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP and the values that will show up in the Dilo PLC.  They should$Nbe scaled appropriately.$N****","OTL(HMI_CrosslapperSetpointError)","10"
RCOMMENT,"Dilo","DiloXLPRWriteData","****$NThe WC in the tags stand for $QWrite to the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP and the values that will show up in the Dilo PLC.  They should$Nbe scaled appropriately.$N****","OTL(HMI_CrosslapperSetpointError)","11"
RCOMMENT,"Dilo","DiloXLPRWriteData","****$NThe WC in the tags stand for $QWrite to the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP and the values that will show up in the Dilo PLC.  They should$Nbe scaled appropriately.$N****","OTL(HMI_CrosslapperSetpointError)","12"
RCOMMENT,"Dilo","DiloXLPRWriteData","****$NThe WC in the tags stand for $QWrite to the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP and the values that will show up in the Dilo PLC.  They should$Nbe scaled appropriately.$N****","OTL(HMI_CrosslapperSetpointError)","13"
RCOMMENT,"Dilo","DiloXLPRWriteData","****$NThe WC in the tags stand for $QWrite to the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP and the values that will show up in the Dilo PLC.  They should$Nbe scaled appropriately.$N****","OTL(HMI_CrosslapperSetpointError)","14"
RCOMMENT,"Dilo","DiloXLPRWriteData","****$NThe WC in the tags stand for $QWrite to the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP and the values that will show up in the Dilo PLC.  They should$Nbe scaled appropriately.$N****","OTL(HMI_CrosslapperSetpointError)","15"
RCOMMENT,"Dilo","DiloXLPRWriteData","****$NThe WC in the tags stand for $QWrite to the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP and the values that will show up in the Dilo PLC.  They should$Nbe scaled appropriately.$N****","OTL(HMI_CrosslapperSetpointError)","16"
RCOMMENT,"Dilo","DiloXLPRWriteData","****$NThe WC in the tags stand for $QWrite to the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP and the values that will show up in the Dilo PLC.  They should$Nbe scaled appropriately.$N****","OTL(HMI_CrosslapperSetpointError)","17"
RCOMMENT,"Dilo","DiloXLPRWriteData","****$NThe WC in the tags stand for $QWrite to the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP and the values that will show up in the Dilo PLC.  They should$Nbe scaled appropriately.$N****","OTL(HMI_CrosslapperSetpointError)","18"
RCOMMENT,"Dilo","DiloXLPRWriteData","****$NThe WC in the tags stand for $QWrite to the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP and the values that will show up in the Dilo PLC.  They should$Nbe scaled appropriately.$N****","OTL(HMI_CrosslapperSetpointError)","19"
RCOMMENT,"Dilo","DiloXLPRWriteData","****$NThe WC in the tags stand for $QWrite to the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP and the values that will show up in the Dilo PLC.  They should$Nbe scaled appropriately.$N****","OTL(HMI_CrosslapperSetpointError)","20"
RCOMMENT,"Dilo","DiloXLPRWriteData","****$NThe WC in the tags stand for $QWrite to the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP and the values that will show up in the Dilo PLC.  They should$Nbe scaled appropriately.$N****","OTL(HMI_CrosslapperSetpointError)","21"
RCOMMENT,"Dilo","DiloXLPRWriteData","****$NThe WC in the tags stand for $QWrite to the Crosslapper PLC$Q.  These are the tags that are aliased$Ndirectly to the Red Lion DSP and the values that will show up in the Dilo PLC.  They should$Nbe scaled appropriately.$N****","OTL(HMI_CrosslapperSetpointError)","22"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"DriveDataExchange","Apron","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron.Inputs.DriveStatusWord.OutputEnabled)","0"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron.Inputs.DriveStatusWord.InverterReady)","1"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron.Inputs.DriveStatusWord.PODataEnabled)","2"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron.Inputs.DriveStatusWord.CurrentRampGenerator)","3"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron.Inputs.DriveStatusWord.CurrentParameterSet)","4"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron.Inputs.DriveStatusWord.FaultWarningPending)","5"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron.Inputs.DriveStatusWord.CWLimitSwitchActive)","6"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron.Inputs.DriveStatusWord.CCWLimitSwitchActive)","7"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron.Inputs.DriveStatusWord.StatusSINT.0)","8"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron.Inputs.DriveStatusWord.StatusSINT.1)","9"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron.Inputs.DriveStatusWord.StatusSINT.2)","10"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron.Inputs.DriveStatusWord.StatusSINT.3)","11"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron.Inputs.DriveStatusWord.StatusSINT.4)","12"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron.Inputs.DriveStatusWord.StatusSINT.5)","13"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron.Inputs.DriveStatusWord.StatusSINT.6)","14"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron.Inputs.DriveStatusWord.StatusSINT.7)","15"
RCOMMENT,"DriveDataExchange","Apron","****$NWhen bit 5 is set, the data in the second half of the status word$Nis the fault.  If bit 5 is not set, the byte is the drive status.$NThis byte is used as a pointer in a list of statuses to display the condition of the drive.$NCheck against limits to prevent array error.$N****","COP(SEWFaults[0],Apron.Status.FaultString,1)","16"
RCOMMENT,"DriveDataExchange","Apron","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,Apron.Inputs.ActualSpeed)","17"
RCOMMENT,"DriveDataExchange","Apron","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,Apron.Inputs.OutputCurrent)","18"
RCOMMENT,"DriveDataExchange","Apron","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,Apron.Inputs.IPosPIWord4)","19"
RCOMMENT,"DriveDataExchange","Apron","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,Apron.Inputs.IPosPIWord5)","20"
RCOMMENT,"DriveDataExchange","Apron","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,Apron.Inputs.IPosPIWord6)","21"
RCOMMENT,"DriveDataExchange","Apron","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,Apron.Inputs.IPosPIWord7)","22"
RCOMMENT,"DriveDataExchange","Apron","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,Apron.Inputs.IPosPIWord8)","23"
RCOMMENT,"DriveDataExchange","Apron","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,Apron.Inputs.IPosPIWord9)","24"
RCOMMENT,"DriveDataExchange","Apron","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,Apron.Inputs.IPosPIWord10)","25"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron:O.Data[0].0)","26"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron:O.Data[0].1)","27"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron:O.Data[0].2)","28"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron:O.Data[0].3)","29"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron:O.Data[0].4)","30"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron:O.Data[0].5)","31"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron:O.Data[0].6)","32"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron:O.Data[0].7)","33"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron:O.Data[0].8)","34"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron:O.Data[0].9)","35"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron:O.Data[0].10)","36"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron:O.Data[0].11)","37"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron:O.Data[0].12)","38"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron:O.Data[0].13)","39"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron:O.Data[0].14)","40"
RCOMMENT,"DriveDataExchange","Apron","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Apron:O.Data[0].15)","41"
RCOMMENT,"DriveDataExchange","Apron","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(Apron.Outputs.SetSpeed,Apron:O.Data[1])","42"
RCOMMENT,"DriveDataExchange","Apron","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(Apron.Outputs.NoFunction,Apron:O.Data[2])","43"
RCOMMENT,"DriveDataExchange","Apron","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(Apron.Outputs.IPosPOWord4,Apron:O.Data[3])","44"
RCOMMENT,"DriveDataExchange","Apron","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(Apron.Outputs.IPosPOWord5,Apron:O.Data[4])","45"
RCOMMENT,"DriveDataExchange","Apron","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(Apron.Outputs.IPosPOWord6,Apron:O.Data[5])","46"
RCOMMENT,"DriveDataExchange","Apron","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(Apron.Outputs.IPosPOWord7,Apron:O.Data[6])","47"
RCOMMENT,"DriveDataExchange","Apron","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(Apron.Outputs.IPosPOWord8,Apron:O.Data[7])","48"
RCOMMENT,"DriveDataExchange","Apron","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(Apron.Outputs.IPosPOWord9,Apron:O.Data[8])","49"
RCOMMENT,"DriveDataExchange","Apron","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(Apron.Outputs.IPosPOWord10,Apron:O.Data[9])","50"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer.Inputs.DriveStatusWord.OutputEnabled)","0"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer.Inputs.DriveStatusWord.InverterReady)","1"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer.Inputs.DriveStatusWord.PODataEnabled)","2"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer.Inputs.DriveStatusWord.CurrentRampGenerator)","3"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer.Inputs.DriveStatusWord.CurrentParameterSet)","4"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer.Inputs.DriveStatusWord.FaultWarningPending)","5"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer.Inputs.DriveStatusWord.CWLimitSwitchActive)","6"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer.Inputs.DriveStatusWord.CCWLimitSwitchActive)","7"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer.Inputs.DriveStatusWord.StatusSINT.0)","8"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer.Inputs.DriveStatusWord.StatusSINT.1)","9"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer.Inputs.DriveStatusWord.StatusSINT.2)","10"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer.Inputs.DriveStatusWord.StatusSINT.3)","11"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer.Inputs.DriveStatusWord.StatusSINT.4)","12"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer.Inputs.DriveStatusWord.StatusSINT.5)","13"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer.Inputs.DriveStatusWord.StatusSINT.6)","14"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer.Inputs.DriveStatusWord.StatusSINT.7)","15"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NWhen bit 5 is set, the data in the second half of the status word$Nis the fault.  If bit 5 is not set, the byte is the drive status.$NThis byte is used as a pointer in a list of statuses to display the condition of the drive.$NCheck against limits to prevent array error.$N****","COP(SEWFaults[0],BottomDoffer.Status.FaultString,1)","16"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomDoffer.Inputs.ActualSpeed)","17"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomDoffer.Inputs.OutputCurrent)","18"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomDoffer.Inputs.IPosPIWord4)","19"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomDoffer.Inputs.IPosPIWord5)","20"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomDoffer.Inputs.IPosPIWord6)","21"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomDoffer.Inputs.IPosPIWord7)","22"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomDoffer.Inputs.IPosPIWord8)","23"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomDoffer.Inputs.IPosPIWord9)","24"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomDoffer.Inputs.IPosPIWord10)","25"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer:O.Data[0].0)","26"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer:O.Data[0].1)","27"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer:O.Data[0].2)","28"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer:O.Data[0].3)","29"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer:O.Data[0].4)","30"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer:O.Data[0].5)","31"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer:O.Data[0].6)","32"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer:O.Data[0].7)","33"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer:O.Data[0].8)","34"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer:O.Data[0].9)","35"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer:O.Data[0].10)","36"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer:O.Data[0].11)","37"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer:O.Data[0].12)","38"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer:O.Data[0].13)","39"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer:O.Data[0].14)","40"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomDoffer:O.Data[0].15)","41"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomDoffer.Outputs.SetSpeed,BottomDoffer:O.Data[1])","42"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomDoffer.Outputs.NoFunction,BottomDoffer:O.Data[2])","43"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomDoffer.Outputs.IPosPOWord4,BottomDoffer:O.Data[3])","44"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomDoffer.Outputs.IPosPOWord5,BottomDoffer:O.Data[4])","45"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomDoffer.Outputs.IPosPOWord6,BottomDoffer:O.Data[5])","46"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomDoffer.Outputs.IPosPOWord7,BottomDoffer:O.Data[6])","47"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomDoffer.Outputs.IPosPOWord8,BottomDoffer:O.Data[7])","48"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomDoffer.Outputs.IPosPOWord9,BottomDoffer:O.Data[8])","49"
RCOMMENT,"DriveDataExchange","BottomDoffer","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomDoffer.Outputs.IPosPOWord10,BottomDoffer:O.Data[9])","50"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler.Inputs.DriveStatusWord.OutputEnabled)","0"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler.Inputs.DriveStatusWord.InverterReady)","1"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler.Inputs.DriveStatusWord.PODataEnabled)","2"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler.Inputs.DriveStatusWord.CurrentRampGenerator)","3"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler.Inputs.DriveStatusWord.CurrentParameterSet)","4"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler.Inputs.DriveStatusWord.FaultWarningPending)","5"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler.Inputs.DriveStatusWord.CWLimitSwitchActive)","6"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler.Inputs.DriveStatusWord.CCWLimitSwitchActive)","7"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler.Inputs.DriveStatusWord.StatusSINT.0)","8"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler.Inputs.DriveStatusWord.StatusSINT.1)","9"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler.Inputs.DriveStatusWord.StatusSINT.2)","10"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler.Inputs.DriveStatusWord.StatusSINT.3)","11"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler.Inputs.DriveStatusWord.StatusSINT.4)","12"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler.Inputs.DriveStatusWord.StatusSINT.5)","13"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler.Inputs.DriveStatusWord.StatusSINT.6)","14"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler.Inputs.DriveStatusWord.StatusSINT.7)","15"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NWhen bit 5 is set, the data in the second half of the status word$Nis the fault.  If bit 5 is not set, the byte is the drive status.$NThis byte is used as a pointer in a list of statuses to display the condition of the drive.$NCheck against limits to prevent array error.$N****","COP(SEWFaults[0],BottomScrambler.Status.FaultString,1)","16"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomScrambler.Inputs.ActualSpeed)","17"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomScrambler.Inputs.OutputCurrent)","18"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomScrambler.Inputs.IPosPIWord4)","19"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomScrambler.Inputs.IPosPIWord5)","20"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomScrambler.Inputs.IPosPIWord6)","21"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomScrambler.Inputs.IPosPIWord7)","22"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomScrambler.Inputs.IPosPIWord8)","23"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomScrambler.Inputs.IPosPIWord9)","24"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomScrambler.Inputs.IPosPIWord10)","25"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler:O.Data[0].0)","26"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler:O.Data[0].1)","27"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler:O.Data[0].2)","28"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler:O.Data[0].3)","29"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler:O.Data[0].4)","30"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler:O.Data[0].5)","31"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler:O.Data[0].6)","32"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler:O.Data[0].7)","33"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler:O.Data[0].8)","34"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler:O.Data[0].9)","35"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler:O.Data[0].10)","36"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler:O.Data[0].11)","37"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler:O.Data[0].12)","38"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler:O.Data[0].13)","39"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler:O.Data[0].14)","40"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomScrambler:O.Data[0].15)","41"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomScrambler.Outputs.SetSpeed,BottomScrambler:O.Data[1])","42"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomScrambler.Outputs.NoFunction,BottomScrambler:O.Data[2])","43"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomScrambler.Outputs.IPosPOWord4,BottomScrambler:O.Data[3])","44"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomScrambler.Outputs.IPosPOWord5,BottomScrambler:O.Data[4])","45"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomScrambler.Outputs.IPosPOWord6,BottomScrambler:O.Data[5])","46"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomScrambler.Outputs.IPosPOWord7,BottomScrambler:O.Data[6])","47"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomScrambler.Outputs.IPosPOWord8,BottomScrambler:O.Data[7])","48"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomScrambler.Outputs.IPosPOWord9,BottomScrambler:O.Data[8])","49"
RCOMMENT,"DriveDataExchange","BottomScrambler","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomScrambler.Outputs.IPosPOWord10,BottomScrambler:O.Data[9])","50"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff.Inputs.DriveStatusWord.OutputEnabled)","0"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff.Inputs.DriveStatusWord.InverterReady)","1"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff.Inputs.DriveStatusWord.PODataEnabled)","2"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff.Inputs.DriveStatusWord.CurrentRampGenerator)","3"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff.Inputs.DriveStatusWord.CurrentParameterSet)","4"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff.Inputs.DriveStatusWord.FaultWarningPending)","5"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff.Inputs.DriveStatusWord.CWLimitSwitchActive)","6"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff.Inputs.DriveStatusWord.CCWLimitSwitchActive)","7"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff.Inputs.DriveStatusWord.StatusSINT.0)","8"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff.Inputs.DriveStatusWord.StatusSINT.1)","9"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff.Inputs.DriveStatusWord.StatusSINT.2)","10"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff.Inputs.DriveStatusWord.StatusSINT.3)","11"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff.Inputs.DriveStatusWord.StatusSINT.4)","12"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff.Inputs.DriveStatusWord.StatusSINT.5)","13"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff.Inputs.DriveStatusWord.StatusSINT.6)","14"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff.Inputs.DriveStatusWord.StatusSINT.7)","15"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NWhen bit 5 is set, the data in the second half of the status word$Nis the fault.  If bit 5 is not set, the byte is the drive status.$NThis byte is used as a pointer in a list of statuses to display the condition of the drive.$NCheck against limits to prevent array error.$N****","COP(SEWFaults[0],BottomTakeoff.Status.FaultString,1)","16"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomTakeoff.Inputs.ActualSpeed)","17"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomTakeoff.Inputs.OutputCurrent)","18"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomTakeoff.Inputs.IPosPIWord4)","19"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomTakeoff.Inputs.IPosPIWord5)","20"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomTakeoff.Inputs.IPosPIWord6)","21"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomTakeoff.Inputs.IPosPIWord7)","22"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomTakeoff.Inputs.IPosPIWord8)","23"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomTakeoff.Inputs.IPosPIWord9)","24"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomTakeoff.Inputs.IPosPIWord10)","25"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff:O.Data[0].0)","26"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff:O.Data[0].1)","27"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff:O.Data[0].2)","28"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff:O.Data[0].3)","29"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff:O.Data[0].4)","30"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff:O.Data[0].5)","31"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff:O.Data[0].6)","32"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff:O.Data[0].7)","33"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff:O.Data[0].8)","34"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff:O.Data[0].9)","35"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff:O.Data[0].10)","36"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff:O.Data[0].11)","37"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff:O.Data[0].12)","38"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff:O.Data[0].13)","39"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff:O.Data[0].14)","40"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTakeoff:O.Data[0].15)","41"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomTakeoff.Outputs.SetSpeed,BottomTakeoff:O.Data[1])","42"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomTakeoff.Outputs.NoFunction,BottomTakeoff:O.Data[2])","43"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomTakeoff.Outputs.IPosPOWord4,BottomTakeoff:O.Data[3])","44"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomTakeoff.Outputs.IPosPOWord5,BottomTakeoff:O.Data[4])","45"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomTakeoff.Outputs.IPosPOWord6,BottomTakeoff:O.Data[5])","46"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomTakeoff.Outputs.IPosPOWord7,BottomTakeoff:O.Data[6])","47"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomTakeoff.Outputs.IPosPOWord8,BottomTakeoff:O.Data[7])","48"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomTakeoff.Outputs.IPosPOWord9,BottomTakeoff:O.Data[8])","49"
RCOMMENT,"DriveDataExchange","BottomTakeoff","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomTakeoff.Outputs.IPosPOWord10,BottomTakeoff:O.Data[9])","50"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt.Inputs.DriveStatusWord.OutputEnabled)","0"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt.Inputs.DriveStatusWord.InverterReady)","1"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt.Inputs.DriveStatusWord.PODataEnabled)","2"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt.Inputs.DriveStatusWord.CurrentRampGenerator)","3"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt.Inputs.DriveStatusWord.CurrentParameterSet)","4"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt.Inputs.DriveStatusWord.FaultWarningPending)","5"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt.Inputs.DriveStatusWord.CWLimitSwitchActive)","6"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt.Inputs.DriveStatusWord.CCWLimitSwitchActive)","7"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt.Inputs.DriveStatusWord.StatusSINT.0)","8"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt.Inputs.DriveStatusWord.StatusSINT.1)","9"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt.Inputs.DriveStatusWord.StatusSINT.2)","10"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt.Inputs.DriveStatusWord.StatusSINT.3)","11"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt.Inputs.DriveStatusWord.StatusSINT.4)","12"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt.Inputs.DriveStatusWord.StatusSINT.5)","13"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt.Inputs.DriveStatusWord.StatusSINT.6)","14"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt.Inputs.DriveStatusWord.StatusSINT.7)","15"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NWhen bit 5 is set, the data in the second half of the status word$Nis the fault.  If bit 5 is not set, the byte is the drive status.$NThis byte is used as a pointer in a list of statuses to display the condition of the drive.$NCheck against limits to prevent array error.$N****","COP(SEWFaults[0],BottomTOFBelt.Status.FaultString,1)","16"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomTOFBelt.Inputs.ActualSpeed)","17"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomTOFBelt.Inputs.OutputCurrent)","18"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomTOFBelt.Inputs.IPosPIWord4)","19"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomTOFBelt.Inputs.IPosPIWord5)","20"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomTOFBelt.Inputs.IPosPIWord6)","21"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomTOFBelt.Inputs.IPosPIWord7)","22"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomTOFBelt.Inputs.IPosPIWord8)","23"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomTOFBelt.Inputs.IPosPIWord9)","24"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,BottomTOFBelt.Inputs.IPosPIWord10)","25"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt:O.Data[0].0)","26"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt:O.Data[0].1)","27"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt:O.Data[0].2)","28"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt:O.Data[0].3)","29"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt:O.Data[0].4)","30"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt:O.Data[0].5)","31"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt:O.Data[0].6)","32"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt:O.Data[0].7)","33"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt:O.Data[0].8)","34"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt:O.Data[0].9)","35"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt:O.Data[0].10)","36"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt:O.Data[0].11)","37"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt:O.Data[0].12)","38"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt:O.Data[0].13)","39"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt:O.Data[0].14)","40"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(BottomTOFBelt:O.Data[0].15)","41"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomTOFBelt.Outputs.SetSpeed,BottomTOFBelt:O.Data[1])","42"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomTOFBelt.Outputs.NoFunction,BottomTOFBelt:O.Data[2])","43"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomTOFBelt.Outputs.IPosPOWord4,BottomTOFBelt:O.Data[3])","44"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomTOFBelt.Outputs.IPosPOWord5,BottomTOFBelt:O.Data[4])","45"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomTOFBelt.Outputs.IPosPOWord6,BottomTOFBelt:O.Data[5])","46"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomTOFBelt.Outputs.IPosPOWord7,BottomTOFBelt:O.Data[6])","47"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomTOFBelt.Outputs.IPosPOWord8,BottomTOFBelt:O.Data[7])","48"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomTOFBelt.Outputs.IPosPOWord9,BottomTOFBelt:O.Data[8])","49"
RCOMMENT,"DriveDataExchange","BottomTOFBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(BottomTOFBelt.Outputs.IPosPOWord10,BottomTOFBelt:O.Data[9])","50"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll.Inputs.DriveStatusWord.OutputEnabled)","0"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll.Inputs.DriveStatusWord.InverterReady)","1"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll.Inputs.DriveStatusWord.PODataEnabled)","2"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll.Inputs.DriveStatusWord.CurrentRampGenerator)","3"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll.Inputs.DriveStatusWord.CurrentParameterSet)","4"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll.Inputs.DriveStatusWord.FaultWarningPending)","5"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll.Inputs.DriveStatusWord.CWLimitSwitchActive)","6"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll.Inputs.DriveStatusWord.CCWLimitSwitchActive)","7"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll.Inputs.DriveStatusWord.StatusSINT.0)","8"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll.Inputs.DriveStatusWord.StatusSINT.1)","9"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll.Inputs.DriveStatusWord.StatusSINT.2)","10"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll.Inputs.DriveStatusWord.StatusSINT.3)","11"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll.Inputs.DriveStatusWord.StatusSINT.4)","12"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll.Inputs.DriveStatusWord.StatusSINT.5)","13"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll.Inputs.DriveStatusWord.StatusSINT.6)","14"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll.Inputs.DriveStatusWord.StatusSINT.7)","15"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NWhen bit 5 is set, the data in the second half of the status word$Nis the fault.  If bit 5 is not set, the byte is the drive status.$NThis byte is used as a pointer in a list of statuses to display the condition of the drive.$NCheck against limits to prevent array error.$N****","COP(SEWFaults[0],ChutefeedFeedroll.Status.FaultString,1)","16"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,ChutefeedFeedroll.Inputs.ActualSpeed)","17"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,ChutefeedFeedroll.Inputs.OutputCurrent)","18"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,ChutefeedFeedroll.Inputs.IPosPIWord4)","19"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,ChutefeedFeedroll.Inputs.IPosPIWord5)","20"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,ChutefeedFeedroll.Inputs.IPosPIWord6)","21"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,ChutefeedFeedroll.Inputs.IPosPIWord7)","22"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,ChutefeedFeedroll.Inputs.IPosPIWord8)","23"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,ChutefeedFeedroll.Inputs.IPosPIWord9)","24"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,ChutefeedFeedroll.Inputs.IPosPIWord10)","25"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll:O.Data[0].0)","26"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll:O.Data[0].1)","27"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll:O.Data[0].2)","28"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll:O.Data[0].3)","29"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll:O.Data[0].4)","30"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll:O.Data[0].5)","31"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll:O.Data[0].6)","32"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll:O.Data[0].7)","33"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll:O.Data[0].8)","34"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll:O.Data[0].9)","35"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll:O.Data[0].10)","36"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll:O.Data[0].11)","37"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll:O.Data[0].12)","38"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll:O.Data[0].13)","39"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll:O.Data[0].14)","40"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ChutefeedFeedroll:O.Data[0].15)","41"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(ChutefeedFeedroll.Outputs.SetSpeed,ChutefeedFeedroll:O.Data[1])","42"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(ChutefeedFeedroll.Outputs.NoFunction,ChutefeedFeedroll:O.Data[2])","43"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(ChutefeedFeedroll.Outputs.IPosPOWord4,ChutefeedFeedroll:O.Data[3])","44"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(ChutefeedFeedroll.Outputs.IPosPOWord5,ChutefeedFeedroll:O.Data[4])","45"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(ChutefeedFeedroll.Outputs.IPosPOWord6,ChutefeedFeedroll:O.Data[5])","46"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(ChutefeedFeedroll.Outputs.IPosPOWord7,ChutefeedFeedroll:O.Data[6])","47"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(ChutefeedFeedroll.Outputs.IPosPOWord8,ChutefeedFeedroll:O.Data[7])","48"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(ChutefeedFeedroll.Outputs.IPosPOWord9,ChutefeedFeedroll:O.Data[8])","49"
RCOMMENT,"DriveDataExchange","ChutefeedFeedroll","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(ChutefeedFeedroll.Outputs.IPosPOWord10,ChutefeedFeedroll:O.Data[9])","50"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1.Inputs.DriveStatusWord.OutputEnabled)","0"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1.Inputs.DriveStatusWord.InverterReady)","1"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1.Inputs.DriveStatusWord.PODataEnabled)","2"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1.Inputs.DriveStatusWord.CurrentRampGenerator)","3"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1.Inputs.DriveStatusWord.CurrentParameterSet)","4"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1.Inputs.DriveStatusWord.FaultWarningPending)","5"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1.Inputs.DriveStatusWord.CWLimitSwitchActive)","6"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1.Inputs.DriveStatusWord.CCWLimitSwitchActive)","7"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1.Inputs.DriveStatusWord.StatusSINT.0)","8"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1.Inputs.DriveStatusWord.StatusSINT.1)","9"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1.Inputs.DriveStatusWord.StatusSINT.2)","10"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1.Inputs.DriveStatusWord.StatusSINT.3)","11"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1.Inputs.DriveStatusWord.StatusSINT.4)","12"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1.Inputs.DriveStatusWord.StatusSINT.5)","13"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1.Inputs.DriveStatusWord.StatusSINT.6)","14"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1.Inputs.DriveStatusWord.StatusSINT.7)","15"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NWhen bit 5 is set, the data in the second half of the status word$Nis the fault.  If bit 5 is not set, the byte is the drive status.$NThis byte is used as a pointer in a list of statuses to display the condition of the drive.$NCheck against limits to prevent array error.$N****","COP(SEWFaults[0],DrafterGroup1.Status.FaultString,1)","16"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup1.Inputs.ActualSpeed)","17"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup1.Inputs.OutputCurrent)","18"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup1.Inputs.IPosPIWord4)","19"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup1.Inputs.IPosPIWord5)","20"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup1.Inputs.IPosPIWord6)","21"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup1.Inputs.IPosPIWord7)","22"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup1.Inputs.IPosPIWord8)","23"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup1.Inputs.IPosPIWord9)","24"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup1.Inputs.IPosPIWord10)","25"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1:O.Data[0].0)","26"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1:O.Data[0].1)","27"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1:O.Data[0].2)","28"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1:O.Data[0].3)","29"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1:O.Data[0].4)","30"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1:O.Data[0].5)","31"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1:O.Data[0].6)","32"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1:O.Data[0].7)","33"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1:O.Data[0].8)","34"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1:O.Data[0].9)","35"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1:O.Data[0].10)","36"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1:O.Data[0].11)","37"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1:O.Data[0].12)","38"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1:O.Data[0].13)","39"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1:O.Data[0].14)","40"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup1:O.Data[0].15)","41"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup1.Outputs.SetSpeed,DrafterGroup1:O.Data[1])","42"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup1.Outputs.NoFunction,DrafterGroup1:O.Data[2])","43"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup1.Outputs.IPosPOWord4,DrafterGroup1:O.Data[3])","44"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup1.Outputs.IPosPOWord5,DrafterGroup1:O.Data[4])","45"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup1.Outputs.IPosPOWord6,DrafterGroup1:O.Data[5])","46"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup1.Outputs.IPosPOWord7,DrafterGroup1:O.Data[6])","47"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup1.Outputs.IPosPOWord8,DrafterGroup1:O.Data[7])","48"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup1.Outputs.IPosPOWord9,DrafterGroup1:O.Data[8])","49"
RCOMMENT,"DriveDataExchange","DrafterGroup1","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup1.Outputs.IPosPOWord10,DrafterGroup1:O.Data[9])","50"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2.Inputs.DriveStatusWord.OutputEnabled)","0"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2.Inputs.DriveStatusWord.InverterReady)","1"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2.Inputs.DriveStatusWord.PODataEnabled)","2"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2.Inputs.DriveStatusWord.CurrentRampGenerator)","3"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2.Inputs.DriveStatusWord.CurrentParameterSet)","4"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2.Inputs.DriveStatusWord.FaultWarningPending)","5"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2.Inputs.DriveStatusWord.CWLimitSwitchActive)","6"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2.Inputs.DriveStatusWord.CCWLimitSwitchActive)","7"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2.Inputs.DriveStatusWord.StatusSINT.0)","8"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2.Inputs.DriveStatusWord.StatusSINT.1)","9"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2.Inputs.DriveStatusWord.StatusSINT.2)","10"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2.Inputs.DriveStatusWord.StatusSINT.3)","11"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2.Inputs.DriveStatusWord.StatusSINT.4)","12"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2.Inputs.DriveStatusWord.StatusSINT.5)","13"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2.Inputs.DriveStatusWord.StatusSINT.6)","14"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2.Inputs.DriveStatusWord.StatusSINT.7)","15"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NWhen bit 5 is set, the data in the second half of the status word$Nis the fault.  If bit 5 is not set, the byte is the drive status.$NThis byte is used as a pointer in a list of statuses to display the condition of the drive.$NCheck against limits to prevent array error.$N****","COP(SEWFaults[0],DrafterGroup2.Status.FaultString,1)","16"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup2.Inputs.ActualSpeed)","17"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup2.Inputs.OutputCurrent)","18"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup2.Inputs.IPosPIWord4)","19"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup2.Inputs.IPosPIWord5)","20"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup2.Inputs.IPosPIWord6)","21"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup2.Inputs.IPosPIWord7)","22"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup2.Inputs.IPosPIWord8)","23"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup2.Inputs.IPosPIWord9)","24"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup2.Inputs.IPosPIWord10)","25"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2:O.Data[0].0)","26"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2:O.Data[0].1)","27"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2:O.Data[0].2)","28"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2:O.Data[0].3)","29"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2:O.Data[0].4)","30"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2:O.Data[0].5)","31"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2:O.Data[0].6)","32"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2:O.Data[0].7)","33"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2:O.Data[0].8)","34"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2:O.Data[0].9)","35"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2:O.Data[0].10)","36"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2:O.Data[0].11)","37"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2:O.Data[0].12)","38"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2:O.Data[0].13)","39"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2:O.Data[0].14)","40"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup2:O.Data[0].15)","41"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup2.Outputs.SetSpeed,DrafterGroup2:O.Data[1])","42"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup2.Outputs.NoFunction,DrafterGroup2:O.Data[2])","43"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup2.Outputs.IPosPOWord4,DrafterGroup2:O.Data[3])","44"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup2.Outputs.IPosPOWord5,DrafterGroup2:O.Data[4])","45"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup2.Outputs.IPosPOWord6,DrafterGroup2:O.Data[5])","46"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup2.Outputs.IPosPOWord7,DrafterGroup2:O.Data[6])","47"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup2.Outputs.IPosPOWord8,DrafterGroup2:O.Data[7])","48"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup2.Outputs.IPosPOWord9,DrafterGroup2:O.Data[8])","49"
RCOMMENT,"DriveDataExchange","DrafterGroup2","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup2.Outputs.IPosPOWord10,DrafterGroup2:O.Data[9])","50"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3.Inputs.DriveStatusWord.OutputEnabled)","0"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3.Inputs.DriveStatusWord.InverterReady)","1"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3.Inputs.DriveStatusWord.PODataEnabled)","2"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3.Inputs.DriveStatusWord.CurrentRampGenerator)","3"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3.Inputs.DriveStatusWord.CurrentParameterSet)","4"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3.Inputs.DriveStatusWord.FaultWarningPending)","5"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3.Inputs.DriveStatusWord.CWLimitSwitchActive)","6"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3.Inputs.DriveStatusWord.CCWLimitSwitchActive)","7"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3.Inputs.DriveStatusWord.StatusSINT.0)","8"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3.Inputs.DriveStatusWord.StatusSINT.1)","9"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3.Inputs.DriveStatusWord.StatusSINT.2)","10"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3.Inputs.DriveStatusWord.StatusSINT.3)","11"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3.Inputs.DriveStatusWord.StatusSINT.4)","12"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3.Inputs.DriveStatusWord.StatusSINT.5)","13"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3.Inputs.DriveStatusWord.StatusSINT.6)","14"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3.Inputs.DriveStatusWord.StatusSINT.7)","15"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NWhen bit 5 is set, the data in the second half of the status word$Nis the fault.  If bit 5 is not set, the byte is the drive status.$NThis byte is used as a pointer in a list of statuses to display the condition of the drive.$NCheck against limits to prevent array error.$N****","COP(SEWFaults[0],DrafterGroup3.Status.FaultString,1)","16"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup3.Inputs.ActualSpeed)","17"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup3.Inputs.OutputCurrent)","18"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup3.Inputs.IPosPIWord4)","19"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup3.Inputs.IPosPIWord5)","20"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup3.Inputs.IPosPIWord6)","21"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup3.Inputs.IPosPIWord7)","22"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup3.Inputs.IPosPIWord8)","23"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup3.Inputs.IPosPIWord9)","24"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup3.Inputs.IPosPIWord10)","25"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3:O.Data[0].0)","26"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3:O.Data[0].1)","27"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3:O.Data[0].2)","28"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3:O.Data[0].3)","29"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3:O.Data[0].4)","30"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3:O.Data[0].5)","31"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3:O.Data[0].6)","32"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3:O.Data[0].7)","33"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3:O.Data[0].8)","34"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3:O.Data[0].9)","35"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3:O.Data[0].10)","36"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3:O.Data[0].11)","37"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3:O.Data[0].12)","38"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3:O.Data[0].13)","39"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3:O.Data[0].14)","40"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup3:O.Data[0].15)","41"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup3.Outputs.SetSpeed,DrafterGroup3:O.Data[1])","42"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup3.Outputs.NoFunction,DrafterGroup3:O.Data[2])","43"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup3.Outputs.IPosPOWord4,DrafterGroup3:O.Data[3])","44"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup3.Outputs.IPosPOWord5,DrafterGroup3:O.Data[4])","45"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup3.Outputs.IPosPOWord6,DrafterGroup3:O.Data[5])","46"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup3.Outputs.IPosPOWord7,DrafterGroup3:O.Data[6])","47"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup3.Outputs.IPosPOWord8,DrafterGroup3:O.Data[7])","48"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup3.Outputs.IPosPOWord9,DrafterGroup3:O.Data[8])","49"
RCOMMENT,"DriveDataExchange","DrafterGroup3","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup3.Outputs.IPosPOWord10,DrafterGroup3:O.Data[9])","50"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4.Inputs.DriveStatusWord.OutputEnabled)","0"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4.Inputs.DriveStatusWord.InverterReady)","1"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4.Inputs.DriveStatusWord.PODataEnabled)","2"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4.Inputs.DriveStatusWord.CurrentRampGenerator)","3"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4.Inputs.DriveStatusWord.CurrentParameterSet)","4"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4.Inputs.DriveStatusWord.FaultWarningPending)","5"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4.Inputs.DriveStatusWord.CWLimitSwitchActive)","6"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4.Inputs.DriveStatusWord.CCWLimitSwitchActive)","7"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4.Inputs.DriveStatusWord.StatusSINT.0)","8"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4.Inputs.DriveStatusWord.StatusSINT.1)","9"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4.Inputs.DriveStatusWord.StatusSINT.2)","10"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4.Inputs.DriveStatusWord.StatusSINT.3)","11"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4.Inputs.DriveStatusWord.StatusSINT.4)","12"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4.Inputs.DriveStatusWord.StatusSINT.5)","13"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4.Inputs.DriveStatusWord.StatusSINT.6)","14"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4.Inputs.DriveStatusWord.StatusSINT.7)","15"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NWhen bit 5 is set, the data in the second half of the status word$Nis the fault.  If bit 5 is not set, the byte is the drive status.$NThis byte is used as a pointer in a list of statuses to display the condition of the drive.$NCheck against limits to prevent array error.$N****","COP(SEWFaults[0],DrafterGroup4.Status.FaultString,1)","16"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup4.Inputs.ActualSpeed)","17"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup4.Inputs.OutputCurrent)","18"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup4.Inputs.IPosPIWord4)","19"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup4.Inputs.IPosPIWord5)","20"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup4.Inputs.IPosPIWord6)","21"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup4.Inputs.IPosPIWord7)","22"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup4.Inputs.IPosPIWord8)","23"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup4.Inputs.IPosPIWord9)","24"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup4.Inputs.IPosPIWord10)","25"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4:O.Data[0].0)","26"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4:O.Data[0].1)","27"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4:O.Data[0].2)","28"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4:O.Data[0].3)","29"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4:O.Data[0].4)","30"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4:O.Data[0].5)","31"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4:O.Data[0].6)","32"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4:O.Data[0].7)","33"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4:O.Data[0].8)","34"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4:O.Data[0].9)","35"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4:O.Data[0].10)","36"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4:O.Data[0].11)","37"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4:O.Data[0].12)","38"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4:O.Data[0].13)","39"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4:O.Data[0].14)","40"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup4:O.Data[0].15)","41"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup4.Outputs.SetSpeed,DrafterGroup4:O.Data[1])","42"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup4.Outputs.NoFunction,DrafterGroup4:O.Data[2])","43"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup4.Outputs.IPosPOWord4,DrafterGroup4:O.Data[3])","44"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup4.Outputs.IPosPOWord5,DrafterGroup4:O.Data[4])","45"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup4.Outputs.IPosPOWord6,DrafterGroup4:O.Data[5])","46"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup4.Outputs.IPosPOWord7,DrafterGroup4:O.Data[6])","47"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup4.Outputs.IPosPOWord8,DrafterGroup4:O.Data[7])","48"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup4.Outputs.IPosPOWord9,DrafterGroup4:O.Data[8])","49"
RCOMMENT,"DriveDataExchange","DrafterGroup4","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup4.Outputs.IPosPOWord10,DrafterGroup4:O.Data[9])","50"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5.Inputs.DriveStatusWord.OutputEnabled)","0"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5.Inputs.DriveStatusWord.InverterReady)","1"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5.Inputs.DriveStatusWord.PODataEnabled)","2"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5.Inputs.DriveStatusWord.CurrentRampGenerator)","3"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5.Inputs.DriveStatusWord.CurrentParameterSet)","4"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5.Inputs.DriveStatusWord.FaultWarningPending)","5"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5.Inputs.DriveStatusWord.CWLimitSwitchActive)","6"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5.Inputs.DriveStatusWord.CCWLimitSwitchActive)","7"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5.Inputs.DriveStatusWord.StatusSINT.0)","8"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5.Inputs.DriveStatusWord.StatusSINT.1)","9"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5.Inputs.DriveStatusWord.StatusSINT.2)","10"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5.Inputs.DriveStatusWord.StatusSINT.3)","11"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5.Inputs.DriveStatusWord.StatusSINT.4)","12"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5.Inputs.DriveStatusWord.StatusSINT.5)","13"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5.Inputs.DriveStatusWord.StatusSINT.6)","14"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5.Inputs.DriveStatusWord.StatusSINT.7)","15"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NWhen bit 5 is set, the data in the second half of the status word$Nis the fault.  If bit 5 is not set, the byte is the drive status.$NThis byte is used as a pointer in a list of statuses to display the condition of the drive.$NCheck against limits to prevent array error.$N****","COP(SEWFaults[0],DrafterGroup5.Status.FaultString,1)","16"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup5.Inputs.ActualSpeed)","17"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup5.Inputs.OutputCurrent)","18"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup5.Inputs.IPosPIWord4)","19"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup5.Inputs.IPosPIWord5)","20"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup5.Inputs.IPosPIWord6)","21"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup5.Inputs.IPosPIWord7)","22"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup5.Inputs.IPosPIWord8)","23"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup5.Inputs.IPosPIWord9)","24"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,DrafterGroup5.Inputs.IPosPIWord10)","25"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5:O.Data[0].0)","26"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5:O.Data[0].1)","27"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5:O.Data[0].2)","28"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5:O.Data[0].3)","29"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5:O.Data[0].4)","30"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5:O.Data[0].5)","31"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5:O.Data[0].6)","32"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5:O.Data[0].7)","33"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5:O.Data[0].8)","34"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5:O.Data[0].9)","35"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5:O.Data[0].10)","36"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5:O.Data[0].11)","37"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5:O.Data[0].12)","38"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5:O.Data[0].13)","39"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5:O.Data[0].14)","40"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(DrafterGroup5:O.Data[0].15)","41"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup5.Outputs.SetSpeed,DrafterGroup5:O.Data[1])","42"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup5.Outputs.NoFunction,DrafterGroup5:O.Data[2])","43"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup5.Outputs.IPosPOWord4,DrafterGroup5:O.Data[3])","44"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup5.Outputs.IPosPOWord5,DrafterGroup5:O.Data[4])","45"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup5.Outputs.IPosPOWord6,DrafterGroup5:O.Data[5])","46"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup5.Outputs.IPosPOWord7,DrafterGroup5:O.Data[6])","47"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup5.Outputs.IPosPOWord8,DrafterGroup5:O.Data[7])","48"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup5.Outputs.IPosPOWord9,DrafterGroup5:O.Data[8])","49"
RCOMMENT,"DriveDataExchange","DrafterGroup5","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(DrafterGroup5.Outputs.IPosPOWord10,DrafterGroup5:O.Data[9])","50"
RCOMMENT,"DriveDataExchange","DriveDataExchangeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Apron,0)","0"
RCOMMENT,"DriveDataExchange","DriveDataExchangeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BottomDoffer,0)","1"
RCOMMENT,"DriveDataExchange","DriveDataExchangeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BottomScrambler,0)","2"
RCOMMENT,"DriveDataExchange","DriveDataExchangeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BottomTakeoff,0)","3"
RCOMMENT,"DriveDataExchange","DriveDataExchangeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BottomTOFBelt,0)","4"
RCOMMENT,"DriveDataExchange","DriveDataExchangeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(ChutefeedFeedroll,0)","5"
RCOMMENT,"DriveDataExchange","DriveDataExchangeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(DrafterGroup1,0)","6"
RCOMMENT,"DriveDataExchange","DriveDataExchangeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(DrafterGroup2,0)","7"
RCOMMENT,"DriveDataExchange","DriveDataExchangeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(DrafterGroup3,0)","8"
RCOMMENT,"DriveDataExchange","DriveDataExchangeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(DrafterGroup4,0)","9"
RCOMMENT,"DriveDataExchange","DriveDataExchangeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(DrafterGroup5,0)","10"
RCOMMENT,"DriveDataExchange","DriveDataExchangeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(FeedRoll,0)","11"
RCOMMENT,"DriveDataExchange","DriveDataExchangeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(MainCylinder,0)","12"
RCOMMENT,"DriveDataExchange","DriveDataExchangeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(ScaleBelt,0)","13"
RCOMMENT,"DriveDataExchange","DriveDataExchangeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(TopDoffer,0)","14"
RCOMMENT,"DriveDataExchange","DriveDataExchangeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(TopScrambler,0)","15"
RCOMMENT,"DriveDataExchange","DriveDataExchangeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(TopTakeoff,0)","16"
RCOMMENT,"DriveDataExchange","DriveDataExchangeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(TopTOFBelt,0)","17"
RCOMMENT,"DriveDataExchange","DriveDataExchangeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(TransportBelt,0)","18"
RCOMMENT,"DriveDataExchange","DriveDataExchangeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Worker,0)","19"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll.Inputs.DriveStatusWord.OutputEnabled)","0"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll.Inputs.DriveStatusWord.InverterReady)","1"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll.Inputs.DriveStatusWord.PODataEnabled)","2"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll.Inputs.DriveStatusWord.CurrentRampGenerator)","3"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll.Inputs.DriveStatusWord.CurrentParameterSet)","4"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll.Inputs.DriveStatusWord.FaultWarningPending)","5"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll.Inputs.DriveStatusWord.CWLimitSwitchActive)","6"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll.Inputs.DriveStatusWord.CCWLimitSwitchActive)","7"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll.Inputs.DriveStatusWord.StatusSINT.0)","8"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll.Inputs.DriveStatusWord.StatusSINT.1)","9"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll.Inputs.DriveStatusWord.StatusSINT.2)","10"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll.Inputs.DriveStatusWord.StatusSINT.3)","11"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll.Inputs.DriveStatusWord.StatusSINT.4)","12"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll.Inputs.DriveStatusWord.StatusSINT.5)","13"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll.Inputs.DriveStatusWord.StatusSINT.6)","14"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll.Inputs.DriveStatusWord.StatusSINT.7)","15"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NWhen bit 5 is set, the data in the second half of the status word$Nis the fault.  If bit 5 is not set, the byte is the drive status.$NThis byte is used as a pointer in a list of statuses to display the condition of the drive.$NCheck against limits to prevent array error.$N****","COP(SEWFaults[0],FeedRoll.Status.FaultString,1)","16"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,FeedRoll.Inputs.ActualSpeed)","17"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,FeedRoll.Inputs.OutputCurrent)","18"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,FeedRoll.Inputs.IPosPIWord4)","19"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,FeedRoll.Inputs.IPosPIWord5)","20"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,FeedRoll.Inputs.IPosPIWord6)","21"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,FeedRoll.Inputs.IPosPIWord7)","22"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,FeedRoll.Inputs.IPosPIWord8)","23"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,FeedRoll.Inputs.IPosPIWord9)","24"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,FeedRoll.Inputs.IPosPIWord10)","25"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll:O.Data[0].0)","26"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll:O.Data[0].1)","27"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll:O.Data[0].2)","28"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll:O.Data[0].3)","29"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll:O.Data[0].4)","30"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll:O.Data[0].5)","31"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll:O.Data[0].6)","32"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll:O.Data[0].7)","33"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll:O.Data[0].8)","34"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll:O.Data[0].9)","35"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll:O.Data[0].10)","36"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll:O.Data[0].11)","37"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll:O.Data[0].12)","38"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll:O.Data[0].13)","39"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll:O.Data[0].14)","40"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(FeedRoll:O.Data[0].15)","41"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(FeedRoll.Outputs.SetSpeed,FeedRoll:O.Data[1])","42"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(FeedRoll.Outputs.NoFunction,FeedRoll:O.Data[2])","43"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(FeedRoll.Outputs.IPosPOWord4,FeedRoll:O.Data[3])","44"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(FeedRoll.Outputs.IPosPOWord5,FeedRoll:O.Data[4])","45"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(FeedRoll.Outputs.IPosPOWord6,FeedRoll:O.Data[5])","46"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(FeedRoll.Outputs.IPosPOWord7,FeedRoll:O.Data[6])","47"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(FeedRoll.Outputs.IPosPOWord8,FeedRoll:O.Data[7])","48"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(FeedRoll.Outputs.IPosPOWord9,FeedRoll:O.Data[8])","49"
RCOMMENT,"DriveDataExchange","FeedRoll","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(FeedRoll.Outputs.IPosPOWord10,FeedRoll:O.Data[9])","50"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder.Inputs.DriveStatusWord.OutputEnabled)","0"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder.Inputs.DriveStatusWord.InverterReady)","1"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder.Inputs.DriveStatusWord.PODataEnabled)","2"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder.Inputs.DriveStatusWord.CurrentRampGenerator)","3"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder.Inputs.DriveStatusWord.CurrentParameterSet)","4"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder.Inputs.DriveStatusWord.FaultWarningPending)","5"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder.Inputs.DriveStatusWord.CWLimitSwitchActive)","6"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder.Inputs.DriveStatusWord.CCWLimitSwitchActive)","7"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder.Inputs.DriveStatusWord.StatusSINT.0)","8"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder.Inputs.DriveStatusWord.StatusSINT.1)","9"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder.Inputs.DriveStatusWord.StatusSINT.2)","10"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder.Inputs.DriveStatusWord.StatusSINT.3)","11"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder.Inputs.DriveStatusWord.StatusSINT.4)","12"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder.Inputs.DriveStatusWord.StatusSINT.5)","13"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder.Inputs.DriveStatusWord.StatusSINT.6)","14"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder.Inputs.DriveStatusWord.StatusSINT.7)","15"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NWhen bit 5 is set, the data in the second half of the status word$Nis the fault.  If bit 5 is not set, the byte is the drive status.$NThis byte is used as a pointer in a list of statuses to display the condition of the drive.$NCheck against limits to prevent array error.$N****","COP(SEWFaults[0],MainCylinder.Status.FaultString,1)","16"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,MainCylinder.Inputs.ActualSpeed)","17"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,MainCylinder.Inputs.OutputCurrent)","18"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,MainCylinder.Inputs.IPosPIWord4)","19"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,MainCylinder.Inputs.IPosPIWord5)","20"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,MainCylinder.Inputs.IPosPIWord6)","21"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,MainCylinder.Inputs.IPosPIWord7)","22"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,MainCylinder.Inputs.IPosPIWord8)","23"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,MainCylinder.Inputs.IPosPIWord9)","24"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,MainCylinder.Inputs.IPosPIWord10)","25"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder:O.Data[0].0)","26"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder:O.Data[0].1)","27"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder:O.Data[0].2)","28"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder:O.Data[0].3)","29"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder:O.Data[0].4)","30"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder:O.Data[0].5)","31"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder:O.Data[0].6)","32"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder:O.Data[0].7)","33"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder:O.Data[0].8)","34"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder:O.Data[0].9)","35"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder:O.Data[0].10)","36"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder:O.Data[0].11)","37"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder:O.Data[0].12)","38"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder:O.Data[0].13)","39"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder:O.Data[0].14)","40"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(MainCylinder:O.Data[0].15)","41"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(MainCylinder.Outputs.SetSpeed,MainCylinder:O.Data[1])","42"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(MainCylinder.Outputs.NoFunction,MainCylinder:O.Data[2])","43"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(MainCylinder.Outputs.IPosPOWord4,MainCylinder:O.Data[3])","44"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(MainCylinder.Outputs.IPosPOWord5,MainCylinder:O.Data[4])","45"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(MainCylinder.Outputs.IPosPOWord6,MainCylinder:O.Data[5])","46"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(MainCylinder.Outputs.IPosPOWord7,MainCylinder:O.Data[6])","47"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(MainCylinder.Outputs.IPosPOWord8,MainCylinder:O.Data[7])","48"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(MainCylinder.Outputs.IPosPOWord9,MainCylinder:O.Data[8])","49"
RCOMMENT,"DriveDataExchange","MainCylinder","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(MainCylinder.Outputs.IPosPOWord10,MainCylinder:O.Data[9])","50"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt.Inputs.DriveStatusWord.OutputEnabled)","0"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt.Inputs.DriveStatusWord.InverterReady)","1"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt.Inputs.DriveStatusWord.PODataEnabled)","2"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt.Inputs.DriveStatusWord.CurrentRampGenerator)","3"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt.Inputs.DriveStatusWord.CurrentParameterSet)","4"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt.Inputs.DriveStatusWord.FaultWarningPending)","5"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt.Inputs.DriveStatusWord.CWLimitSwitchActive)","6"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt.Inputs.DriveStatusWord.CCWLimitSwitchActive)","7"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt.Inputs.DriveStatusWord.StatusSINT.0)","8"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt.Inputs.DriveStatusWord.StatusSINT.1)","9"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt.Inputs.DriveStatusWord.StatusSINT.2)","10"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt.Inputs.DriveStatusWord.StatusSINT.3)","11"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt.Inputs.DriveStatusWord.StatusSINT.4)","12"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt.Inputs.DriveStatusWord.StatusSINT.5)","13"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt.Inputs.DriveStatusWord.StatusSINT.6)","14"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt.Inputs.DriveStatusWord.StatusSINT.7)","15"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NWhen bit 5 is set, the data in the second half of the status word$Nis the fault.  If bit 5 is not set, the byte is the drive status.$NThis byte is used as a pointer in a list of statuses to display the condition of the drive.$NCheck against limits to prevent array error.$N****","COP(SEWFaults[0],ScaleBelt.Status.FaultString,1)","16"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,ScaleBelt.Inputs.ActualSpeed)","17"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,ScaleBelt.Inputs.OutputCurrent)","18"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,ScaleBelt.Inputs.IPosPIWord4)","19"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,ScaleBelt.Inputs.IPosPIWord5)","20"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,ScaleBelt.Inputs.IPosPIWord6)","21"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,ScaleBelt.Inputs.IPosPIWord7)","22"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,ScaleBelt.Inputs.IPosPIWord8)","23"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,ScaleBelt.Inputs.IPosPIWord9)","24"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,ScaleBelt.Inputs.IPosPIWord10)","25"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt:O.Data[0].0)","26"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt:O.Data[0].1)","27"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt:O.Data[0].2)","28"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt:O.Data[0].3)","29"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt:O.Data[0].4)","30"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt:O.Data[0].5)","31"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt:O.Data[0].6)","32"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt:O.Data[0].7)","33"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt:O.Data[0].8)","34"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt:O.Data[0].9)","35"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt:O.Data[0].10)","36"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt:O.Data[0].11)","37"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt:O.Data[0].12)","38"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt:O.Data[0].13)","39"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt:O.Data[0].14)","40"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(ScaleBelt:O.Data[0].15)","41"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(ScaleBelt.Outputs.SetSpeed,ScaleBelt:O.Data[1])","42"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(ScaleBelt.Outputs.NoFunction,ScaleBelt:O.Data[2])","43"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(ScaleBelt.Outputs.IPosPOWord4,ScaleBelt:O.Data[3])","44"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(ScaleBelt.Outputs.IPosPOWord5,ScaleBelt:O.Data[4])","45"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(ScaleBelt.Outputs.IPosPOWord6,ScaleBelt:O.Data[5])","46"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(ScaleBelt.Outputs.IPosPOWord7,ScaleBelt:O.Data[6])","47"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(ScaleBelt.Outputs.IPosPOWord8,ScaleBelt:O.Data[7])","48"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(ScaleBelt.Outputs.IPosPOWord9,ScaleBelt:O.Data[8])","49"
RCOMMENT,"DriveDataExchange","ScaleBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(ScaleBelt.Outputs.IPosPOWord10,ScaleBelt:O.Data[9])","50"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer.Inputs.DriveStatusWord.OutputEnabled)","0"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer.Inputs.DriveStatusWord.InverterReady)","1"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer.Inputs.DriveStatusWord.PODataEnabled)","2"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer.Inputs.DriveStatusWord.CurrentRampGenerator)","3"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer.Inputs.DriveStatusWord.CurrentParameterSet)","4"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer.Inputs.DriveStatusWord.FaultWarningPending)","5"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer.Inputs.DriveStatusWord.CWLimitSwitchActive)","6"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer.Inputs.DriveStatusWord.CCWLimitSwitchActive)","7"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer.Inputs.DriveStatusWord.StatusSINT.0)","8"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer.Inputs.DriveStatusWord.StatusSINT.1)","9"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer.Inputs.DriveStatusWord.StatusSINT.2)","10"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer.Inputs.DriveStatusWord.StatusSINT.3)","11"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer.Inputs.DriveStatusWord.StatusSINT.4)","12"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer.Inputs.DriveStatusWord.StatusSINT.5)","13"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer.Inputs.DriveStatusWord.StatusSINT.6)","14"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer.Inputs.DriveStatusWord.StatusSINT.7)","15"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NWhen bit 5 is set, the data in the second half of the status word$Nis the fault.  If bit 5 is not set, the byte is the drive status.$NThis byte is used as a pointer in a list of statuses to display the condition of the drive.$NCheck against limits to prevent array error.$N****","COP(SEWFaults[0],TopDoffer.Status.FaultString,1)","16"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopDoffer.Inputs.ActualSpeed)","17"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopDoffer.Inputs.OutputCurrent)","18"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopDoffer.Inputs.IPosPIWord4)","19"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopDoffer.Inputs.IPosPIWord5)","20"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopDoffer.Inputs.IPosPIWord6)","21"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopDoffer.Inputs.IPosPIWord7)","22"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopDoffer.Inputs.IPosPIWord8)","23"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopDoffer.Inputs.IPosPIWord9)","24"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopDoffer.Inputs.IPosPIWord10)","25"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer:O.Data[0].0)","26"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer:O.Data[0].1)","27"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer:O.Data[0].2)","28"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer:O.Data[0].3)","29"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer:O.Data[0].4)","30"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer:O.Data[0].5)","31"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer:O.Data[0].6)","32"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer:O.Data[0].7)","33"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer:O.Data[0].8)","34"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer:O.Data[0].9)","35"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer:O.Data[0].10)","36"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer:O.Data[0].11)","37"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer:O.Data[0].12)","38"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer:O.Data[0].13)","39"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer:O.Data[0].14)","40"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopDoffer:O.Data[0].15)","41"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopDoffer.Outputs.SetSpeed,TopDoffer:O.Data[1])","42"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopDoffer.Outputs.NoFunction,TopDoffer:O.Data[2])","43"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopDoffer.Outputs.IPosPOWord4,TopDoffer:O.Data[3])","44"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopDoffer.Outputs.IPosPOWord5,TopDoffer:O.Data[4])","45"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopDoffer.Outputs.IPosPOWord6,TopDoffer:O.Data[5])","46"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopDoffer.Outputs.IPosPOWord7,TopDoffer:O.Data[6])","47"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopDoffer.Outputs.IPosPOWord8,TopDoffer:O.Data[7])","48"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopDoffer.Outputs.IPosPOWord9,TopDoffer:O.Data[8])","49"
RCOMMENT,"DriveDataExchange","TopDoffer","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopDoffer.Outputs.IPosPOWord10,TopDoffer:O.Data[9])","50"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler.Inputs.DriveStatusWord.OutputEnabled)","0"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler.Inputs.DriveStatusWord.InverterReady)","1"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler.Inputs.DriveStatusWord.PODataEnabled)","2"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler.Inputs.DriveStatusWord.CurrentRampGenerator)","3"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler.Inputs.DriveStatusWord.CurrentParameterSet)","4"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler.Inputs.DriveStatusWord.FaultWarningPending)","5"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler.Inputs.DriveStatusWord.CWLimitSwitchActive)","6"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler.Inputs.DriveStatusWord.CCWLimitSwitchActive)","7"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler.Inputs.DriveStatusWord.StatusSINT.0)","8"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler.Inputs.DriveStatusWord.StatusSINT.1)","9"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler.Inputs.DriveStatusWord.StatusSINT.2)","10"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler.Inputs.DriveStatusWord.StatusSINT.3)","11"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler.Inputs.DriveStatusWord.StatusSINT.4)","12"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler.Inputs.DriveStatusWord.StatusSINT.5)","13"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler.Inputs.DriveStatusWord.StatusSINT.6)","14"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler.Inputs.DriveStatusWord.StatusSINT.7)","15"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NWhen bit 5 is set, the data in the second half of the status word$Nis the fault.  If bit 5 is not set, the byte is the drive status.$NThis byte is used as a pointer in a list of statuses to display the condition of the drive.$NCheck against limits to prevent array error.$N****","COP(SEWFaults[0],TopScrambler.Status.FaultString,1)","16"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopScrambler.Inputs.ActualSpeed)","17"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopScrambler.Inputs.OutputCurrent)","18"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopScrambler.Inputs.IPosPIWord4)","19"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopScrambler.Inputs.IPosPIWord5)","20"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopScrambler.Inputs.IPosPIWord6)","21"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopScrambler.Inputs.IPosPIWord7)","22"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopScrambler.Inputs.IPosPIWord8)","23"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopScrambler.Inputs.IPosPIWord9)","24"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopScrambler.Inputs.IPosPIWord10)","25"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler:O.Data[0].0)","26"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler:O.Data[0].1)","27"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler:O.Data[0].2)","28"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler:O.Data[0].3)","29"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler:O.Data[0].4)","30"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler:O.Data[0].5)","31"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler:O.Data[0].6)","32"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler:O.Data[0].7)","33"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler:O.Data[0].8)","34"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler:O.Data[0].9)","35"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler:O.Data[0].10)","36"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler:O.Data[0].11)","37"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler:O.Data[0].12)","38"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler:O.Data[0].13)","39"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler:O.Data[0].14)","40"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopScrambler:O.Data[0].15)","41"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopScrambler.Outputs.SetSpeed,TopScrambler:O.Data[1])","42"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopScrambler.Outputs.NoFunction,TopScrambler:O.Data[2])","43"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopScrambler.Outputs.IPosPOWord4,TopScrambler:O.Data[3])","44"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopScrambler.Outputs.IPosPOWord5,TopScrambler:O.Data[4])","45"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopScrambler.Outputs.IPosPOWord6,TopScrambler:O.Data[5])","46"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopScrambler.Outputs.IPosPOWord7,TopScrambler:O.Data[6])","47"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopScrambler.Outputs.IPosPOWord8,TopScrambler:O.Data[7])","48"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopScrambler.Outputs.IPosPOWord9,TopScrambler:O.Data[8])","49"
RCOMMENT,"DriveDataExchange","TopScrambler","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopScrambler.Outputs.IPosPOWord10,TopScrambler:O.Data[9])","50"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff.Inputs.DriveStatusWord.OutputEnabled)","0"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff.Inputs.DriveStatusWord.InverterReady)","1"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff.Inputs.DriveStatusWord.PODataEnabled)","2"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff.Inputs.DriveStatusWord.CurrentRampGenerator)","3"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff.Inputs.DriveStatusWord.CurrentParameterSet)","4"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff.Inputs.DriveStatusWord.FaultWarningPending)","5"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff.Inputs.DriveStatusWord.CWLimitSwitchActive)","6"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff.Inputs.DriveStatusWord.CCWLimitSwitchActive)","7"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff.Inputs.DriveStatusWord.StatusSINT.0)","8"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff.Inputs.DriveStatusWord.StatusSINT.1)","9"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff.Inputs.DriveStatusWord.StatusSINT.2)","10"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff.Inputs.DriveStatusWord.StatusSINT.3)","11"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff.Inputs.DriveStatusWord.StatusSINT.4)","12"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff.Inputs.DriveStatusWord.StatusSINT.5)","13"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff.Inputs.DriveStatusWord.StatusSINT.6)","14"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff.Inputs.DriveStatusWord.StatusSINT.7)","15"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NWhen bit 5 is set, the data in the second half of the status word$Nis the fault.  If bit 5 is not set, the byte is the drive status.$NThis byte is used as a pointer in a list of statuses to display the condition of the drive.$NCheck against limits to prevent array error.$N****","COP(SEWFaults[0],TopTakeoff.Status.FaultString,1)","16"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopTakeoff.Inputs.ActualSpeed)","17"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopTakeoff.Inputs.OutputCurrent)","18"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopTakeoff.Inputs.IPosPIWord4)","19"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopTakeoff.Inputs.IPosPIWord5)","20"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopTakeoff.Inputs.IPosPIWord6)","21"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopTakeoff.Inputs.IPosPIWord7)","22"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopTakeoff.Inputs.IPosPIWord8)","23"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopTakeoff.Inputs.IPosPIWord9)","24"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopTakeoff.Inputs.IPosPIWord10)","25"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff:O.Data[0].0)","26"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff:O.Data[0].1)","27"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff:O.Data[0].2)","28"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff:O.Data[0].3)","29"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff:O.Data[0].4)","30"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff:O.Data[0].5)","31"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff:O.Data[0].6)","32"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff:O.Data[0].7)","33"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff:O.Data[0].8)","34"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff:O.Data[0].9)","35"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff:O.Data[0].10)","36"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff:O.Data[0].11)","37"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff:O.Data[0].12)","38"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff:O.Data[0].13)","39"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff:O.Data[0].14)","40"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTakeoff:O.Data[0].15)","41"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopTakeoff.Outputs.SetSpeed,TopTakeoff:O.Data[1])","42"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopTakeoff.Outputs.NoFunction,TopTakeoff:O.Data[2])","43"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopTakeoff.Outputs.IPosPOWord4,TopTakeoff:O.Data[3])","44"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopTakeoff.Outputs.IPosPOWord5,TopTakeoff:O.Data[4])","45"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopTakeoff.Outputs.IPosPOWord6,TopTakeoff:O.Data[5])","46"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopTakeoff.Outputs.IPosPOWord7,TopTakeoff:O.Data[6])","47"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopTakeoff.Outputs.IPosPOWord8,TopTakeoff:O.Data[7])","48"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopTakeoff.Outputs.IPosPOWord9,TopTakeoff:O.Data[8])","49"
RCOMMENT,"DriveDataExchange","TopTakeoff","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopTakeoff.Outputs.IPosPOWord10,TopTakeoff:O.Data[9])","50"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt.Inputs.DriveStatusWord.OutputEnabled)","0"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt.Inputs.DriveStatusWord.InverterReady)","1"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt.Inputs.DriveStatusWord.PODataEnabled)","2"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt.Inputs.DriveStatusWord.CurrentRampGenerator)","3"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt.Inputs.DriveStatusWord.CurrentParameterSet)","4"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt.Inputs.DriveStatusWord.FaultWarningPending)","5"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt.Inputs.DriveStatusWord.CWLimitSwitchActive)","6"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt.Inputs.DriveStatusWord.CCWLimitSwitchActive)","7"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt.Inputs.DriveStatusWord.StatusSINT.0)","8"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt.Inputs.DriveStatusWord.StatusSINT.1)","9"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt.Inputs.DriveStatusWord.StatusSINT.2)","10"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt.Inputs.DriveStatusWord.StatusSINT.3)","11"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt.Inputs.DriveStatusWord.StatusSINT.4)","12"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt.Inputs.DriveStatusWord.StatusSINT.5)","13"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt.Inputs.DriveStatusWord.StatusSINT.6)","14"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt.Inputs.DriveStatusWord.StatusSINT.7)","15"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NWhen bit 5 is set, the data in the second half of the status word$Nis the fault.  If bit 5 is not set, the byte is the drive status.$NThis byte is used as a pointer in a list of statuses to display the condition of the drive.$NCheck against limits to prevent array error.$N****","COP(SEWFaults[0],TopTOFBelt.Status.FaultString,1)","16"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopTOFBelt.Inputs.ActualSpeed)","17"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopTOFBelt.Inputs.OutputCurrent)","18"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopTOFBelt.Inputs.IPosPIWord4)","19"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopTOFBelt.Inputs.IPosPIWord5)","20"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopTOFBelt.Inputs.IPosPIWord6)","21"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopTOFBelt.Inputs.IPosPIWord7)","22"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopTOFBelt.Inputs.IPosPIWord8)","23"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopTOFBelt.Inputs.IPosPIWord9)","24"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TopTOFBelt.Inputs.IPosPIWord10)","25"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt:O.Data[0].0)","26"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt:O.Data[0].1)","27"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt:O.Data[0].2)","28"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt:O.Data[0].3)","29"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt:O.Data[0].4)","30"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt:O.Data[0].5)","31"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt:O.Data[0].6)","32"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt:O.Data[0].7)","33"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt:O.Data[0].8)","34"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt:O.Data[0].9)","35"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt:O.Data[0].10)","36"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt:O.Data[0].11)","37"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt:O.Data[0].12)","38"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt:O.Data[0].13)","39"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt:O.Data[0].14)","40"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TopTOFBelt:O.Data[0].15)","41"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopTOFBelt.Outputs.SetSpeed,TopTOFBelt:O.Data[1])","42"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopTOFBelt.Outputs.NoFunction,TopTOFBelt:O.Data[2])","43"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopTOFBelt.Outputs.IPosPOWord4,TopTOFBelt:O.Data[3])","44"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopTOFBelt.Outputs.IPosPOWord5,TopTOFBelt:O.Data[4])","45"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopTOFBelt.Outputs.IPosPOWord6,TopTOFBelt:O.Data[5])","46"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopTOFBelt.Outputs.IPosPOWord7,TopTOFBelt:O.Data[6])","47"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopTOFBelt.Outputs.IPosPOWord8,TopTOFBelt:O.Data[7])","48"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopTOFBelt.Outputs.IPosPOWord9,TopTOFBelt:O.Data[8])","49"
RCOMMENT,"DriveDataExchange","TopTOFBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TopTOFBelt.Outputs.IPosPOWord10,TopTOFBelt:O.Data[9])","50"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt.Inputs.DriveStatusWord.OutputEnabled)","0"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt.Inputs.DriveStatusWord.InverterReady)","1"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt.Inputs.DriveStatusWord.PODataEnabled)","2"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt.Inputs.DriveStatusWord.CurrentRampGenerator)","3"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt.Inputs.DriveStatusWord.CurrentParameterSet)","4"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt.Inputs.DriveStatusWord.FaultWarningPending)","5"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt.Inputs.DriveStatusWord.CWLimitSwitchActive)","6"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt.Inputs.DriveStatusWord.CCWLimitSwitchActive)","7"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt.Inputs.DriveStatusWord.StatusSINT.0)","8"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt.Inputs.DriveStatusWord.StatusSINT.1)","9"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt.Inputs.DriveStatusWord.StatusSINT.2)","10"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt.Inputs.DriveStatusWord.StatusSINT.3)","11"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt.Inputs.DriveStatusWord.StatusSINT.4)","12"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt.Inputs.DriveStatusWord.StatusSINT.5)","13"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt.Inputs.DriveStatusWord.StatusSINT.6)","14"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt.Inputs.DriveStatusWord.StatusSINT.7)","15"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NWhen bit 5 is set, the data in the second half of the status word$Nis the fault.  If bit 5 is not set, the byte is the drive status.$NThis byte is used as a pointer in a list of statuses to display the condition of the drive.$NCheck against limits to prevent array error.$N****","COP(SEWFaults[0],TransportBelt.Status.FaultString,1)","16"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TransportBelt.Inputs.ActualSpeed)","17"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TransportBelt.Inputs.OutputCurrent)","18"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TransportBelt.Inputs.IPosPIWord4)","19"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TransportBelt.Inputs.IPosPIWord5)","20"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TransportBelt.Inputs.IPosPIWord6)","21"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TransportBelt.Inputs.IPosPIWord7)","22"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TransportBelt.Inputs.IPosPIWord8)","23"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TransportBelt.Inputs.IPosPIWord9)","24"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,TransportBelt.Inputs.IPosPIWord10)","25"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt:O.Data[0].0)","26"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt:O.Data[0].1)","27"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt:O.Data[0].2)","28"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt:O.Data[0].3)","29"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt:O.Data[0].4)","30"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt:O.Data[0].5)","31"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt:O.Data[0].6)","32"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt:O.Data[0].7)","33"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt:O.Data[0].8)","34"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt:O.Data[0].9)","35"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt:O.Data[0].10)","36"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt:O.Data[0].11)","37"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt:O.Data[0].12)","38"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt:O.Data[0].13)","39"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt:O.Data[0].14)","40"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(TransportBelt:O.Data[0].15)","41"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TransportBelt.Outputs.SetSpeed,TransportBelt:O.Data[1])","42"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TransportBelt.Outputs.NoFunction,TransportBelt:O.Data[2])","43"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TransportBelt.Outputs.IPosPOWord4,TransportBelt:O.Data[3])","44"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TransportBelt.Outputs.IPosPOWord5,TransportBelt:O.Data[4])","45"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TransportBelt.Outputs.IPosPOWord6,TransportBelt:O.Data[5])","46"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TransportBelt.Outputs.IPosPOWord7,TransportBelt:O.Data[6])","47"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TransportBelt.Outputs.IPosPOWord8,TransportBelt:O.Data[7])","48"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TransportBelt.Outputs.IPosPOWord9,TransportBelt:O.Data[8])","49"
RCOMMENT,"DriveDataExchange","TransportBelt","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(TransportBelt.Outputs.IPosPOWord10,TransportBelt:O.Data[9])","50"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker.Inputs.DriveStatusWord.OutputEnabled)","0"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker.Inputs.DriveStatusWord.InverterReady)","1"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker.Inputs.DriveStatusWord.PODataEnabled)","2"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker.Inputs.DriveStatusWord.CurrentRampGenerator)","3"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker.Inputs.DriveStatusWord.CurrentParameterSet)","4"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker.Inputs.DriveStatusWord.FaultWarningPending)","5"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker.Inputs.DriveStatusWord.CWLimitSwitchActive)","6"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker.Inputs.DriveStatusWord.CCWLimitSwitchActive)","7"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker.Inputs.DriveStatusWord.StatusSINT.0)","8"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker.Inputs.DriveStatusWord.StatusSINT.1)","9"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker.Inputs.DriveStatusWord.StatusSINT.2)","10"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker.Inputs.DriveStatusWord.StatusSINT.3)","11"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker.Inputs.DriveStatusWord.StatusSINT.4)","12"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker.Inputs.DriveStatusWord.StatusSINT.5)","13"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker.Inputs.DriveStatusWord.StatusSINT.6)","14"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bit read from the drive is moved into a bit of the status word.  This status word is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker.Inputs.DriveStatusWord.StatusSINT.7)","15"
RCOMMENT,"DriveDataExchange","Worker","****$NWhen bit 5 is set, the data in the second half of the status word$Nis the fault.  If bit 5 is not set, the byte is the drive status.$NThis byte is used as a pointer in a list of statuses to display the condition of the drive.$NCheck against limits to prevent array error.$N****","COP(SEWFaults[0],Worker.Status.FaultString,1)","16"
RCOMMENT,"DriveDataExchange","Worker","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,Worker.Inputs.ActualSpeed)","17"
RCOMMENT,"DriveDataExchange","Worker","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,Worker.Inputs.OutputCurrent)","18"
RCOMMENT,"DriveDataExchange","Worker","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,Worker.Inputs.IPosPIWord4)","19"
RCOMMENT,"DriveDataExchange","Worker","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,Worker.Inputs.IPosPIWord5)","20"
RCOMMENT,"DriveDataExchange","Worker","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,Worker.Inputs.IPosPIWord6)","21"
RCOMMENT,"DriveDataExchange","Worker","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,Worker.Inputs.IPosPIWord7)","22"
RCOMMENT,"DriveDataExchange","Worker","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,Worker.Inputs.IPosPIWord8)","23"
RCOMMENT,"DriveDataExchange","Worker","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,Worker.Inputs.IPosPIWord9)","24"
RCOMMENT,"DriveDataExchange","Worker","****$NThe register read from the drive is moved into a register of the $Qinputs$Q data type.  This data type  is structured$Nto mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(0,Worker.Inputs.IPosPIWord10)","25"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker:O.Data[0].0)","26"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker:O.Data[0].1)","27"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker:O.Data[0].2)","28"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker:O.Data[0].3)","29"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker:O.Data[0].4)","30"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker:O.Data[0].5)","31"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker:O.Data[0].6)","32"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker:O.Data[0].7)","33"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker:O.Data[0].8)","34"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker:O.Data[0].9)","35"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker:O.Data[0].10)","36"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker:O.Data[0].11)","37"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker:O.Data[0].12)","38"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker:O.Data[0].13)","39"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker:O.Data[0].14)","40"
RCOMMENT,"DriveDataExchange","Worker","****$NThe bits used in the program are sent to the drive here.  This control word$Nis set up to mirror the control word for Instance for the SEW DFE33B Ethernet card.$N****","OTE(Worker:O.Data[0].15)","41"
RCOMMENT,"DriveDataExchange","Worker","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(Worker.Outputs.SetSpeed,Worker:O.Data[1])","42"
RCOMMENT,"DriveDataExchange","Worker","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(Worker.Outputs.NoFunction,Worker:O.Data[2])","43"
RCOMMENT,"DriveDataExchange","Worker","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(Worker.Outputs.IPosPOWord4,Worker:O.Data[3])","44"
RCOMMENT,"DriveDataExchange","Worker","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(Worker.Outputs.IPosPOWord5,Worker:O.Data[4])","45"
RCOMMENT,"DriveDataExchange","Worker","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(Worker.Outputs.IPosPOWord6,Worker:O.Data[5])","46"
RCOMMENT,"DriveDataExchange","Worker","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(Worker.Outputs.IPosPOWord7,Worker:O.Data[6])","47"
RCOMMENT,"DriveDataExchange","Worker","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(Worker.Outputs.IPosPOWord8,Worker:O.Data[7])","48"
RCOMMENT,"DriveDataExchange","Worker","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(Worker.Outputs.IPosPOWord9,Worker:O.Data[8])","49"
RCOMMENT,"DriveDataExchange","Worker","****$NThe registers used in the program are sent to the drive here.  These values$Nare set up to mirror the Instance for the SEW DFE33B Ethernet card.$N****","MOV(Worker.Outputs.IPosPOWord10,Worker:O.Data[9])","50"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"FS51","FOFeedroll","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(FOFeedroll.Internal.Permissive)","0"
RCOMMENT,"FS51","FOFeedroll","****$NJog Command$N****","OTE(FOFeedroll.Internal.IntermediateJog)","1"
RCOMMENT,"FS51","FOFeedroll","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(FOFeedroll.Internal.DriveReverse)","2"
RCOMMENT,"FS51","FOFeedroll","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(FOFeedroll.Internal.MaintModeRun)","3"
RCOMMENT,"FS51","FOFeedroll","****$NAutomatic control.  The TON is dalay for start while the TOF is $Nthe delay for stop.$N****","OTE(FOFeedroll.Internal.AutoModeRun)","4"
RCOMMENT,"FS51","FOFeedroll","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(FOFeedroll.Internal.ReleaseRamp)","5"
RCOMMENT,"FS51","FOFeedroll","****$NThe commanded speed is calculated based on speed setpoint$Nmultiplied by the line speed (in percent).  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are based on the line speed accel and decel.$NThese should always be less so than the line speed$'s so the drives will follow the line ramp.$N****","MOV(FOFeedroll.Internal.DecelTime,FOFeedroll.Internal.DecelTime)","6"
RCOMMENT,"FS51","FOFeedroll","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(FOFeedroll.Internal.SpeedReference.ScaledOutput,FOFeedroll:O.FreqCommand)","7"
RCOMMENT,"FS51","FOFeedroll","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(FOFeedroll:O.Start)","8"
RCOMMENT,"FS51","FOFeedroll","****$NIf the drive is not being told to start, it should$Nbe being told to stop.$N****","OTE(FOFeedroll:O.Stop)","9"
RCOMMENT,"FS51","FOFeedroll","****$NTo Reverse the drive, send the reverse bit along with the start bit.  Seal$Nit in until the drive stops.$N****","OTE(FOFeedroll:O.Reverse)","10"
RCOMMENT,"FS51","FOFeedroll","****$NIf not reverse, then forward.$N****","OTE(FOFeedroll:O.Forward)","11"
RCOMMENT,"FS51","FOFeedroll","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(FOFeedroll.Internal.ActualSpeedScaler.ScaledOutput,FOFeedroll.Status.ActualSpeed)","12"
RCOMMENT,"FS51","FOFeedroll","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(FOFeedroll.Internal.LoadScaler.ScaledOutput,FOFeedroll.Status.MotorLoad)","13"
RCOMMENT,"FS51","FOFeedroll","****$NDrive Running Status$N****","OTE(FOFeedroll.Status.Running)","14"
RCOMMENT,"FS51","FOFeedroll","****$NJogging Forward Status$N****","OTE(FOFeedroll.Status.JoggingFwd)","15"
RCOMMENT,"FS51","FOFeedroll","****$NJogging Reverse Status$N****","OTE(FOFeedroll.Status.JoggingRev)","16"
RCOMMENT,"FS51","FOFeedroll","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(FOFeedroll.Status.FailedToStart)","17"
RCOMMENT,"FS51","FOFeedroll","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(FOFeedroll.Status.FailedToStop)","18"
RCOMMENT,"FS51","FOFeedroll","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(FOFeedroll.Status.Faulted)","19"
RCOMMENT,"FS51","FOFeedroll","****$NUnlatch the Drive Faulted Status$N****","OTU(FOFeedroll.Status.FailedToStop)","20"
RCOMMENT,"FS51","FOOutfeedFan","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(FOOutfeedFan.Internal.Permissive)","0"
RCOMMENT,"FS51","FOOutfeedFan","****$NJog Command$N****","OTE(FOOutfeedFan.Internal.IntermediateJog)","1"
RCOMMENT,"FS51","FOOutfeedFan","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(FOOutfeedFan.Internal.DriveReverse)","2"
RCOMMENT,"FS51","FOOutfeedFan","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(FOOutfeedFan.Internal.MaintModeRun)","3"
RCOMMENT,"FS51","FOOutfeedFan","****$NAutomatic control.  The TON is dalay for start while the TOF is $Nthe delay for stop.$N****","OTE(FOOutfeedFan.Internal.AutoModeRun)","4"
RCOMMENT,"FS51","FOOutfeedFan","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(FOOutfeedFan.Internal.ReleaseRamp)","5"
RCOMMENT,"FS51","FOOutfeedFan","****$NThe commanded speed is calculated based on speed setpoint$Nmultiplied by the line speed (in percent).  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are based on the line speed accel and decel.$NThese should always be less so than the line speed$'s so the drives will follow the line ramp.$N****","MOV(FOOutfeedFan.Internal.DecelTime,FOOutfeedFan.Internal.DecelTime)","6"
RCOMMENT,"FS51","FOOutfeedFan","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(FOOutfeedFan.Internal.SpeedReference.ScaledOutput,FOOutfeedFan:O.FreqCommand)","7"
RCOMMENT,"FS51","FOOutfeedFan","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(FOOutfeedFan:O.Start)","8"
RCOMMENT,"FS51","FOOutfeedFan","****$NIf the drive is not being told to start, it should$Nbe being told to stop.$N****","OTE(FOOutfeedFan:O.Stop)","9"
RCOMMENT,"FS51","FOOutfeedFan","****$NTo Reverse the drive, send the reverse bit along with the start bit.  Seal$Nit in until the drive stops.$N****","OTE(FOOutfeedFan:O.Reverse)","10"
RCOMMENT,"FS51","FOOutfeedFan","****$NIf not reverse, then forward.$N****","OTE(FOOutfeedFan:O.Forward)","11"
RCOMMENT,"FS51","FOOutfeedFan","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(FOOutfeedFan.Internal.ActualSpeedScaler.ScaledOutput,FOOutfeedFan.Status.ActualSpeed)","12"
RCOMMENT,"FS51","FOOutfeedFan","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(FOOutfeedFan.Internal.LoadScaler.ScaledOutput,FOOutfeedFan.Status.MotorLoad)","13"
RCOMMENT,"FS51","FOOutfeedFan","****$NDrive Running Status$N****","OTE(FOOutfeedFan.Status.Running)","14"
RCOMMENT,"FS51","FOOutfeedFan","****$NJogging Forward Status$N****","OTE(FOOutfeedFan.Status.JoggingFwd)","15"
RCOMMENT,"FS51","FOOutfeedFan","****$NJogging Reverse Status$N****","OTE(FOOutfeedFan.Status.JoggingRev)","16"
RCOMMENT,"FS51","FOOutfeedFan","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(FOOutfeedFan.Status.FailedToStart)","17"
RCOMMENT,"FS51","FOOutfeedFan","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(FOOutfeedFan.Status.FailedToStop)","18"
RCOMMENT,"FS51","FOOutfeedFan","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(FOOutfeedFan.Status.Faulted)","19"
RCOMMENT,"FS51","FOOutfeedFan","****$NUnlatch the Drive Faulted Status$N****","OTU(FOOutfeedFan.Status.FailedToStop)","20"
RCOMMENT,"FS51","FS51Beater","****$NPermissive to operate the motor.$N****","OTE(FS51Beater.Internal.Permissive)","0"
RCOMMENT,"FS51","FS51Beater","****$NManual Run Control$N****","OTE(FS51Beater.Internal.IntermediateRunForward)","1"
RCOMMENT,"FS51","FS51Beater","****$NManual Jog Control$N****","OTE(FS51Beater.Internal.IntermediateJogForward)","2"
RCOMMENT,"FS51","FS51Beater","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(FS51Beater.Internal.AutoOffDelayTimer,?,?)","3"
RCOMMENT,"FS51","FS51Beater","****$NMotor Starter Control$N****","OTE(FS51BeaterCont)","4"
RCOMMENT,"FS51","FS51Beater","****$NRunning Status$N****","OTE(FS51Beater.Status.RunningForward)","5"
RCOMMENT,"FS51","FS51Beater","****$NIf the motor does not start when commanded, it has failed to run$N****","OTL(FS51Beater.Status.FailedToStart)","6"
RCOMMENT,"FS51","FS51Beater","****$NIf a motor continues to run when the run command has been removed,$Nit has failed to stop.$N****$N","OTL(FS51Beater.Status.FailedToStop)","7"
RCOMMENT,"FS51","FS51Beater","****$NGeneral Faulted Status$N****","OTE(FS51Beater.Status.Faulted)","8"
RCOMMENT,"FS51","FS51Beater","****$NReset Fault Latches$N****","OTU(FS51Beater.Status.FailedToStop)","9"
RCOMMENT,"FS51","FS51Control","****$NThe input is used to trigger two timers for debounce.  The resulting state$Nwill be used in the program.$N****","OTE(FS51System.Internal.PEState)","1"
RCOMMENT,"FS51","FS51Control","****$NCall for Fiber to Blending$N****","OTE(FS51System.Status.CallForFiber)","2"
RCOMMENT,"FS51","FS51Main","****$NCall the other routines in the program.$N****","JSR(FS51Control,0)","0"
RCOMMENT,"FS51","FS51Main","****$NCall the other routines in the program.$N****","JSR(FOFeedroll,0)","1"
RCOMMENT,"FS51","FS51Main","****$NCall the other routines in the program.$N****","JSR(FOOutfeedFan,0)","2"
RCOMMENT,"FS51","FS51Main","****$NCall the other routines in the program.$N****","JSR(FS51Beater,0)","3"
RCOMMENT,"FS51","FS51Main","****$NCall the other routines in the program.$N****","JSR(FS51ReserveSiloFeedroll,0)","4"
RCOMMENT,"FS51","FS51Main","****$NCall the other routines in the program.$N****","JSR(VBOBeater,0)","5"
RCOMMENT,"FS51","FS51ReserveSiloFeedroll","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(FS51ReserveSiloFeedroll.Internal.Permissive)","0"
RCOMMENT,"FS51","FS51ReserveSiloFeedroll","****$NJog Command$N****","OTE(FS51ReserveSiloFeedroll.Internal.IntermediateJog)","1"
RCOMMENT,"FS51","FS51ReserveSiloFeedroll","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(FS51ReserveSiloFeedroll.Internal.DriveReverse)","2"
RCOMMENT,"FS51","FS51ReserveSiloFeedroll","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(FS51ReserveSiloFeedroll.Internal.MaintModeRun)","3"
RCOMMENT,"FS51","FS51ReserveSiloFeedroll","****$NAutomatic control.  The TON is dalay for start while the TOF is $Nthe delay for stop.$N****","OTE(FS51ReserveSiloFeedroll.Internal.AutoModeRun)","4"
RCOMMENT,"FS51","FS51ReserveSiloFeedroll","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(FS51ReserveSiloFeedroll.Internal.ReleaseRamp)","5"
RCOMMENT,"FS51","FS51ReserveSiloFeedroll","****$NThe commanded speed is calculated based on speed setpoint$Nmultiplied by the line speed (in percent).  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are based on the line speed accel and decel.$NThese should always be less so than the line speed$'s so the drives will follow the line ramp.$N****","MOV(FS51ReserveSiloFeedroll.Internal.DecelTime,FS51ReserveSiloFeedroll.Internal.DecelTime)","6"
RCOMMENT,"FS51","FS51ReserveSiloFeedroll","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(FS51ReserveSiloFeedroll.Internal.SpeedReference.ScaledOutput,FS51ReserveSiloFeedroll:O.FreqCommand)","7"
RCOMMENT,"FS51","FS51ReserveSiloFeedroll","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(FS51ReserveSiloFeedroll:O.Start)","8"
RCOMMENT,"FS51","FS51ReserveSiloFeedroll","****$NIf the drive is not being told to start, it should$Nbe being told to stop.$N****","OTE(FS51ReserveSiloFeedroll:O.Stop)","9"
RCOMMENT,"FS51","FS51ReserveSiloFeedroll","****$NTo Reverse the drive, send the reverse bit along with the start bit.  Seal$Nit in until the drive stops.$N****","OTE(FS51ReserveSiloFeedroll:O.Reverse)","10"
RCOMMENT,"FS51","FS51ReserveSiloFeedroll","****$NIf not reverse, then forward.$N****","OTE(FS51ReserveSiloFeedroll:O.Forward)","11"
RCOMMENT,"FS51","FS51ReserveSiloFeedroll","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(FS51ReserveSiloFeedroll.Internal.ActualSpeedScaler.ScaledOutput,FS51ReserveSiloFeedroll.Status.ActualSpeed)","12"
RCOMMENT,"FS51","FS51ReserveSiloFeedroll","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(FS51ReserveSiloFeedroll.Internal.LoadScaler.ScaledOutput,FS51ReserveSiloFeedroll.Status.MotorLoad)","13"
RCOMMENT,"FS51","FS51ReserveSiloFeedroll","****$NDrive Running Status$N****","OTE(FS51ReserveSiloFeedroll.Status.Running)","14"
RCOMMENT,"FS51","FS51ReserveSiloFeedroll","****$NJogging Forward Status$N****","OTE(FS51ReserveSiloFeedroll.Status.JoggingFwd)","15"
RCOMMENT,"FS51","FS51ReserveSiloFeedroll","****$NJogging Reverse Status$N****","OTE(FS51ReserveSiloFeedroll.Status.JoggingRev)","16"
RCOMMENT,"FS51","FS51ReserveSiloFeedroll","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(FS51ReserveSiloFeedroll.Status.FailedToStart)","17"
RCOMMENT,"FS51","FS51ReserveSiloFeedroll","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(FS51ReserveSiloFeedroll.Status.FailedToStop)","18"
RCOMMENT,"FS51","FS51ReserveSiloFeedroll","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(FS51ReserveSiloFeedroll.Status.Faulted)","19"
RCOMMENT,"FS51","FS51ReserveSiloFeedroll","****$NUnlatch the Drive Faulted Status$N****","OTU(FS51ReserveSiloFeedroll.Status.FailedToStop)","20"
RCOMMENT,"FS51","VBOBeater","****$NPermissive to operate the motor.$N****","OTE(VBOBeater.Internal.Permissive)","0"
RCOMMENT,"FS51","VBOBeater","****$NManual Run Control$N****","OTE(VBOBeater.Internal.IntermediateRunForward)","1"
RCOMMENT,"FS51","VBOBeater","****$NManual Jog Control$N****","OTE(VBOBeater.Internal.IntermediateJogForward)","2"
RCOMMENT,"FS51","VBOBeater","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(VBOBeater.Internal.AutoOffDelayTimer,?,?)","3"
RCOMMENT,"FS51","VBOBeater","****$NMotor Starter Control$N****","OTE(VBOBeaterCont)","4"
RCOMMENT,"FS51","VBOBeater","****$NRunning Status$N****","OTE(VBOBeater.Status.RunningForward)","5"
RCOMMENT,"FS51","VBOBeater","****$NIf the motor does not start when commanded, it has failed to run$N****","OTL(VBOBeater.Status.FailedToStart)","6"
RCOMMENT,"FS51","VBOBeater","****$NIf a motor continues to run when the run command has been removed,$Nit has failed to stop.$N****$N","OTL(VBOBeater.Status.FailedToStop)","7"
RCOMMENT,"FS51","VBOBeater","****$NGeneral Faulted Status$N****","OTE(VBOBeater.Status.Faulted)","8"
RCOMMENT,"FS51","VBOBeater","****$NReset Fault Latches$N****","OTU(VBOBeater.Status.FailedToStop)","9"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"FS52","FS52Beater","****$NPermissive to operate the motor.$N****","OTE(FS52Beater.Internal.Permissive)","0"
RCOMMENT,"FS52","FS52Beater","****$NManual Run Control$N****","OTE(FS52Beater.Internal.IntermediateRunForward)","1"
RCOMMENT,"FS52","FS52Beater","****$NManual Jog Control$N****","OTE(FS52Beater.Internal.IntermediateJogForward)","2"
RCOMMENT,"FS52","FS52Beater","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(FS52Beater.Internal.AutoOffDelayTimer,?,?)","3"
RCOMMENT,"FS52","FS52Beater","****$NMotor Starter Control$N****","OTE(FS52BeaterCont)","4"
RCOMMENT,"FS52","FS52Beater","****$NRunning Status$N****","OTE(FS52Beater.Status.RunningForward)","5"
RCOMMENT,"FS52","FS52Beater","****$NIf the motor does not start when commanded, it has failed to run$N****","OTL(FS52Beater.Status.FailedToStart)","6"
RCOMMENT,"FS52","FS52Beater","****$NIf a motor continues to run when the run command has been removed,$Nit has failed to stop.$N****$N","OTL(FS52Beater.Status.FailedToStop)","7"
RCOMMENT,"FS52","FS52Beater","****$NGeneral Faulted Status$N****","OTE(FS52Beater.Status.Faulted)","8"
RCOMMENT,"FS52","FS52Beater","****$NReset Fault Latches$N****","OTU(FS52Beater.Status.FailedToStop)","9"
RCOMMENT,"FS52","FS52Control","****$NThe input is used to trigger two timers for debounce.  The resulting state$Nwill be used in the program.$N****","OTE(FS52System.Internal.PEState)","1"
RCOMMENT,"FS52","FS52Control","****$NCall for Fiber to Blending$N****","OTE(FS52System.Status.CallForFiber)","2"
RCOMMENT,"FS52","FS52Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(FS52Control,0)","0"
RCOMMENT,"FS52","FS52Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(FS52Beater,0)","1"
RCOMMENT,"FS52","FS52Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(FS52ReserveSiloOutfeedFan,0)","2"
RCOMMENT,"FS52","FS52Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(FS52ReserveSiloFeedroll,0)","3"
RCOMMENT,"FS52","FS52ReserveSiloFeedroll","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(FS52ReserveSiloFeedroll.Internal.Permissive)","0"
RCOMMENT,"FS52","FS52ReserveSiloFeedroll","****$NJog Command$N****","OTE(FS52ReserveSiloFeedroll.Internal.IntermediateJog)","1"
RCOMMENT,"FS52","FS52ReserveSiloFeedroll","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(FS52ReserveSiloFeedroll.Internal.DriveReverse)","2"
RCOMMENT,"FS52","FS52ReserveSiloFeedroll","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(FS52ReserveSiloFeedroll.Internal.MaintModeRun)","3"
RCOMMENT,"FS52","FS52ReserveSiloFeedroll","****$NAutomatic control.  The TON is dalay for start while the TOF is $Nthe delay for stop.$N****","OTE(FS52ReserveSiloFeedroll.Internal.AutoModeRun)","4"
RCOMMENT,"FS52","FS52ReserveSiloFeedroll","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(FS52ReserveSiloFeedroll.Internal.ReleaseRamp)","5"
RCOMMENT,"FS52","FS52ReserveSiloFeedroll","****$NThe commanded speed is calculated based on speed setpoint$Nmultiplied by the line speed (in percent).  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are based on the line speed accel and decel.$NThese should always be less so than the line speed$'s so the drives will follow the line ramp.$N****","MOV(FS52ReserveSiloFeedroll.Internal.DecelTime,FS52ReserveSiloFeedroll.Internal.DecelTime)","6"
RCOMMENT,"FS52","FS52ReserveSiloFeedroll","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(FS52ReserveSiloFeedroll.Internal.SpeedReference.ScaledOutput,FS52ReserveSiloFeedroll:O.FreqCommand)","7"
RCOMMENT,"FS52","FS52ReserveSiloFeedroll","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(FS52ReserveSiloFeedroll:O.Start)","8"
RCOMMENT,"FS52","FS52ReserveSiloFeedroll","****$NIf the drive is not being told to start, it should$Nbe being told to stop.$N****","OTE(FS52ReserveSiloFeedroll:O.Stop)","9"
RCOMMENT,"FS52","FS52ReserveSiloFeedroll","****$NTo Reverse the drive, send the reverse bit along with the start bit.  Seal$Nit in until the drive stops.$N****","OTE(FS52ReserveSiloFeedroll:O.Reverse)","10"
RCOMMENT,"FS52","FS52ReserveSiloFeedroll","****$NIf not reverse, then forward.$N****","OTE(FS52ReserveSiloFeedroll:O.Forward)","11"
RCOMMENT,"FS52","FS52ReserveSiloFeedroll","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(FS52ReserveSiloFeedroll.Internal.ActualSpeedScaler.ScaledOutput,FS52ReserveSiloFeedroll.Status.ActualSpeed)","12"
RCOMMENT,"FS52","FS52ReserveSiloFeedroll","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(FS52ReserveSiloFeedroll.Internal.LoadScaler.ScaledOutput,FS52ReserveSiloFeedroll.Status.MotorLoad)","13"
RCOMMENT,"FS52","FS52ReserveSiloFeedroll","****$NDrive Running Status$N****","OTE(FS52ReserveSiloFeedroll.Status.Running)","14"
RCOMMENT,"FS52","FS52ReserveSiloFeedroll","****$NJogging Forward Status$N****","OTE(FS52ReserveSiloFeedroll.Status.JoggingFwd)","15"
RCOMMENT,"FS52","FS52ReserveSiloFeedroll","****$NJogging Reverse Status$N****","OTE(FS52ReserveSiloFeedroll.Status.JoggingRev)","16"
RCOMMENT,"FS52","FS52ReserveSiloFeedroll","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(FS52ReserveSiloFeedroll.Status.FailedToStart)","17"
RCOMMENT,"FS52","FS52ReserveSiloFeedroll","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(FS52ReserveSiloFeedroll.Status.FailedToStop)","18"
RCOMMENT,"FS52","FS52ReserveSiloFeedroll","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(FS52ReserveSiloFeedroll.Status.Faulted)","19"
RCOMMENT,"FS52","FS52ReserveSiloFeedroll","****$NUnlatch the Drive Faulted Status$N****","OTU(FS52ReserveSiloFeedroll.Status.FailedToStop)","20"
RCOMMENT,"FS52","FS52ReserveSiloOutfeedFan","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(FS52ReserveSiloOutfeedFan.Internal.Permissive)","0"
RCOMMENT,"FS52","FS52ReserveSiloOutfeedFan","****$NJog Command$N****","OTE(FS52ReserveSiloOutfeedFan.Internal.IntermediateJog)","1"
RCOMMENT,"FS52","FS52ReserveSiloOutfeedFan","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(FS52ReserveSiloOutfeedFan.Internal.DriveReverse)","2"
RCOMMENT,"FS52","FS52ReserveSiloOutfeedFan","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(FS52ReserveSiloOutfeedFan.Internal.MaintModeRun)","3"
RCOMMENT,"FS52","FS52ReserveSiloOutfeedFan","****$NAutomatic control.  The TON is dalay for start while the TOF is $Nthe delay for stop.$N****","OTE(FS52ReserveSiloOutfeedFan.Internal.AutoModeRun)","4"
RCOMMENT,"FS52","FS52ReserveSiloOutfeedFan","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(FS52ReserveSiloOutfeedFan.Internal.ReleaseRamp)","5"
RCOMMENT,"FS52","FS52ReserveSiloOutfeedFan","****$NThe commanded speed is calculated based on speed setpoint$Nmultiplied by the line speed (in percent).  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are based on the line speed accel and decel.$NThese should always be less so than the line speed$'s so the drives will follow the line ramp.$N****","MOV(FS52ReserveSiloOutfeedFan.Internal.DecelTime,FS52ReserveSiloOutfeedFan.Internal.DecelTime)","6"
RCOMMENT,"FS52","FS52ReserveSiloOutfeedFan","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(FS52ReserveSiloOutfeedFan.Internal.SpeedReference.ScaledOutput,FS52ReserveSiloOutfeedFan:O.FreqCommand)","7"
RCOMMENT,"FS52","FS52ReserveSiloOutfeedFan","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(FS52ReserveSiloOutfeedFan:O.Start)","8"
RCOMMENT,"FS52","FS52ReserveSiloOutfeedFan","****$NIf the drive is not being told to start, it should$Nbe being told to stop.$N****","OTE(FS52ReserveSiloOutfeedFan:O.Stop)","9"
RCOMMENT,"FS52","FS52ReserveSiloOutfeedFan","****$NTo Reverse the drive, send the reverse bit along with the start bit.  Seal$Nit in until the drive stops.$N****","OTE(FS52ReserveSiloOutfeedFan:O.Reverse)","10"
RCOMMENT,"FS52","FS52ReserveSiloOutfeedFan","****$NIf not reverse, then forward.$N****","OTE(FS52ReserveSiloOutfeedFan:O.Forward)","11"
RCOMMENT,"FS52","FS52ReserveSiloOutfeedFan","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(FS52ReserveSiloOutfeedFan.Internal.ActualSpeedScaler.ScaledOutput,FS52ReserveSiloOutfeedFan.Status.ActualSpeed)","12"
RCOMMENT,"FS52","FS52ReserveSiloOutfeedFan","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(FS52ReserveSiloOutfeedFan.Internal.LoadScaler.ScaledOutput,FS52ReserveSiloOutfeedFan.Status.MotorLoad)","13"
RCOMMENT,"FS52","FS52ReserveSiloOutfeedFan","****$NDrive Running Status$N****","OTE(FS52ReserveSiloOutfeedFan.Status.Running)","14"
RCOMMENT,"FS52","FS52ReserveSiloOutfeedFan","****$NJogging Forward Status$N****","OTE(FS52ReserveSiloOutfeedFan.Status.JoggingFwd)","15"
RCOMMENT,"FS52","FS52ReserveSiloOutfeedFan","****$NJogging Reverse Status$N****","OTE(FS52ReserveSiloOutfeedFan.Status.JoggingRev)","16"
RCOMMENT,"FS52","FS52ReserveSiloOutfeedFan","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(FS52ReserveSiloOutfeedFan.Status.FailedToStart)","17"
RCOMMENT,"FS52","FS52ReserveSiloOutfeedFan","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(FS52ReserveSiloOutfeedFan.Status.FailedToStop)","18"
RCOMMENT,"FS52","FS52ReserveSiloOutfeedFan","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(FS52ReserveSiloOutfeedFan.Status.Faulted)","19"
RCOMMENT,"FS52","FS52ReserveSiloOutfeedFan","****$NUnlatch the Drive Faulted Status$N****","OTU(FS52ReserveSiloOutfeedFan.Status.FailedToStop)","20"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"LineDoorSolenoids","CardDoorLocks","****$NThe permissive to lock is delayed by the timer.$N****","OTE(CardDoorLocks.Internal.LockPermissive)","0"
RCOMMENT,"LineDoorSolenoids","CardDoorLocks","****$NThe permissive to unlock is delayed by the timer.$N****","OTE(CardDoorLocks.Internal.UnlockPermissive)","1"
RCOMMENT,"LineDoorSolenoids","CardDoorLocks","****$NThe unlock command works if the permissive above is satisfied.$N****","OTE(CardDoorLocks.Internal.IntermediateUnlock)","2"
RCOMMENT,"LineDoorSolenoids","CardDoorLocks","****$NStatus for the HMI$N****","OTE(CardDoorLocks.Status.Locked)","3"
RCOMMENT,"LineDoorSolenoids","CardDoorLocks","****$NStatus for the HMI$N****","OTE(CardDoorLocks.Status.Unlocked)","4"
RCOMMENT,"LineDoorSolenoids","CardDoorLocks","****$NWatch the Outputs$N****","NOP()","6"
RCOMMENT,"LineDoorSolenoids","CardDoorLocks","****$NFire the Outputs$N****","OTE(CardFeedrollTopHatchReleaseSol)","7"
RCOMMENT,"LineDoorSolenoids","ChutefeedDoorLocks","****$NThe permissive to lock is delayed by the timer.$N****","OTE(ChutefeedDoorLocks.Internal.LockPermissive)","0"
RCOMMENT,"LineDoorSolenoids","ChutefeedDoorLocks","****$NThe permissive to unlock is delayed by the timer.$N****","OTE(ChutefeedDoorLocks.Internal.UnlockPermissive)","1"
RCOMMENT,"LineDoorSolenoids","ChutefeedDoorLocks","****$NThe unlock command works if the permissive above is satisfied.$N****","OTE(ChutefeedDoorLocks.Internal.IntermediateUnlock)","2"
RCOMMENT,"LineDoorSolenoids","ChutefeedDoorLocks","****$NStatus for the HMI$N****","OTE(ChutefeedDoorLocks.Status.Locked)","3"
RCOMMENT,"LineDoorSolenoids","ChutefeedDoorLocks","****$NStatus for the HMI$N****","OTE(ChutefeedDoorLocks.Status.Unlocked)","4"
RCOMMENT,"LineDoorSolenoids","ChutefeedDoorLocks","****$NFire the Outputs$N****","OTE(ChutefeedFrontAccessDoorReleaseSol)","5"
RCOMMENT,"LineDoorSolenoids","DoorSolenoidMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(CardDoorLocks,0)","0"
RCOMMENT,"LineDoorSolenoids","DoorSolenoidMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(ChutefeedDoorLocks,0)","1"
RCOMMENT,"LineDoorSolenoids","DoorSolenoidMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(DrafterDoorLocks,0)","2"
RCOMMENT,"LineDoorSolenoids","DrafterDoorLocks","****$NThe permissive to lock is delayed by the timer.$N****","OTE(DrafterDoorLocks.Internal.LockPermissive)","0"
RCOMMENT,"LineDoorSolenoids","DrafterDoorLocks","****$NThe permissive to unlock is delayed by the timer.$N****","OTE(DrafterDoorLocks.Internal.UnlockPermissive)","1"
RCOMMENT,"LineDoorSolenoids","DrafterDoorLocks","****$NThe unlock command works if the permissive above is satisfied.$N****","OTE(DrafterDoorLocks.Internal.IntermediateUnlock)","2"
RCOMMENT,"LineDoorSolenoids","DrafterDoorLocks","****$NStatus for the HMI$N****","OTE(DrafterDoorLocks.Status.Locked)","3"
RCOMMENT,"LineDoorSolenoids","DrafterDoorLocks","****$NStatus for the HMI$N****","OTE(DrafterDoorLocks.Status.Unlocked)","4"
RCOMMENT,"LineDoorSolenoids","DrafterDoorLocks","****$NFire the Outputs$N****","OTE(DrafterLeftDoor1ReleaseSol)","5"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"LineDrives","BottomDoffer","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(BottomDoffer.Internal.Permissive)","0"
RCOMMENT,"LineDrives","BottomDoffer","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(BottomDoffer.Command.Enable)","1"
RCOMMENT,"LineDrives","BottomDoffer","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(BottomDoffer.Command.Disable)","2"
RCOMMENT,"LineDrives","BottomDoffer","****$NJog Command$N****","OTE(BottomDoffer.Internal.IntermediateJog)","3"
RCOMMENT,"LineDrives","BottomDoffer","****$NWhen the drive is jogged reverse, the reverse bit is latched in$Nuntil the ramp returns to zero.$N****","OTE(BottomDoffer.Internal.DriveReverse)","4"
RCOMMENT,"LineDrives","BottomDoffer","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(BottomDoffer.Internal.MaintModeRun)","5"
RCOMMENT,"LineDrives","BottomDoffer","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(BottomDoffer.Internal.ReleaseRamp)","6"
RCOMMENT,"LineDrives","BottomDoffer","****$NThe speed may be incremented/decremented$Nby the step change value.  It is then checked against pre-determined values.$N****","SUB(BottomDoffer.Command.SpeedSetpoint,BottomDoffer.Command.StepChangeValue,BottomDoffer.Command.SpeedSetpoint)","7"
RCOMMENT,"LineDrives","BottomDoffer","****$NThe commanded speed is calculated based on speed setpoint$Nmultiplied by the line speed (in percent).  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are based on the line speed accel and decel.$NThese should always be less so than the line speed$'s so the drives will follow the line ramp.$N****","MOV(BottomDoffer.Internal.DecelTime,BottomDoffer.Internal.DecelTime)","8"
RCOMMENT,"LineDrives","BottomDoffer","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","NEG(BottomDoffer.Internal.SpeedReference.ScaledOutput,BottomDoffer.Outputs.SetSpeed)","9"
RCOMMENT,"LineDrives","BottomDoffer","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(BottomDoffer.Outputs.DriveCommandWord.Enable2)","10"
RCOMMENT,"LineDrives","BottomDoffer","****$NInhibit the drive when it is not being told to run.$N****","OTE(BottomDoffer.Outputs.DriveCommandWord.ControllerInhibit)","11"
RCOMMENT,"LineDrives","BottomDoffer","****$NScale the raw analog signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BottomDoffer.Internal.ActualSpeedScaler.ScaledOutput,BottomDoffer.Status.ActualSpeed)","12"
RCOMMENT,"LineDrives","BottomDoffer","****$NDepending on the mode, scale the proper feedback$Nfor load display on the HMI$N****","MOV(BottomDoffer.Internal.LoadScaler.ScaledOutput,BottomDoffer.Status.MotorLoad)","13"
RCOMMENT,"LineDrives","BottomDoffer","****$NDrive Running Status$N****","OTE(BottomDoffer.Status.Running)","14"
RCOMMENT,"LineDrives","BottomDoffer","****$NJogging Forward Status$N****","OTE(BottomDoffer.Status.JoggingFwd)","15"
RCOMMENT,"LineDrives","BottomDoffer","****$NJogging Reverse Status$N****","OTE(BottomDoffer.Status.JoggingRev)","16"
RCOMMENT,"LineDrives","BottomDoffer","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(BottomDoffer.Status.FailedToStart)","17"
RCOMMENT,"LineDrives","BottomDoffer","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(BottomDoffer.Status.FailedToStop)","18"
RCOMMENT,"LineDrives","BottomDoffer","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(BottomDoffer.Status.Faulted)","19"
RCOMMENT,"LineDrives","BottomDoffer","****$NUnlatch the Drive Faulted Status$N****","OTU(BottomDoffer.Status.FailedToStop)","20"
RCOMMENT,"LineDrives","BottomScrambler","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(BottomScrambler.Internal.Permissive)","0"
RCOMMENT,"LineDrives","BottomScrambler","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(BottomScrambler.Command.Enable)","1"
RCOMMENT,"LineDrives","BottomScrambler","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(BottomScrambler.Command.Disable)","2"
RCOMMENT,"LineDrives","BottomScrambler","****$NJog Command$N****","OTE(BottomScrambler.Internal.IntermediateJog)","3"
RCOMMENT,"LineDrives","BottomScrambler","****$NWhen the drive is jogged reverse, the reverse bit is latched in$Nuntil the ramp returns to zero.$N****","OTE(BottomScrambler.Internal.DriveReverse)","4"
RCOMMENT,"LineDrives","BottomScrambler","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(BottomScrambler.Internal.MaintModeRun)","5"
RCOMMENT,"LineDrives","BottomScrambler","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(BottomScrambler.Internal.ReleaseRamp)","6"
RCOMMENT,"LineDrives","BottomScrambler","****$NThe speed may be incremented/decremented$Nby the step change value.  It is then checked against pre-determined values.$N****","SUB(BottomScrambler.Command.SpeedSetpoint,BottomScrambler.Command.StepChangeValue,BottomScrambler.Command.SpeedSetpoint)","7"
RCOMMENT,"LineDrives","BottomScrambler","****$NThe commanded speed is calculated based on speed setpoint$Nmultiplied by the line speed (in percent).  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are based on the line speed accel and decel.$NThese should always be less so than the line speed$'s so the drives will follow the line ramp.$N****","MOV(BottomScrambler.Internal.DecelTime,BottomScrambler.Internal.DecelTime)","8"
RCOMMENT,"LineDrives","BottomScrambler","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","NEG(BottomScrambler.Internal.SpeedReference.ScaledOutput,BottomScrambler.Outputs.SetSpeed)","9"
RCOMMENT,"LineDrives","BottomScrambler","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(BottomScrambler.Outputs.DriveCommandWord.Enable2)","10"
RCOMMENT,"LineDrives","BottomScrambler","****$NInhibit the drive when it is not being told to run.$N****","OTE(BottomScrambler.Outputs.DriveCommandWord.ControllerInhibit)","11"
RCOMMENT,"LineDrives","BottomScrambler","****$NScale the raw analog signal coming from the drive$Nto engineering units for display on the HMI.$N****","MUL(BottomScrambler.Status.ActualSpeed,BottomScramblerRoll2Ratio,HMIBottomScramblerRoll2Speed)","12"
RCOMMENT,"LineDrives","BottomScrambler","****$NDepending on the mode, scale the proper feedback$Nfor load display on the HMI$N****","MOV(BottomScrambler.Internal.LoadScaler.ScaledOutput,BottomScrambler.Status.MotorLoad)","13"
RCOMMENT,"LineDrives","BottomScrambler","****$NDrive Running Status$N****","OTE(BottomScrambler.Status.Running)","14"
RCOMMENT,"LineDrives","BottomScrambler","****$NJogging Forward Status$N****","OTE(BottomScrambler.Status.JoggingFwd)","15"
RCOMMENT,"LineDrives","BottomScrambler","****$NJogging Reverse Status$N****","OTE(BottomScrambler.Status.JoggingRev)","16"
RCOMMENT,"LineDrives","BottomScrambler","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(BottomScrambler.Status.FailedToStart)","17"
RCOMMENT,"LineDrives","BottomScrambler","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(BottomScrambler.Status.FailedToStop)","18"
RCOMMENT,"LineDrives","BottomScrambler","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(BottomScrambler.Status.Faulted)","19"
RCOMMENT,"LineDrives","BottomScrambler","****$NUnlatch the Drive Faulted Status$N****","OTU(BottomScrambler.Status.FailedToStop)","20"
RCOMMENT,"LineDrives","BottomTakeoff","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(BottomTakeoff.Internal.Permissive)","0"
RCOMMENT,"LineDrives","BottomTakeoff","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(BottomTakeoff.Command.Enable)","1"
RCOMMENT,"LineDrives","BottomTakeoff","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(BottomTakeoff.Command.Disable)","2"
RCOMMENT,"LineDrives","BottomTakeoff","****$NJog Command$N****","OTE(BottomTakeoff.Internal.IntermediateJog)","3"
RCOMMENT,"LineDrives","BottomTakeoff","****$NWhen the drive is jogged reverse, the reverse bit is latched in$Nuntil the ramp returns to zero.$N****","OTE(BottomTakeoff.Internal.DriveReverse)","4"
RCOMMENT,"LineDrives","BottomTakeoff","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(BottomTakeoff.Internal.MaintModeRun)","5"
RCOMMENT,"LineDrives","BottomTakeoff","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(BottomTakeoff.Internal.ReleaseRamp)","6"
RCOMMENT,"LineDrives","BottomTakeoff","****$NThe speed may be incremented/decremented$Nby the step change value.  It is then checked against pre-determined values.$N****","SUB(BottomTakeoff.Command.SpeedSetpoint,BottomTakeoff.Command.StepChangeValue,BottomTakeoff.Command.SpeedSetpoint)","7"
RCOMMENT,"LineDrives","BottomTakeoff","****$NThe commanded speed is calculated based on speed setpoint$Nmultiplied by the line speed (in percent).  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are based on the line speed accel and decel.$NThese should always be less so than the line speed$'s so the drives will follow the line ramp.$N****","MOV(BottomTakeoff.Internal.DecelTime,BottomTakeoff.Internal.DecelTime)","8"
RCOMMENT,"LineDrives","BottomTakeoff","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","NEG(BottomTakeoff.Internal.SpeedReference.ScaledOutput,BottomTakeoff.Outputs.SetSpeed)","9"
RCOMMENT,"LineDrives","BottomTakeoff","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(BottomTakeoff.Outputs.DriveCommandWord.Enable2)","10"
RCOMMENT,"LineDrives","BottomTakeoff","****$NInhibit the drive when it is not being told to run.$N****","OTE(BottomTakeoff.Outputs.DriveCommandWord.ControllerInhibit)","11"
RCOMMENT,"LineDrives","BottomTakeoff","****$NScale the raw analog signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BottomTakeoff.Internal.ActualSpeedScaler.ScaledOutput,BottomTakeoff.Status.ActualSpeed)","12"
RCOMMENT,"LineDrives","BottomTakeoff","****$NDepending on the mode, scale the proper feedback$Nfor load display on the HMI$N****","MOV(BottomTakeoff.Internal.LoadScaler.ScaledOutput,BottomTakeoff.Status.MotorLoad)","13"
RCOMMENT,"LineDrives","BottomTakeoff","****$NDrive Running Status$N****","OTE(BottomTakeoff.Status.Running)","14"
RCOMMENT,"LineDrives","BottomTakeoff","****$NJogging Forward Status$N****","OTE(BottomTakeoff.Status.JoggingFwd)","15"
RCOMMENT,"LineDrives","BottomTakeoff","****$NJogging Reverse Status$N****","OTE(BottomTakeoff.Status.JoggingRev)","16"
RCOMMENT,"LineDrives","BottomTakeoff","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(BottomTakeoff.Status.FailedToStart)","17"
RCOMMENT,"LineDrives","BottomTakeoff","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(BottomTakeoff.Status.FailedToStop)","18"
RCOMMENT,"LineDrives","BottomTakeoff","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(BottomTakeoff.Status.Faulted)","19"
RCOMMENT,"LineDrives","BottomTakeoff","****$NUnlatch the Drive Faulted Status$N****","OTU(BottomTakeoff.Status.FailedToStop)","20"
RCOMMENT,"LineDrives","BottomTOFBelt","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(BottomTOFBelt.Internal.Permissive)","0"
RCOMMENT,"LineDrives","BottomTOFBelt","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(BottomTOFBelt.Command.Enable)","1"
RCOMMENT,"LineDrives","BottomTOFBelt","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(BottomTOFBelt.Command.Disable)","2"
RCOMMENT,"LineDrives","BottomTOFBelt","****$NJog Command$N****","OTE(BottomTOFBelt.Internal.IntermediateJog)","3"
RCOMMENT,"LineDrives","BottomTOFBelt","****$NWhen the drive is jogged reverse, the reverse bit is latched in$Nuntil the ramp returns to zero.$N****","OTE(BottomTOFBelt.Internal.DriveReverse)","4"
RCOMMENT,"LineDrives","BottomTOFBelt","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(BottomTOFBelt.Internal.MaintModeRun)","5"
RCOMMENT,"LineDrives","BottomTOFBelt","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(BottomTOFBelt.Internal.ReleaseRamp)","6"
RCOMMENT,"LineDrives","BottomTOFBelt","****$NThe speed may be incremented/decremented$Nby the step change value.  It is then checked against pre-determined values.$N****","SUB(BottomTOFBelt.Command.SpeedSetpoint,BottomTOFBelt.Command.StepChangeValue,BottomTOFBelt.Command.SpeedSetpoint)","7"
RCOMMENT,"LineDrives","BottomTOFBelt","****$NThe commanded speed is calculated based on speed setpoint$Nmultiplied by the line speed (in percent).  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are based on the line speed accel and decel.$NThese should always be less so than the line speed$'s so the drives will follow the line ramp.$N****","MOV(BottomTOFBelt.Internal.DecelTime,BottomTOFBelt.Internal.DecelTime)","8"
RCOMMENT,"LineDrives","BottomTOFBelt","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","NEG(BottomTOFBelt.Internal.SpeedReference.ScaledOutput,BottomTOFBelt.Outputs.SetSpeed)","9"
RCOMMENT,"LineDrives","BottomTOFBelt","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(BottomTOFBelt.Outputs.DriveCommandWord.Enable2)","10"
RCOMMENT,"LineDrives","BottomTOFBelt","****$NInhibit the drive when it is not being told to run.$N****","OTE(BottomTOFBelt.Outputs.DriveCommandWord.ControllerInhibit)","11"
RCOMMENT,"LineDrives","BottomTOFBelt","****$NScale the raw analog signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(BottomTOFBelt.Internal.ActualSpeedScaler.ScaledOutput,BottomTOFBelt.Status.ActualSpeed)","12"
RCOMMENT,"LineDrives","BottomTOFBelt","****$NDepending on the mode, scale the proper feedback$Nfor load display on the HMI$N****","MOV(BottomTOFBelt.Internal.LoadScaler.ScaledOutput,BottomTOFBelt.Status.MotorLoad)","13"
RCOMMENT,"LineDrives","BottomTOFBelt","****$NDrive Running Status$N****","OTE(BottomTOFBelt.Status.Running)","14"
RCOMMENT,"LineDrives","BottomTOFBelt","****$NJogging Forward Status$N****","OTE(BottomTOFBelt.Status.JoggingFwd)","15"
RCOMMENT,"LineDrives","BottomTOFBelt","****$NJogging Reverse Status$N****","OTE(BottomTOFBelt.Status.JoggingRev)","16"
RCOMMENT,"LineDrives","BottomTOFBelt","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(BottomTOFBelt.Status.FailedToStart)","17"
RCOMMENT,"LineDrives","BottomTOFBelt","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(BottomTOFBelt.Status.FailedToStop)","18"
RCOMMENT,"LineDrives","BottomTOFBelt","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(BottomTOFBelt.Status.Faulted)","19"
RCOMMENT,"LineDrives","BottomTOFBelt","****$NUnlatch the Drive Faulted Status$N****","OTU(BottomTOFBelt.Status.FailedToStop)","20"
RCOMMENT,"LineDrives","Calender","****$NThe speed may be incremented/decremented$Nby the step change value.  It is then checked against pre-determined values.$N****","MOV(Calender.Command.DrawSetpointMin,Calender.Command.DrawSetpoint)","0"
RCOMMENT,"LineDrives","Calender","****$NThe speed feedback from the looms is scaled above.  This speed is scaled here$Nand sent to an analog output to the calender section for their speed reference.$N****$NCalender tached in at 20.03 m/min at 10 V.$N","MUL(HMI_LoomSpeedFPM,FeetToMetersMultiplier,HMI_CalenderSpeedRefMPM)","1"
RCOMMENT,"LineDrives","Calender","****$NScale the analog input to engineering units.$N****","MUL(CalenderSpeedScaler.ScaledOutput,FeetToMetersMultiplier,HMI_CalenderSpeedMPM)","2"
RCOMMENT,"LineDrives","Calender","****$NFire the start output for 1 second when the line starts.$N****","OTL(CalenderShouldBeRunning)","3"
RCOMMENT,"LineDrives","Calender","****$NDisrupt the stop output for 1 second when the line stops.$N****","OTU(CalenderShouldBeRunning)","4"
RCOMMENT,"LineDrives","Calender","****$NThe stop output remains high until the line stops.  At that point$Nit drops out for 1 second.$N****","OTE(CalenderStop)","5"
RCOMMENT,"LineDrives","Calender","****$NThe $Qshould be running$Q bit should be on when the calender should be running.  Because$Nthe start command is toggled for only a second, this internal bit is latched with the start command$Nand unlatched with the stop command.$N****","OTL(Calender.Status.FailedToStart)","7"
RCOMMENT,"LineDrives","Calender","****$NReset output and alarms.$N****","OTU(Calender.Status.FailedToStart)","8"
RCOMMENT,"LineDrives","Crosslapper","****$NPermissives to Operate Drive$N****","OTE(Crosslapper.Internal.Permissive)","0"
RCOMMENT,"LineDrives","Crosslapper","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(Crosslapper.Command.Enable)","1"
RCOMMENT,"LineDrives","Crosslapper","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(Crosslapper.Command.Disable)","2"
RCOMMENT,"LineDrives","Crosslapper","****$NJog Command$N****","OTE(Crosslapper.Internal.IntermediateJog)","3"
RCOMMENT,"LineDrives","Crosslapper","****$NWhen the drive is jogged reverse, the reverse bit is latched in$Nuntil the ramp returns to zero.$N****","OTE(Crosslapper.Internal.DriveReverse)","4"
RCOMMENT,"LineDrives","Crosslapper","****$NIf the line is in maintenance mode, the drive may be run$Nindividually.$N****","OTE(Crosslapper.Internal.MaintModeRun)","5"
RCOMMENT,"LineDrives","Crosslapper","****$NCheck the data entered against limits before calculating mechanical ratio below.$N****","MOV(Crosslapper.Command.GearTeethMin,Crosslapper.Command.FirstGearTeeth)","6"
RCOMMENT,"LineDrives","Crosslapper","****$NCheck the data entered against limits before calculating mechanical ratio below.$N****","MOV(Crosslapper.Command.GearTeethMin,Crosslapper.Command.LastGearTeeth)","7"
RCOMMENT,"LineDrives","Crosslapper","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(Crosslapper.Internal.ReleaseRamp)","8"
RCOMMENT,"LineDrives","Crosslapper","****$NThe speed may be incremented/decremented$Nby the step change value.  It is then checked against pre-determined values.$N****","MOV(Crosslapper.Command.DrawSetpointMin,Crosslapper.Command.DrawSetpoint)","9"
RCOMMENT,"LineDrives","Crosslapper","****$NThe commanded speed is based on the mode.  In run$Nmode the speed is the speed of the drive it follows multiplied$Nby the draw.  In Maint mode it runs at its maintenance mode speed setpoint.  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are in seconds.$NThese should always be less so than the line speed rates so the drives will follow the line ramp.$N****","MUL(Crosslapper.Status.CommandedSpeed,FeetToMetersMultiplier,HMI_CrosslapperSpeedRefMPM)","10"
RCOMMENT,"LineDrives","Crosslapper","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$NTo reverse the drive direction, reverse the reference.$N****","MOV(Crosslapper.Internal.SpeedReference.ScaledOutput,CrosslapperSpeedRef)","11"
RCOMMENT,"LineDrives","Crosslapper","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(CrosslapperPlantOn)","12"
RCOMMENT,"LineDrives","Crosslapper","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MUL(Crosslapper.Status.ActualSpeed,FeetToMetersMultiplier,HMI_CrosslapperSpeedMPM)","13"
RCOMMENT,"LineDrives","Crosslapper","****$NDrive Running Status$N****","OTE(Crosslapper.Status.Running)","14"
RCOMMENT,"LineDrives","Crosslapper","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(Crosslapper.Status.FailedToStart)","15"
RCOMMENT,"LineDrives","Crosslapper","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(Crosslapper.Status.FailedToStop)","16"
RCOMMENT,"LineDrives","Crosslapper","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(Crosslapper.Status.Faulted)","17"
RCOMMENT,"LineDrives","Crosslapper","****$NUnlatch the Drive Faulted Status$N****","OTU(Crosslapper.Status.FailedToStop)","18"
RCOMMENT,"LineDrives","DrafterEntryApron","****$NPermissives to Operate Drive$N****","OTE(Apron.Internal.Permissive)","0"
RCOMMENT,"LineDrives","DrafterEntryApron","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(Apron.Command.Enable)","1"
RCOMMENT,"LineDrives","DrafterEntryApron","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(Apron.Command.Disable)","2"
RCOMMENT,"LineDrives","DrafterEntryApron","****$NJog Command$N****","OTE(Apron.Internal.IntermediateJog)","3"
RCOMMENT,"LineDrives","DrafterEntryApron","****$NWhen the drive is jogged reverse, the reverse bit is latched in$Nuntil the ramp returns to zero.$N****","OTE(Apron.Internal.DriveReverse)","4"
RCOMMENT,"LineDrives","DrafterEntryApron","****$NIf the line is in maintenance mode, the drive may be run$Nindividually.$N****","OTE(Apron.Internal.MaintModeRun)","5"
RCOMMENT,"LineDrives","DrafterEntryApron","****$NCheck the data entered against limits before calculating mechanical ratio below.$N****","MOV(Apron.Command.GearTeethMin,Apron.Command.FirstGearTeeth)","6"
RCOMMENT,"LineDrives","DrafterEntryApron","****$NCheck the data entered against limits before calculating mechanical ratio below.$N****","MOV(Apron.Command.GearTeethMin,Apron.Command.LastGearTeeth)","7"
RCOMMENT,"LineDrives","DrafterEntryApron","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(Apron.Internal.ReleaseRamp)","8"
RCOMMENT,"LineDrives","DrafterEntryApron","****$NThe speed may be incremented/decremented$Nby the step change value.  It is then checked against pre-determined values.$N****","MOV(Apron.Command.DrawSetpointMin,Apron.Command.DrawSetpoint)","9"
RCOMMENT,"LineDrives","DrafterEntryApron","****$NThe commanded speed is based on the mode.  In run$Nmode the speed is the speed of the drive it follows multiplied$Nby the draw.  In Maint mode it runs at its maintenance mode speed setpoint.  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are in seconds.$NThese should always be less so than the line speed rates so the drives will follow the line ramp.$N****","MOV(Apron.Internal.DecelTime,Apron.Internal.DecelTime)","10"
RCOMMENT,"LineDrives","DrafterEntryApron","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$NTo reverse the drive direction, reverse the reference.$N****","NEG(Apron.Internal.SpeedReference.ScaledOutput,Apron.Outputs.SetSpeed)","11"
RCOMMENT,"LineDrives","DrafterEntryApron","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(Apron.Outputs.DriveCommandWord.Enable2)","12"
RCOMMENT,"LineDrives","DrafterEntryApron","****$NInhibit the drive when it is not being told to run.$N****","OTE(Apron.Outputs.DriveCommandWord.ControllerInhibit)","13"
RCOMMENT,"LineDrives","DrafterEntryApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(Apron.Internal.ActualSpeedScaler.ScaledOutput,Apron.Status.ActualSpeed)","14"
RCOMMENT,"LineDrives","DrafterEntryApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(Apron.Internal.LoadScaler.ScaledOutput,Apron.Status.MotorLoad)","15"
RCOMMENT,"LineDrives","DrafterEntryApron","****$NDrive Running Status$N****","OTE(Apron.Status.Running)","16"
RCOMMENT,"LineDrives","DrafterEntryApron","****$NJogging Forward Status$N****","OTE(Apron.Status.JoggingFwd)","17"
RCOMMENT,"LineDrives","DrafterEntryApron","****$NJogging Reverse Status$N****","OTE(Apron.Status.JoggingRev)","18"
RCOMMENT,"LineDrives","DrafterEntryApron","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(Apron.Status.FailedToStart)","19"
RCOMMENT,"LineDrives","DrafterEntryApron","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(Apron.Status.FailedToStop)","20"
RCOMMENT,"LineDrives","DrafterEntryApron","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(Apron.Status.Faulted)","21"
RCOMMENT,"LineDrives","DrafterEntryApron","****$NUnlatch the Drive Faulted Status$N****","OTU(Apron.Status.FailedToStop)","22"
RCOMMENT,"LineDrives","DrafterGroup1","****$NPermissives to Operate Drive$N****","OTE(DrafterGroup1.Internal.Permissive)","0"
RCOMMENT,"LineDrives","DrafterGroup1","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(DrafterGroup1.Command.Enable)","1"
RCOMMENT,"LineDrives","DrafterGroup1","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(DrafterGroup1.Command.Disable)","2"
RCOMMENT,"LineDrives","DrafterGroup1","****$NJog Command$N****","OTE(DrafterGroup1.Internal.IntermediateJog)","3"
RCOMMENT,"LineDrives","DrafterGroup1","****$NWhen the drive is jogged reverse, the reverse bit is latched in$Nuntil the ramp returns to zero.$N****","OTE(DrafterGroup1.Internal.DriveReverse)","4"
RCOMMENT,"LineDrives","DrafterGroup1","****$NIf the line is in maintenance mode, the drive may be run$Nindividually.$N****","OTE(DrafterGroup1.Internal.MaintModeRun)","5"
RCOMMENT,"LineDrives","DrafterGroup1","****$NCheck the data entered against limits before calculating mechanical ratio below.$N****","MOV(DrafterGroup1.Command.GearTeethMin,DrafterGroup1.Command.FirstGearTeeth)","6"
RCOMMENT,"LineDrives","DrafterGroup1","****$NCheck the data entered against limits before calculating mechanical ratio below.$N****","MOV(DrafterGroup1.Command.GearTeethMin,DrafterGroup1.Command.LastGearTeeth)","7"
RCOMMENT,"LineDrives","DrafterGroup1","****$NThe drafters have a mechanical ratio that is calculated by dividing$Nthe first gear number of teeth by the last gear number of teeth.  The mechanical ratio$Nshould be greater than 1.$N****","CPT(DrafterGroup1.Status.MechanicalRatio,DrafterGroup1.Command.FirstGearTeeth/DrafterGroup1.Command.LastGearTeeth)","8"
RCOMMENT,"LineDrives","DrafterGroup1","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(DrafterGroup1.Internal.ReleaseRamp)","9"
RCOMMENT,"LineDrives","DrafterGroup1","****$NThe speed may be incremented/decremented$Nby the step change value.  It is then checked against pre-determined values.$N****","MOV(DrafterGroup1.Command.DrawSetpointMin,DrafterGroup1.Command.DrawSetpoint)","10"
RCOMMENT,"LineDrives","DrafterGroup1","****$NThe commanded speed is based on the mode.  In run$Nmode the speed is the speed of the drive it follows multiplied$Nby the draw.  In Maint mode it runs at its maintenance mode speed setpoint.  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are in seconds.$NThese should always be less so than the line speed rates so the drives will follow the line ramp.$N****","MOV(DrafterGroup1.Internal.DecelTime,DrafterGroup1.Internal.DecelTime)","11"
RCOMMENT,"LineDrives","DrafterGroup1","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$NTo reverse the drive direction, reverse the reference.$N****","NEG(DrafterGroup1.Internal.SpeedReference.ScaledOutput,DrafterGroup1.Outputs.SetSpeed)","12"
RCOMMENT,"LineDrives","DrafterGroup1","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(DrafterGroup1.Outputs.DriveCommandWord.Enable2)","13"
RCOMMENT,"LineDrives","DrafterGroup1","****$NInhibit the drive when it is not being told to run.$N****","OTE(DrafterGroup1.Outputs.DriveCommandWord.ControllerInhibit)","14"
RCOMMENT,"LineDrives","DrafterGroup1","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(DrafterGroup1.Internal.ActualSpeedScaler.ScaledOutput,DrafterGroup1.Status.ActualSpeed)","15"
RCOMMENT,"LineDrives","DrafterGroup1","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(DrafterGroup1.Internal.LoadScaler.ScaledOutput,DrafterGroup1.Status.MotorLoad)","16"
RCOMMENT,"LineDrives","DrafterGroup1","****$NDrive Running Status$N****","OTE(DrafterGroup1.Status.Running)","17"
RCOMMENT,"LineDrives","DrafterGroup1","****$NJogging Forward Status$N****","OTE(DrafterGroup1.Status.JoggingFwd)","18"
RCOMMENT,"LineDrives","DrafterGroup1","****$NJogging Reverse Status$N****","OTE(DrafterGroup1.Status.JoggingRev)","19"
RCOMMENT,"LineDrives","DrafterGroup1","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(DrafterGroup1.Status.FailedToStart)","20"
RCOMMENT,"LineDrives","DrafterGroup1","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(DrafterGroup1.Status.FailedToStop)","21"
RCOMMENT,"LineDrives","DrafterGroup1","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(DrafterGroup1.Status.Faulted)","22"
RCOMMENT,"LineDrives","DrafterGroup1","****$NUnlatch the Drive Faulted Status$N****","OTU(DrafterGroup1.Status.FailedToStop)","23"
RCOMMENT,"LineDrives","DrafterGroup2","****$NPermissives to Operate Drive$N****","OTE(DrafterGroup2.Internal.Permissive)","0"
RCOMMENT,"LineDrives","DrafterGroup2","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(DrafterGroup2.Command.Enable)","1"
RCOMMENT,"LineDrives","DrafterGroup2","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(DrafterGroup2.Command.Disable)","2"
RCOMMENT,"LineDrives","DrafterGroup2","****$NJog Command$N****","OTE(DrafterGroup2.Internal.IntermediateJog)","3"
RCOMMENT,"LineDrives","DrafterGroup2","****$NWhen the drive is jogged reverse, the reverse bit is latched in$Nuntil the ramp returns to zero.$N****","OTE(DrafterGroup2.Internal.DriveReverse)","4"
RCOMMENT,"LineDrives","DrafterGroup2","****$NIf the line is in maintenance mode, the drive may be run$Nindividually.$N****","OTE(DrafterGroup2.Internal.MaintModeRun)","5"
RCOMMENT,"LineDrives","DrafterGroup2","****$NCheck the data entered against limits before calculating mechanical ratio below.$N****","MOV(DrafterGroup2.Command.GearTeethMin,DrafterGroup2.Command.FirstGearTeeth)","6"
RCOMMENT,"LineDrives","DrafterGroup2","****$NCheck the data entered against limits before calculating mechanical ratio below.$N****","MOV(DrafterGroup2.Command.GearTeethMin,DrafterGroup2.Command.LastGearTeeth)","7"
RCOMMENT,"LineDrives","DrafterGroup2","****$NThe drafters have a mechanical ratio that is calculated by dividing$Nthe first gear number of teeth by the last gear number of teeth.  The mechanical ratio$Nshould be greater than 1.$N****","CPT(DrafterGroup2.Status.MechanicalRatio,DrafterGroup2.Command.FirstGearTeeth/DrafterGroup2.Command.LastGearTeeth)","8"
RCOMMENT,"LineDrives","DrafterGroup2","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(DrafterGroup2.Internal.ReleaseRamp)","9"
RCOMMENT,"LineDrives","DrafterGroup2","****$NThe speed may be incremented/decremented$Nby the step change value.  It is then checked against pre-determined values.$N****","MOV(DrafterGroup2.Command.DrawSetpointMin,DrafterGroup2.Command.DrawSetpoint)","10"
RCOMMENT,"LineDrives","DrafterGroup2","****$NThe commanded speed is based on the mode.  In run$Nmode the speed is the speed of the drive it follows multiplied$Nby the draw.  In Maint mode it runs at its maintenance mode speed setpoint.  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are in seconds.$NThese should always be less so than the line speed rates so the drives will follow the line ramp.$N****","MOV(DrafterGroup2.Internal.DecelTime,DrafterGroup2.Internal.DecelTime)","11"
RCOMMENT,"LineDrives","DrafterGroup2","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$NTo reverse the drive direction, reverse the reference.$N****","NEG(DrafterGroup2.Internal.SpeedReference.ScaledOutput,DrafterGroup2.Outputs.SetSpeed)","12"
RCOMMENT,"LineDrives","DrafterGroup2","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(DrafterGroup2.Outputs.DriveCommandWord.Enable2)","13"
RCOMMENT,"LineDrives","DrafterGroup2","****$NInhibit the drive when it is not being told to run.$N****","OTE(DrafterGroup2.Outputs.DriveCommandWord.ControllerInhibit)","14"
RCOMMENT,"LineDrives","DrafterGroup2","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(DrafterGroup2.Internal.ActualSpeedScaler.ScaledOutput,DrafterGroup2.Status.ActualSpeed)","15"
RCOMMENT,"LineDrives","DrafterGroup2","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(DrafterGroup2.Internal.LoadScaler.ScaledOutput,DrafterGroup2.Status.MotorLoad)","16"
RCOMMENT,"LineDrives","DrafterGroup2","****$NDrive Running Status$N****","OTE(DrafterGroup2.Status.Running)","17"
RCOMMENT,"LineDrives","DrafterGroup2","****$NJogging Forward Status$N****","OTE(DrafterGroup2.Status.JoggingFwd)","18"
RCOMMENT,"LineDrives","DrafterGroup2","****$NJogging Reverse Status$N****","OTE(DrafterGroup2.Status.JoggingRev)","19"
RCOMMENT,"LineDrives","DrafterGroup2","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(DrafterGroup2.Status.FailedToStart)","20"
RCOMMENT,"LineDrives","DrafterGroup2","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(DrafterGroup2.Status.FailedToStop)","21"
RCOMMENT,"LineDrives","DrafterGroup2","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(DrafterGroup2.Status.Faulted)","22"
RCOMMENT,"LineDrives","DrafterGroup2","****$NUnlatch the Drive Faulted Status$N****","OTU(DrafterGroup2.Status.FailedToStop)","23"
RCOMMENT,"LineDrives","DrafterGroup3","****$NPermissives to Operate Drive$N****","OTE(DrafterGroup3.Internal.Permissive)","0"
RCOMMENT,"LineDrives","DrafterGroup3","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(DrafterGroup3.Command.Enable)","1"
RCOMMENT,"LineDrives","DrafterGroup3","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(DrafterGroup3.Command.Disable)","2"
RCOMMENT,"LineDrives","DrafterGroup3","****$NJog Command$N****","OTE(DrafterGroup3.Internal.IntermediateJog)","3"
RCOMMENT,"LineDrives","DrafterGroup3","****$NWhen the drive is jogged reverse, the reverse bit is latched in$Nuntil the ramp returns to zero.$N****","OTE(DrafterGroup3.Internal.DriveReverse)","4"
RCOMMENT,"LineDrives","DrafterGroup3","****$NIf the line is in maintenance mode, the drive may be run$Nindividually.$N****","OTE(DrafterGroup3.Internal.MaintModeRun)","5"
RCOMMENT,"LineDrives","DrafterGroup3","****$NCheck the data entered against limits before calculating mechanical ratio below.$N****","MOV(DrafterGroup3.Command.GearTeethMin,DrafterGroup3.Command.FirstGearTeeth)","6"
RCOMMENT,"LineDrives","DrafterGroup3","****$NCheck the data entered against limits before calculating mechanical ratio below.$N****","MOV(DrafterGroup3.Command.GearTeethMin,DrafterGroup3.Command.LastGearTeeth)","7"
RCOMMENT,"LineDrives","DrafterGroup3","****$NThe drafters have a mechanical ratio that is calculated by dividing$Nthe first gear number of teeth by the last gear number of teeth.  The mechanical ratio$Nshould be greater than 1.$N****","CPT(DrafterGroup3.Status.MechanicalRatio,DrafterGroup3.Command.FirstGearTeeth/DrafterGroup3.Command.LastGearTeeth)","8"
RCOMMENT,"LineDrives","DrafterGroup3","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(DrafterGroup3.Internal.ReleaseRamp)","9"
RCOMMENT,"LineDrives","DrafterGroup3","****$NThe speed may be incremented/decremented$Nby the step change value.  It is then checked against pre-determined values.$N****","MOV(DrafterGroup3.Command.DrawSetpointMin,DrafterGroup3.Command.DrawSetpoint)","10"
RCOMMENT,"LineDrives","DrafterGroup3","****$NThe commanded speed is based on the mode.  In run$Nmode the speed is the speed of the drive it follows multiplied$Nby the draw.  In Maint mode it runs at its maintenance mode speed setpoint.  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are in seconds.$NThese should always be less so than the line speed rates so the drives will follow the line ramp.$N****","MOV(DrafterGroup3.Internal.DecelTime,DrafterGroup3.Internal.DecelTime)","11"
RCOMMENT,"LineDrives","DrafterGroup3","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$NTo reverse the drive direction, reverse the reference.$N****","NEG(DrafterGroup3.Internal.SpeedReference.ScaledOutput,DrafterGroup3.Outputs.SetSpeed)","12"
RCOMMENT,"LineDrives","DrafterGroup3","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(DrafterGroup3.Outputs.DriveCommandWord.Enable2)","13"
RCOMMENT,"LineDrives","DrafterGroup3","****$NInhibit the drive when it is not being told to run.$N****","OTE(DrafterGroup3.Outputs.DriveCommandWord.ControllerInhibit)","14"
RCOMMENT,"LineDrives","DrafterGroup3","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(DrafterGroup3.Internal.ActualSpeedScaler.ScaledOutput,DrafterGroup3.Status.ActualSpeed)","15"
RCOMMENT,"LineDrives","DrafterGroup3","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(DrafterGroup3.Internal.LoadScaler.ScaledOutput,DrafterGroup3.Status.MotorLoad)","16"
RCOMMENT,"LineDrives","DrafterGroup3","****$NDrive Running Status$N****","OTE(DrafterGroup3.Status.Running)","17"
RCOMMENT,"LineDrives","DrafterGroup3","****$NJogging Forward Status$N****","OTE(DrafterGroup3.Status.JoggingFwd)","18"
RCOMMENT,"LineDrives","DrafterGroup3","****$NJogging Reverse Status$N****","OTE(DrafterGroup3.Status.JoggingRev)","19"
RCOMMENT,"LineDrives","DrafterGroup3","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(DrafterGroup3.Status.FailedToStart)","20"
RCOMMENT,"LineDrives","DrafterGroup3","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(DrafterGroup3.Status.FailedToStop)","21"
RCOMMENT,"LineDrives","DrafterGroup3","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(DrafterGroup3.Status.Faulted)","22"
RCOMMENT,"LineDrives","DrafterGroup3","****$NUnlatch the Drive Faulted Status$N****","OTU(DrafterGroup3.Status.FailedToStop)","23"
RCOMMENT,"LineDrives","DrafterGroup4","****$NPermissives to Operate Drive$N****","OTE(DrafterGroup4.Internal.Permissive)","0"
RCOMMENT,"LineDrives","DrafterGroup4","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(DrafterGroup4.Command.Enable)","1"
RCOMMENT,"LineDrives","DrafterGroup4","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(DrafterGroup4.Command.Disable)","2"
RCOMMENT,"LineDrives","DrafterGroup4","****$NJog Command$N****","OTE(DrafterGroup4.Internal.IntermediateJog)","3"
RCOMMENT,"LineDrives","DrafterGroup4","****$NWhen the drive is jogged reverse, the reverse bit is latched in$Nuntil the ramp returns to zero.$N****","OTE(DrafterGroup4.Internal.DriveReverse)","4"
RCOMMENT,"LineDrives","DrafterGroup4","****$NIf the line is in maintenance mode, the drive may be run$Nindividually.$N****","OTE(DrafterGroup4.Internal.MaintModeRun)","5"
RCOMMENT,"LineDrives","DrafterGroup4","****$NCheck the data entered against limits before calculating mechanical ratio below.$N****","MOV(DrafterGroup4.Command.GearTeethMin,DrafterGroup4.Command.FirstGearTeeth)","6"
RCOMMENT,"LineDrives","DrafterGroup4","****$NCheck the data entered against limits before calculating mechanical ratio below.$N****","MOV(DrafterGroup4.Command.GearTeethMin,DrafterGroup4.Command.LastGearTeeth)","7"
RCOMMENT,"LineDrives","DrafterGroup4","****$NThe drafters have a mechanical ratio that is calculated by dividing$Nthe first gear number of teeth by the last gear number of teeth.  The mechanical ratio$Nshould be greater than 1.$N****","CPT(DrafterGroup4.Status.MechanicalRatio,DrafterGroup4.Command.FirstGearTeeth/DrafterGroup4.Command.LastGearTeeth)","8"
RCOMMENT,"LineDrives","DrafterGroup4","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(DrafterGroup4.Internal.ReleaseRamp)","9"
RCOMMENT,"LineDrives","DrafterGroup4","****$NThe speed may be incremented/decremented$Nby the step change value.  It is then checked against pre-determined values.$N****","MOV(DrafterGroup4.Command.DrawSetpointMin,DrafterGroup4.Command.DrawSetpoint)","10"
RCOMMENT,"LineDrives","DrafterGroup4","****$NThe commanded speed is based on the mode.  In run$Nmode the speed is the speed of the drive it follows multiplied$Nby the draw.  In Maint mode it runs at its maintenance mode speed setpoint.  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are in seconds.$NThese should always be less so than the line speed rates so the drives will follow the line ramp.$N****","MOV(DrafterGroup4.Internal.DecelTime,DrafterGroup4.Internal.DecelTime)","11"
RCOMMENT,"LineDrives","DrafterGroup4","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$NTo reverse the drive direction, reverse the reference.$N****","NEG(DrafterGroup4.Internal.SpeedReference.ScaledOutput,DrafterGroup4.Outputs.SetSpeed)","12"
RCOMMENT,"LineDrives","DrafterGroup4","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(DrafterGroup4.Outputs.DriveCommandWord.Enable2)","13"
RCOMMENT,"LineDrives","DrafterGroup4","****$NInhibit the drive when it is not being told to run.$N****","OTE(DrafterGroup4.Outputs.DriveCommandWord.ControllerInhibit)","14"
RCOMMENT,"LineDrives","DrafterGroup4","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(DrafterGroup4.Internal.ActualSpeedScaler.ScaledOutput,DrafterGroup4.Status.ActualSpeed)","15"
RCOMMENT,"LineDrives","DrafterGroup4","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(DrafterGroup4.Internal.LoadScaler.ScaledOutput,DrafterGroup4.Status.MotorLoad)","16"
RCOMMENT,"LineDrives","DrafterGroup4","****$NDrive Running Status$N****","OTE(DrafterGroup4.Status.Running)","17"
RCOMMENT,"LineDrives","DrafterGroup4","****$NJogging Forward Status$N****","OTE(DrafterGroup4.Status.JoggingFwd)","18"
RCOMMENT,"LineDrives","DrafterGroup4","****$NJogging Reverse Status$N****","OTE(DrafterGroup4.Status.JoggingRev)","19"
RCOMMENT,"LineDrives","DrafterGroup4","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(DrafterGroup4.Status.FailedToStart)","20"
RCOMMENT,"LineDrives","DrafterGroup4","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(DrafterGroup4.Status.FailedToStop)","21"
RCOMMENT,"LineDrives","DrafterGroup4","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(DrafterGroup4.Status.Faulted)","22"
RCOMMENT,"LineDrives","DrafterGroup4","****$NUnlatch the Drive Faulted Status$N****","OTU(DrafterGroup4.Status.FailedToStop)","23"
RCOMMENT,"LineDrives","DrafterGroup5","****$NPermissives to Operate Drive$N****","OTE(DrafterGroup5.Internal.Permissive)","0"
RCOMMENT,"LineDrives","DrafterGroup5","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(DrafterGroup5.Command.Enable)","1"
RCOMMENT,"LineDrives","DrafterGroup5","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(DrafterGroup5.Command.Disable)","2"
RCOMMENT,"LineDrives","DrafterGroup5","****$NJog Command$N****","OTE(DrafterGroup5.Internal.IntermediateJog)","3"
RCOMMENT,"LineDrives","DrafterGroup5","****$NWhen the drive is jogged reverse, the reverse bit is latched in$Nuntil the ramp returns to zero.$N****","OTE(DrafterGroup5.Internal.DriveReverse)","4"
RCOMMENT,"LineDrives","DrafterGroup5","****$NIf the line is in maintenance mode, the drive may be run$Nindividually.$N****","OTE(DrafterGroup5.Internal.MaintModeRun)","5"
RCOMMENT,"LineDrives","DrafterGroup5","****$NCheck the data entered against limits before calculating mechanical ratio below.$N****","MOV(DrafterGroup5.Command.GearTeethMin,DrafterGroup5.Command.FirstGearTeeth)","6"
RCOMMENT,"LineDrives","DrafterGroup5","****$NCheck the data entered against limits before calculating mechanical ratio below.$N****","MOV(DrafterGroup5.Command.GearTeethMin,DrafterGroup5.Command.LastGearTeeth)","7"
RCOMMENT,"LineDrives","DrafterGroup5","****$NThe drafters have a mechanical ratio that is calculated by dividing$Nthe first gear number of teeth by the last gear number of teeth.  The mechanical ratio$Nshould be greater than 1.$N****","CPT(DrafterGroup5.Status.MechanicalRatio,DrafterGroup5.Command.FirstGearTeeth/DrafterGroup5.Command.LastGearTeeth)","8"
RCOMMENT,"LineDrives","DrafterGroup5","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(DrafterGroup5.Internal.ReleaseRamp)","9"
RCOMMENT,"LineDrives","DrafterGroup5","****$NThe speed may be incremented/decremented$Nby the step change value.  It is then checked against pre-determined values.$N****","MOV(DrafterGroup5.Command.DrawSetpointMin,DrafterGroup5.Command.DrawSetpoint)","10"
RCOMMENT,"LineDrives","DrafterGroup5","****$NThe commanded speed is based on the mode.  In run$Nmode the speed is the speed of the drive it follows multiplied$Nby the draw.  In Maint mode it runs at its maintenance mode speed setpoint.  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are in seconds.$NThese should always be less so than the line speed rates so the drives will follow the line ramp.$N****","MOV(DrafterGroup5.Internal.DecelTime,DrafterGroup5.Internal.DecelTime)","11"
RCOMMENT,"LineDrives","DrafterGroup5","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$NTo reverse the drive direction, reverse the reference.$N****","NEG(DrafterGroup5.Internal.SpeedReference.ScaledOutput,DrafterGroup5.Outputs.SetSpeed)","12"
RCOMMENT,"LineDrives","DrafterGroup5","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(DrafterGroup5.Outputs.DriveCommandWord.Enable2)","13"
RCOMMENT,"LineDrives","DrafterGroup5","****$NInhibit the drive when it is not being told to run.$N****","OTE(DrafterGroup5.Outputs.DriveCommandWord.ControllerInhibit)","14"
RCOMMENT,"LineDrives","DrafterGroup5","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(DrafterGroup5.Internal.ActualSpeedScaler.ScaledOutput,DrafterGroup5.Status.ActualSpeed)","15"
RCOMMENT,"LineDrives","DrafterGroup5","****$NScale the speed of the final roll (using mechanical ratio) to send to the$Nlooms.$N****","MUL(HMI_LoomsSpeedRefFPM,FeetToMetersMultiplier,HMI_LoomsSpeedRefMPM)","16"
RCOMMENT,"LineDrives","DrafterGroup5","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(DrafterGroup5.Internal.LoadScaler.ScaledOutput,DrafterGroup5.Status.MotorLoad)","17"
RCOMMENT,"LineDrives","DrafterGroup5","****$NDrive Running Status$N****","OTE(DrafterGroup5.Status.Running)","18"
RCOMMENT,"LineDrives","DrafterGroup5","****$NJogging Forward Status$N****","OTE(DrafterGroup5.Status.JoggingFwd)","19"
RCOMMENT,"LineDrives","DrafterGroup5","****$NJogging Reverse Status$N****","OTE(DrafterGroup5.Status.JoggingRev)","20"
RCOMMENT,"LineDrives","DrafterGroup5","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(DrafterGroup5.Status.FailedToStart)","21"
RCOMMENT,"LineDrives","DrafterGroup5","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(DrafterGroup5.Status.FailedToStop)","22"
RCOMMENT,"LineDrives","DrafterGroup5","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(DrafterGroup5.Status.Faulted)","23"
RCOMMENT,"LineDrives","DrafterGroup5","****$NUnlatch the Drive Faulted Status$N****","OTU(DrafterGroup5.Status.FailedToStop)","24"
RCOMMENT,"LineDrives","DrawCalculations","****$NIn order to get the total draft the draws must be in the save format$Nas the mechanica ratios.  Here, the draw setpoints are converted.$N****","CPT(DrafterG5DrawRatio,DrafterGroup5.Command.DrawSetpoint/100+1)","0"
RCOMMENT,"LineDrives","DrawCalculations","****$NThe drafter section ratio is the result of multiplying all the mechanica ratios and the draw$Nsetpoint ratios calculated above.$N****","CPT(HMI_DrafterSectionDrawRatio,DrafterG1DrawRatio*DrafterGroup1.Status.MechanicalRatio* DrafterG2DrawRatio*DrafterGroup2.Status.MechanicalRatio*DrafterG3DrawRatio*DrafterGroup3.Status.MechanicalRatio*DrafterG4DrawRatio*DrafterGroup4.Status.MechanicalRatio*DrafterG5DrawRatio*DrafterGroup5.Status.MechanicalRatio)","1"
RCOMMENT,"LineDrives","DrawCalculations","****$NThe section draw is just the ratio turned into percent (draw).$N****","CPT(HMI_DrafterSectionDraw,(HMI_DrafterSectionDrawRatio-1)*100)","2"
RCOMMENT,"LineDrives","DrawCalculations","****$NThe total draw is is the floor apron actual speed divided by the calender actual speed$Nratio (converted to draw).$NIf the apron is not running, move a zero to prevent a divide by zero.$N****","MOV(0,HMI_LineTotalDraw)","3"
RCOMMENT,"LineDrives","FeedRoll","****$NPermissives to Operate Drive$N****","OTE(FeedRoll.Internal.Permissive)","0"
RCOMMENT,"LineDrives","FeedRoll","****$NThe feedroll must be jogged reverse for an amount of time to unlatch a$Nmetal detect.$N****","TON(FeedRollJogReverseTimer,?,?)","1"
RCOMMENT,"LineDrives","FeedRoll","****$NThe metal detected bit gets latched in until a reverse is executed for an$Namount of time.$N****","OTE(CardMetalDetected)","2"
RCOMMENT,"LineDrives","FeedRoll","****$NThe feedroll may be enabled and disabled regardless of the line$'s running status.$N****","OTU(FeedRoll.Command.Enable)","3"
RCOMMENT,"LineDrives","FeedRoll","****$NThe feedroll may be enabled and disabled regardless of the line$'s running status.$N****","OTU(FeedRoll.Command.Disable)","4"
RCOMMENT,"LineDrives","FeedRoll","****$NIn setpoint mode, the feedroll follows the line ramp (%) to it$'s set speed.$NThe weight has no control of the speed.$N****","OTU(HMI_FeedrollToSetpointMode)","5"
RCOMMENT,"LineDrives","FeedRoll","****$NIn weight mode, the speed of the feedroll is varied in order to maintain$Na consistant fabric weight.$N****","OTU(HMI_FeedRollToWeighMode)","6"
RCOMMENT,"LineDrives","FeedRoll","****$NJog Command$N****","OTE(FeedRoll.Internal.IntermediateJog)","7"
RCOMMENT,"LineDrives","FeedRoll","****$NWhen the drive is jogged reverse, the reverse bit is latched in$Nuntil the ramp returns to zero.$N****","OTE(FeedRoll.Internal.DriveReverse)","8"
RCOMMENT,"LineDrives","FeedRoll","****$NIf the line is in maintenance mode, the drive may be run$Nindividually.$N****","OTE(FeedRoll.Internal.MaintModeRun)","9"
RCOMMENT,"LineDrives","FeedRoll","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(FeedRoll.Internal.ReleaseRamp)","10"
RCOMMENT,"LineDrives","FeedRoll","****$NThe speed may be incremented/decremented$Nby the step change value.  It is then checked against pre-determined values.$N****","MOV(FeedRoll.Internal.SpeedSetpointMin,FeedRoll.Command.SpeedSetpoint)","11"
RCOMMENT,"LineDrives","FeedRoll","****$NScale the analog input to engineering units.$N****","DriveRamp(Scale_Smoothing1,ScaleBeltScaler.ScaledOutput,ScaleDisplayAverageSeconds,ScaleDisplayAverageSeconds,MaximumProduction,MainScaleActWeight,1)","12"
RCOMMENT,"LineDrives","FeedRoll","****$NThe commanded speed is based on the mode.  In run$Nmode the speed is the speed of the drive it follows multiplied$Nby the draw.  In Maint mode it runs at its maintenance mode speed setpoint.  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are in seconds.$NThese should always be less so than the line speed rates so the drives will follow the line ramp.$N****","MOV(FeedRoll.Internal.DecelTime,FeedRoll.Internal.DecelTime)","16"
RCOMMENT,"LineDrives","FeedRoll","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$NTo reverse the drive direction, reverse the reference.$N****","NEG(FeedRoll.Internal.SpeedReference.ScaledOutput,FeedRoll.Outputs.SetSpeed)","17"
RCOMMENT,"LineDrives","FeedRoll","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(FeedRoll.Outputs.DriveCommandWord.Enable2)","18"
RCOMMENT,"LineDrives","FeedRoll","****$NInhibit the drive when it is not being told to run.$N****","OTE(FeedRoll.Outputs.DriveCommandWord.ControllerInhibit)","19"
RCOMMENT,"LineDrives","FeedRoll","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(FeedRoll.Internal.ActualSpeedScaler.ScaledOutput,FeedRoll.Status.ActualSpeed)","20"
RCOMMENT,"LineDrives","FeedRoll","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(FeedRoll.Internal.LoadScaler.ScaledOutput,FeedRoll.Status.MotorLoad)","21"
RCOMMENT,"LineDrives","FeedRoll","****$NDrive Running Status$N****","OTE(FeedRoll.Status.Running)","22"
RCOMMENT,"LineDrives","FeedRoll","****$NJogging Forward Status$N****","OTE(FeedRoll.Status.JoggingFwd)","23"
RCOMMENT,"LineDrives","FeedRoll","****$NJogging Reverse Status$N****","OTE(FeedRoll.Status.JoggingRev)","24"
RCOMMENT,"LineDrives","FeedRoll","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(FeedRoll.Status.FailedToStart)","25"
RCOMMENT,"LineDrives","FeedRoll","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(FeedRoll.Status.FailedToStop)","26"
RCOMMENT,"LineDrives","FeedRoll","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(FeedRoll.Status.Faulted)","27"
RCOMMENT,"LineDrives","FeedRoll","****$NUnlatch the Drive Faulted Status$N****","OTU(FeedRoll.Status.FailedToStop)","28"
RCOMMENT,"LineDrives","LineControl","****$NLine to Run Mode$N****","OTU(System.Command.ToRunMode)","0"
RCOMMENT,"LineDrives","LineControl","****$NLine to Maint Mode$N****","OTU(System.Command.ToMaintMode)","1"
RCOMMENT,"LineDrives","LineControl","****$NThread mode allows the line to be threaded.  The enabled drives past the crosslapper will be$Njogged momentarily.  The card drives will not be jogged.$N****","OTE(System.Status.ThreadModeEnabled)","2"
RCOMMENT,"LineDrives","LineControl","****$NEnable web break detection.$N****","OTE(System.Status.WebBreakDetectEnabled)","3"
RCOMMENT,"LineDrives","LineControl","****$NWhen the web break detection is enabled, it looks at the detectors$Nfor web break.$N****","OTE(System.Status.WebBreakDetected)","4"
RCOMMENT,"LineDrives","LineControl","****$NEach permissive for line run is set up for display on the screen.$NAll the permissives will be used below to form the main permissive.$N****$N!!!!  FIRST SCAN LOOKS AS IF IT$'S NOT PASSING POWER, BUT THE COIL IS ON  !!!!$N****","OTE(System.Status.LineRunPermissive[0])","5"
RCOMMENT,"LineDrives","LineControl","****$NEach permissive for line run is set up for display on the screen.$NAll the permissives will be used below to form the main permissive.$N****","OTE(System.Status.LineRunPermissive[1])","6"
RCOMMENT,"LineDrives","LineControl","****$NEach permissive for line run is set up for display on the screen.$NAll the permissives will be used below to form the main permissive.$N****","OTE(System.Status.LineRunPermissive[2])","7"
RCOMMENT,"LineDrives","LineControl","****$NEach permissive for line run is set up for display on the screen.$NAll the permissives will be used below to form the main permissive.$N****","OTE(System.Status.LineRunPermissive[3])","8"
RCOMMENT,"LineDrives","LineControl","****$NEach permissive for line run is set up for display on the screen.$NAll the permissives will be used below to form the main permissive.$N****","OTE(System.Status.LineRunPermissive[4])","9"
RCOMMENT,"LineDrives","LineControl","****$NEach permissive for line run is set up for display on the screen.$NAll the permissives will be used below to form the main permissive.$N****","OTE(System.Status.LineRunPermissive[5])","10"
RCOMMENT,"LineDrives","LineControl","****$NEach permissive for line run is set up for display on the screen.$NAll the permissives will be used below to form the main permissive.$N****","OTE(System.Status.LineRunPermissive[6])","11"
RCOMMENT,"LineDrives","LineControl","****$NEach permissive for line run is set up for display on the screen.$NAll the permissives will be used below to form the main permissive.$N****","OTE(System.Status.LineRunPermissive[7])","12"
RCOMMENT,"LineDrives","LineControl","****$NEach permissive for line run is set up for display on the screen.$NAll the permissives will be used below to form the main permissive.$N****","OTE(System.Status.LineRunPermissive[8])","13"
RCOMMENT,"LineDrives","LineControl","****$NEach permissive for line run is set up for display on the screen.$NAll the permissives will be used below to form the main permissive.$N****","OTE(System.Status.LineRunPermissive[9])","14"
RCOMMENT,"LineDrives","LineControl","****$NEach permissive for line run is set up for display on the screen.$NAll the permissives will be used below to form the main permissive.$N****","OTE(System.Status.LineRunPermissive[10])","15"
RCOMMENT,"LineDrives","LineControl","****$NThe master run permissive is the end result of all the permissives above.$N$NIF ANY PERMISSIVES ARE ADDED ABOVE, MAKE CERTAIN$NTHEY ARE ADDED TO THE MASTER RUNG$N****","OTE(System.Status.MasterLineRunPermissive)","16"
RCOMMENT,"LineDrives","LineControl","****$NIf the permissive is lost, use fast decel.  Seal it in until the line stops.$N****","OTE(System.Status.FastStopActive)","17"
RCOMMENT,"LineDrives","LineControl","****$NThe normal stop array will be used later in a string for a normal stop main.$NThe bits need to be a 1.  If any bit goes low, the line will stop normally (not fast stop).$N****","OTE(System.Internal.NormalStop[0])","18"
RCOMMENT,"LineDrives","LineControl","****$NThe normal stop array will be used later in a string for a normal stop main.$NThe bits need to be a 1.  If any bit goes low, the line will stop normally (not fast stop).$N****","OTE(System.Internal.NormalStop[1])","19"
RCOMMENT,"LineDrives","LineControl","****$NThe normal stop array will be used later in a string for a normal stop main.$NThe bits need to be a 1.  If any bit goes low, the line will stop normally (not fast stop).$N****","OTE(System.Internal.NormalStop[2])","20"
RCOMMENT,"LineDrives","LineControl","****$NThe normal stop array will be used later in a string for a normal stop main.$NThe bits need to be a 1.  If any bit goes low, the line will stop normally (not fast stop).$N****","OTE(System.Internal.NormalStop[3])","21"
RCOMMENT,"LineDrives","LineControl","****$NThe normal stop array will be used later in a string for a normal stop main.$NThe bits need to be a 1.  If any bit goes low, the line will stop normally (not fast stop).$N****","OTE(System.Internal.NormalStop[4])","22"
RCOMMENT,"LineDrives","LineControl","****$NThe normal stop array will be used later in a string for a normal stop main.$NThe bits need to be a 1.  If any bit goes low, the line will stop normally (not fast stop).$N****","OTE(System.Internal.NormalStop[5])","23"
RCOMMENT,"LineDrives","LineControl","****$NThe normal stop array will be used later in a string for a normal stop main.$NThe bits need to be a 1.  If any bit goes low, the line will stop normally (not fast stop).$N****","OTE(System.Internal.NormalStop[6])","24"
RCOMMENT,"LineDrives","LineControl","****$NThe normal stop array will be used later in a string for a normal stop main.$NThe bits need to be a 1.  If any bit goes low, the line will stop normally (not fast stop).$N****","OTE(System.Internal.NormalStop[7])","25"
RCOMMENT,"LineDrives","LineControl","****$NThe normal stop array will be used later in a string for a normal stop main.$NThe bits need to be a 1.  If any bit goes low, the line will stop normally (not fast stop).$N****","OTE(System.Internal.NormalStop[8])","26"
RCOMMENT,"LineDrives","LineControl","****$NThe normal stop array will be used later in a string for a normal stop main.$NThe bits need to be a 1.  If any bit goes low, the line will stop normally (not fast stop).$N****","OTE(System.Internal.NormalStop[9])","27"
RCOMMENT,"LineDrives","LineControl","****$NThe normal stop array will be used later in a string for a normal stop main.$NThe bits need to be a 1.  If any bit goes low, the line will stop normally (not fast stop).$N****","OTE(System.Internal.NormalStop[10])","28"
RCOMMENT,"LineDrives","LineControl","****$NAll the normal stops must be high making the normal stop main high to allow$Nthe line to run.$N****","OTE(System.Status.MasterNormalStop)","29"
RCOMMENT,"LineDrives","LineControl","****$NAll the card drives must be enabled in order to start the line in production mode.$N****","OTE(Card_Enabled)","30"
RCOMMENT,"LineDrives","LineControl","****$NThe line ready must be active to start the line.$N****","OTE(Line_Ready)","31"
RCOMMENT,"LineDrives","LineControl","****$NDisplay for HMI$N****","OTE(HMI_ExitEquipmentReady)","32"
RCOMMENT,"LineDrives","LineControl","****$NJust for eyeballing.$N****","OTE(Crosslapper_Info)","33"
RCOMMENT,"LineDrives","LineControl","****$NJust for eyeballing.$N****","OTE(Looms_Info)","34"
RCOMMENT,"LineDrives","LineControl","****$NStart the drives after the delay$N****$NThe one shot prevents a stuck button from continuously starting the line","OTE(System.Internal.StartDrives)","35"
RCOMMENT,"LineDrives","LineControl","****$NWhen all the enabled drives are running, release the ramp.$N****","OTE(System.Internal.ReleaseLineRamp)","37"
RCOMMENT,"LineDrives","LineControl","****$NWhen the drives are being told to start but do not, the line$Nhas failed to start thus unlatching the start drives command.$N****","TON(System.Internal.LineFailedToStartTimer,?,?)","38"
RCOMMENT,"LineDrives","LineControl","****$NThe main ramp will ramp from 0-100% when the line is running.$N****","LineSpeedRamp(System.Internal.MasterRamp,System.Command.NormalAccel,System.Command.NormalDecel,100,System.Command.EStopDecel,System.Internal.ReleaseLineRamp,System.Status.AtZeroSpeed,100,System.Internal.RampedMasterRef,System.Status.FastStopActive,No)","39"
RCOMMENT,"LineDrives","LineControl","****$NLine Thread Command$N****","OTE(System.Internal.ThreadModeJog)","40"
RCOMMENT,"LineDrives","LineControl","****$NIf the line is not a zero speed, it is still being told to run.$N****","OTE(System.Internal.LineDrivesRunning)","41"
RCOMMENT,"LineDrives","LineControl","****$NActivate Slow Mode for Low Fiber$N****","OTE(FS5XLowFiberAlarmSlowMode)","46"
RCOMMENT,"LineDrives","LineControl","****$NIf the blending system faults/stops during a line run, the alarm will go off$Nand this rung will put the line into a slow mode.$N****","OTE(BlendingAlarmSlowMode)","47"
RCOMMENT,"LineDrives","LineControl","****$NEach time one of the inputs is made, the slow mode toggle$Nis activated.  Below, it is used to toggle slow mode.$N****","OTE(System.Command.SlowModeToggle)","48"
RCOMMENT,"LineDrives","LineControl","****$NThe flip flop output changes state every time the input is high.$NWhen the line slow pushbutton is pressed, the line slow active bit$Nwill change states.$N****","JKFlipFLop(System.Internal.SlowModeFlipFlop,System.Command.SlowModeToggle,System.Status.SlowModeActive,No)","49"
RCOMMENT,"LineDrives","LineControl","****$NIncrement the Web Percent$N****","ADD(System.Command.WebSpeedPercent,System.Command.WebPercentStep,System.Command.WebSpeedPercent)","50"
RCOMMENT,"LineDrives","LineControl","****$NDecrement the Web Percent Line Speed$N****","SUB(System.Command.WebSpeedPercent,System.Command.WebPercentStep,System.Command.WebSpeedPercent)","51"
RCOMMENT,"LineDrives","LineControl","****$NWhen the line stops, put 30 percent into the line speed.$N****","MOV(30,System.Command.WebSpeedPercent)","52"
RCOMMENT,"LineDrives","LineControl","****$NWhen the line is not running, allow the ramp to get to setpoint faster.  When running,$Nuse the normal ramps set at the master ramp.$N****","MOV(5,System.Internal.WebRampDecel)","53"
RCOMMENT,"LineDrives","LineControl","****$NOnce the speed is checked against its limits, it$Nis sent to the ramp.  Because this is the web percent ramp,$Nit is always active.  The master ramp will ramp to zero to take the $Nline down.$N****","LineSpeedRamp(System.Internal.WebPercentRamp,System.Internal.WebRampAccel,System.Internal.WebRampDecel,100,System.Internal.WebRampDecel,Yes,NotApplicable,System.Internal.WebPercentToRamp,System.Internal.RampedWebPercent,Yes,No)","54"
RCOMMENT,"LineDrives","LineControl","****$NMonitoring$N****","MOV(System.Internal.RampedWebPercent,System.Internal.RampedWebPercent)","55"
RCOMMENT,"LineDrives","LineDrivesMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(LineControl,0)","0"
RCOMMENT,"LineDrives","LineDrivesMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(DrafterEntryApron,0)","1"
RCOMMENT,"LineDrives","LineDrivesMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BottomDoffer,0)","2"
RCOMMENT,"LineDrives","LineDrivesMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BottomScrambler,0)","3"
RCOMMENT,"LineDrives","LineDrivesMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BottomTakeoff,0)","4"
RCOMMENT,"LineDrives","LineDrivesMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(BottomTOFBelt,0)","5"
RCOMMENT,"LineDrives","LineDrivesMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Calender,0)","6"
RCOMMENT,"LineDrives","LineDrivesMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Crosslapper,0)","7"
RCOMMENT,"LineDrives","LineDrivesMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(DrafterGroup1,0)","8"
RCOMMENT,"LineDrives","LineDrivesMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(DrafterGroup2,0)","9"
RCOMMENT,"LineDrives","LineDrivesMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(DrafterGroup3,0)","10"
RCOMMENT,"LineDrives","LineDrivesMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(DrafterGroup4,0)","11"
RCOMMENT,"LineDrives","LineDrivesMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(DrafterGroup5,0)","12"
RCOMMENT,"LineDrives","LineDrivesMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(DrawCalculations,0)","13"
RCOMMENT,"LineDrives","LineDrivesMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(FeedRoll,0)","14"
RCOMMENT,"LineDrives","LineDrivesMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(MainCylinder,0)","15"
RCOMMENT,"LineDrives","LineDrivesMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(ScaleBelt,0)","16"
RCOMMENT,"LineDrives","LineDrivesMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(TopDoffer,0)","17"
RCOMMENT,"LineDrives","LineDrivesMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(TopScrambler,0)","18"
RCOMMENT,"LineDrives","LineDrivesMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(TopTakeoff,0)","19"
RCOMMENT,"LineDrives","LineDrivesMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(TopTOFBelt,0)","20"
RCOMMENT,"LineDrives","LineDrivesMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Worker,0)","21"
RCOMMENT,"LineDrives","MainCylinder","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(MainCylinder.Internal.Permissive)","0"
RCOMMENT,"LineDrives","MainCylinder","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(MainCylinder.Command.Enable)","1"
RCOMMENT,"LineDrives","MainCylinder","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(MainCylinder.Command.Disable)","2"
RCOMMENT,"LineDrives","MainCylinder","****$NJog Command$N****","OTE(MainCylinder.Internal.IntermediateJog)","3"
RCOMMENT,"LineDrives","MainCylinder","****$NWhen the drive is jogged reverse, the reverse bit is latched in$Nuntil the ramp returns to zero.$N****","OTE(MainCylinder.Internal.DriveReverse)","4"
RCOMMENT,"LineDrives","MainCylinder","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(MainCylinder.Internal.MaintModeRun)","5"
RCOMMENT,"LineDrives","MainCylinder","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(MainCylinder.Internal.ReleaseRamp)","6"
RCOMMENT,"LineDrives","MainCylinder","****$NThe speed may be incremented/decremented$Nby the step change value.  It is then checked against pre-determined values.$N****","SUB(MainCylinder.Command.SpeedSetpoint,MainCylinder.Command.StepChangeValue,MainCylinder.Command.SpeedSetpoint)","7"
RCOMMENT,"LineDrives","MainCylinder","****$NThe commanded speed is calculated based on speed setpoint$Nmultiplied by the line speed (in percent).  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are based on the line speed accel and decel.$NThese should always be less so than the line speed$'s so the drives will follow the line ramp.$N****","MOV(System.Internal.EStopDecelTime,MainCylinder.Internal.DecelTime)","8"
RCOMMENT,"LineDrives","MainCylinder","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","NEG(MainCylinder.Internal.SpeedReference.ScaledOutput,MainCylinder.Outputs.SetSpeed)","9"
RCOMMENT,"LineDrives","MainCylinder","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","TOF(MainCylinder_Stanstill,?,?)","10"
RCOMMENT,"LineDrives","MainCylinder","****$NInhibit the drive when it is not being told to run.$N****","OTE(MainCylinder.Outputs.DriveCommandWord.ControllerInhibit)","12"
RCOMMENT,"LineDrives","MainCylinder","****$NScale the raw analog signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(System.Internal.RampedMasterRef,System.Internal.MainCylSpeedPercent)","13"
RCOMMENT,"LineDrives","MainCylinder","****$NDepending on the mode, scale the proper feedback$Nfor load display on the HMI$N****","MOV(MainCylinder.Internal.LoadScaler.ScaledOutput,MainCylinder.Status.MotorLoad)","14"
RCOMMENT,"LineDrives","MainCylinder","****$NDrive Running Status$N****","OTE(MainCylinder.Status.Running)","15"
RCOMMENT,"LineDrives","MainCylinder","****$NJogging Forward Status$N****","OTE(MainCylinder.Status.JoggingFwd)","16"
RCOMMENT,"LineDrives","MainCylinder","****$NJogging Reverse Status$N****","OTE(MainCylinder.Status.JoggingRev)","17"
RCOMMENT,"LineDrives","MainCylinder","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(MainCylinder.Status.FailedToStart)","18"
RCOMMENT,"LineDrives","MainCylinder","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(MainCylinder.Status.FailedToStop)","19"
RCOMMENT,"LineDrives","MainCylinder","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(MainCylinder.Status.Faulted)","20"
RCOMMENT,"LineDrives","MainCylinder","****$NUnlatch the Drive Faulted Status$N****","OTU(MainCylinder.Status.FailedToStop)","21"
RCOMMENT,"LineDrives","ScaleBelt","****$NPermissives to Operate Drive$N****","OTE(ScaleBelt.Internal.Permissive)","0"
RCOMMENT,"LineDrives","ScaleBelt","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(ScaleBelt.Command.Enable)","1"
RCOMMENT,"LineDrives","ScaleBelt","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(ScaleBelt.Command.Disable)","2"
RCOMMENT,"LineDrives","ScaleBelt","****$NJog Command$N****","OTE(ScaleBelt.Internal.IntermediateJog)","3"
RCOMMENT,"LineDrives","ScaleBelt","****$NWhen the drive is jogged reverse, the reverse bit is latched in$Nuntil the ramp returns to zero.$N****","OTE(ScaleBelt.Internal.DriveReverse)","4"
RCOMMENT,"LineDrives","ScaleBelt","****$NIf the line is in maintenance mode, the drive may be run$Nindividually.$N****","OTE(ScaleBelt.Internal.MaintModeRun)","5"
RCOMMENT,"LineDrives","ScaleBelt","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(ScaleBelt.Internal.ReleaseRamp)","6"
RCOMMENT,"LineDrives","ScaleBelt","****$NThe speed may be incremented/decremented$Nby the step change value.  It is then checked against pre-determined values.$N****","MOV(ScaleBelt.Command.DrawSetpointMin,ScaleBelt.Command.DrawSetpoint)","7"
RCOMMENT,"LineDrives","ScaleBelt","****$NThe commanded speed is based on the mode.  In run$Nmode the speed is the speed of the drive it follows multiplied$Nby the draw.  In Maint mode it runs at its maintenance mode speed setpoint.  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are in seconds.$NThese should always be less so than the line speed rates so the drives will follow the line ramp.$N****","MOV(ScaleBelt.Internal.DecelTime,ScaleBelt.Internal.DecelTime)","8"
RCOMMENT,"LineDrives","ScaleBelt","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$NTo reverse the drive direction, reverse the reference.$N****","NEG(ScaleBelt.Internal.SpeedReference.ScaledOutput,ScaleBelt.Outputs.SetSpeed)","9"
RCOMMENT,"LineDrives","ScaleBelt","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(Start_Chute_Delivery)","10"
RCOMMENT,"LineDrives","ScaleBelt","****$NInhibit the drive when it is not being told to run.$N****","OTE(ScaleBelt.Outputs.DriveCommandWord.ControllerInhibit)","11"
RCOMMENT,"LineDrives","ScaleBelt","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(ScaleBelt.Internal.ActualSpeedScaler.ScaledOutput,ScaleBelt.Status.ActualSpeed)","12"
RCOMMENT,"LineDrives","ScaleBelt","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(ScaleBelt.Internal.LoadScaler.ScaledOutput,ScaleBelt.Status.MotorLoad)","13"
RCOMMENT,"LineDrives","ScaleBelt","****$NDrive Running Status$N****","OTE(ScaleBelt.Status.Running)","14"
RCOMMENT,"LineDrives","ScaleBelt","****$NJogging Forward Status$N****","OTE(ScaleBelt.Status.JoggingFwd)","15"
RCOMMENT,"LineDrives","ScaleBelt","****$NJogging Reverse Status$N****","OTE(ScaleBelt.Status.JoggingRev)","16"
RCOMMENT,"LineDrives","ScaleBelt","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(ScaleBelt.Status.FailedToStart)","17"
RCOMMENT,"LineDrives","ScaleBelt","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(ScaleBelt.Status.FailedToStop)","18"
RCOMMENT,"LineDrives","ScaleBelt","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(ScaleBelt.Status.Faulted)","19"
RCOMMENT,"LineDrives","ScaleBelt","****$NUnlatch the Drive Faulted Status$N****","OTU(ScaleBelt.Status.FailedToStop)","20"
RCOMMENT,"LineDrives","TopDoffer","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(TopDoffer.Internal.Permissive)","0"
RCOMMENT,"LineDrives","TopDoffer","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(TopDoffer.Command.Enable)","1"
RCOMMENT,"LineDrives","TopDoffer","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(TopDoffer.Command.Disable)","2"
RCOMMENT,"LineDrives","TopDoffer","****$NJog Command$N****","OTE(TopDoffer.Internal.IntermediateJog)","3"
RCOMMENT,"LineDrives","TopDoffer","****$NWhen the drive is jogged reverse, the reverse bit is latched in$Nuntil the ramp returns to zero.$N****","OTE(TopDoffer.Internal.DriveReverse)","4"
RCOMMENT,"LineDrives","TopDoffer","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(TopDoffer.Internal.MaintModeRun)","5"
RCOMMENT,"LineDrives","TopDoffer","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(TopDoffer.Internal.ReleaseRamp)","6"
RCOMMENT,"LineDrives","TopDoffer","****$NThe speed may be incremented/decremented$Nby the step change value.  It is then checked against pre-determined values.$N****","SUB(TopDoffer.Command.SpeedSetpoint,TopDoffer.Command.StepChangeValue,TopDoffer.Command.SpeedSetpoint)","7"
RCOMMENT,"LineDrives","TopDoffer","****$NThe commanded speed is calculated based on speed setpoint$Nmultiplied by the line speed (in percent).  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are based on the line speed accel and decel.$NThese should always be less so than the line speed$'s so the drives will follow the line ramp.$N****","MOV(TopDoffer.Internal.DecelTime,TopDoffer.Internal.DecelTime)","8"
RCOMMENT,"LineDrives","TopDoffer","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","NEG(TopDoffer.Internal.SpeedReference.ScaledOutput,TopDoffer.Outputs.SetSpeed)","9"
RCOMMENT,"LineDrives","TopDoffer","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(TopDoffer.Outputs.DriveCommandWord.Enable2)","10"
RCOMMENT,"LineDrives","TopDoffer","****$NInhibit the drive when it is not being told to run.$N****","OTE(TopDoffer.Outputs.DriveCommandWord.ControllerInhibit)","11"
RCOMMENT,"LineDrives","TopDoffer","****$NScale the raw analog signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(TopDoffer.Internal.ActualSpeedScaler.ScaledOutput,TopDoffer.Status.ActualSpeed)","12"
RCOMMENT,"LineDrives","TopDoffer","****$NDepending on the mode, scale the proper feedback$Nfor load display on the HMI$N****","MOV(TopDoffer.Internal.LoadScaler.ScaledOutput,TopDoffer.Status.MotorLoad)","13"
RCOMMENT,"LineDrives","TopDoffer","****$NDrive Running Status$N****","OTE(TopDoffer.Status.Running)","14"
RCOMMENT,"LineDrives","TopDoffer","****$NJogging Forward Status$N****","OTE(TopDoffer.Status.JoggingFwd)","15"
RCOMMENT,"LineDrives","TopDoffer","****$NJogging Reverse Status$N****","OTE(TopDoffer.Status.JoggingRev)","16"
RCOMMENT,"LineDrives","TopDoffer","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(TopDoffer.Status.FailedToStart)","17"
RCOMMENT,"LineDrives","TopDoffer","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(TopDoffer.Status.FailedToStop)","18"
RCOMMENT,"LineDrives","TopDoffer","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(TopDoffer.Status.Faulted)","19"
RCOMMENT,"LineDrives","TopDoffer","****$NUnlatch the Drive Faulted Status$N****","OTU(TopDoffer.Status.FailedToStop)","20"
RCOMMENT,"LineDrives","TopScrambler","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(TopScrambler.Internal.Permissive)","0"
RCOMMENT,"LineDrives","TopScrambler","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(TopScrambler.Command.Enable)","1"
RCOMMENT,"LineDrives","TopScrambler","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(TopScrambler.Command.Disable)","2"
RCOMMENT,"LineDrives","TopScrambler","****$NJog Command$N****","OTE(TopScrambler.Internal.IntermediateJog)","3"
RCOMMENT,"LineDrives","TopScrambler","****$NWhen the drive is jogged reverse, the reverse bit is latched in$Nuntil the ramp returns to zero.$N****","OTE(TopScrambler.Internal.DriveReverse)","4"
RCOMMENT,"LineDrives","TopScrambler","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(TopScrambler.Internal.MaintModeRun)","5"
RCOMMENT,"LineDrives","TopScrambler","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(TopScrambler.Internal.ReleaseRamp)","6"
RCOMMENT,"LineDrives","TopScrambler","****$NThe speed may be incremented/decremented$Nby the step change value.  It is then checked against pre-determined values.$N****","SUB(TopScrambler.Command.SpeedSetpoint,TopScrambler.Command.StepChangeValue,TopScrambler.Command.SpeedSetpoint)","7"
RCOMMENT,"LineDrives","TopScrambler","****$NThe commanded speed is calculated based on speed setpoint$Nmultiplied by the line speed (in percent).  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are based on the line speed accel and decel.$NThese should always be less so than the line speed$'s so the drives will follow the line ramp.$N****","MOV(TopScrambler.Internal.DecelTime,TopScrambler.Internal.DecelTime)","8"
RCOMMENT,"LineDrives","TopScrambler","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","NEG(TopScrambler.Internal.SpeedReference.ScaledOutput,TopScrambler.Outputs.SetSpeed)","9"
RCOMMENT,"LineDrives","TopScrambler","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(TopScrambler.Outputs.DriveCommandWord.Enable2)","10"
RCOMMENT,"LineDrives","TopScrambler","****$NInhibit the drive when it is not being told to run.$N****","OTE(TopScrambler.Outputs.DriveCommandWord.ControllerInhibit)","11"
RCOMMENT,"LineDrives","TopScrambler","****$NScale the raw analog signal coming from the drive$Nto engineering units for display on the HMI.$N****","MUL(TopScrambler.Status.ActualSpeed,TopScramblerRoll2Ratio,HMITopScramblerRoll2Speed)","12"
RCOMMENT,"LineDrives","TopScrambler","****$NDepending on the mode, scale the proper feedback$Nfor load display on the HMI$N****","MOV(TopScrambler.Internal.LoadScaler.ScaledOutput,TopScrambler.Status.MotorLoad)","13"
RCOMMENT,"LineDrives","TopScrambler","****$NDrive Running Status$N****","OTE(TopScrambler.Status.Running)","14"
RCOMMENT,"LineDrives","TopScrambler","****$NJogging Forward Status$N****","OTE(TopScrambler.Status.JoggingFwd)","15"
RCOMMENT,"LineDrives","TopScrambler","****$NJogging Reverse Status$N****","OTE(TopScrambler.Status.JoggingRev)","16"
RCOMMENT,"LineDrives","TopScrambler","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(TopScrambler.Status.FailedToStart)","17"
RCOMMENT,"LineDrives","TopScrambler","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(TopScrambler.Status.FailedToStop)","18"
RCOMMENT,"LineDrives","TopScrambler","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(TopScrambler.Status.Faulted)","19"
RCOMMENT,"LineDrives","TopScrambler","****$NUnlatch the Drive Faulted Status$N****","OTU(TopScrambler.Status.FailedToStop)","20"
RCOMMENT,"LineDrives","TopTakeoff","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(TopTakeoff.Internal.Permissive)","0"
RCOMMENT,"LineDrives","TopTakeoff","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(TopTakeoff.Command.Enable)","1"
RCOMMENT,"LineDrives","TopTakeoff","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(TopTakeoff.Command.Disable)","2"
RCOMMENT,"LineDrives","TopTakeoff","****$NJog Command$N****","OTE(TopTakeoff.Internal.IntermediateJog)","3"
RCOMMENT,"LineDrives","TopTakeoff","****$NWhen the drive is jogged reverse, the reverse bit is latched in$Nuntil the ramp returns to zero.$N****","OTE(TopTakeoff.Internal.DriveReverse)","4"
RCOMMENT,"LineDrives","TopTakeoff","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(TopTakeoff.Internal.MaintModeRun)","5"
RCOMMENT,"LineDrives","TopTakeoff","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(TopTakeoff.Internal.ReleaseRamp)","6"
RCOMMENT,"LineDrives","TopTakeoff","****$NThe speed may be incremented/decremented$Nby the step change value.  It is then checked against pre-determined values.$N****","SUB(TopTakeoff.Command.SpeedSetpoint,TopTakeoff.Command.StepChangeValue,TopTakeoff.Command.SpeedSetpoint)","7"
RCOMMENT,"LineDrives","TopTakeoff","****$NThe commanded speed is calculated based on speed setpoint$Nmultiplied by the line speed (in percent).  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are based on the line speed accel and decel.$NThese should always be less so than the line speed$'s so the drives will follow the line ramp.$N****","MOV(TopTakeoff.Internal.DecelTime,TopTakeoff.Internal.DecelTime)","8"
RCOMMENT,"LineDrives","TopTakeoff","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","NEG(TopTakeoff.Internal.SpeedReference.ScaledOutput,TopTakeoff.Outputs.SetSpeed)","9"
RCOMMENT,"LineDrives","TopTakeoff","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(TopTakeoff.Outputs.DriveCommandWord.Enable2)","10"
RCOMMENT,"LineDrives","TopTakeoff","****$NInhibit the drive when it is not being told to run.$N****","OTE(TopTakeoff.Outputs.DriveCommandWord.ControllerInhibit)","11"
RCOMMENT,"LineDrives","TopTakeoff","****$NScale the raw analog signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(TopTakeoff.Internal.ActualSpeedScaler.ScaledOutput,TopTakeoff.Status.ActualSpeed)","12"
RCOMMENT,"LineDrives","TopTakeoff","****$NDepending on the mode, scale the proper feedback$Nfor load display on the HMI$N****","MOV(TopTakeoff.Internal.LoadScaler.ScaledOutput,TopTakeoff.Status.MotorLoad)","13"
RCOMMENT,"LineDrives","TopTakeoff","****$NDrive Running Status$N****","OTE(TopTakeoff.Status.Running)","14"
RCOMMENT,"LineDrives","TopTakeoff","****$NJogging Forward Status$N****","OTE(TopTakeoff.Status.JoggingFwd)","15"
RCOMMENT,"LineDrives","TopTakeoff","****$NJogging Reverse Status$N****","OTE(TopTakeoff.Status.JoggingRev)","16"
RCOMMENT,"LineDrives","TopTakeoff","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(TopTakeoff.Status.FailedToStart)","17"
RCOMMENT,"LineDrives","TopTakeoff","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(TopTakeoff.Status.FailedToStop)","18"
RCOMMENT,"LineDrives","TopTakeoff","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(TopTakeoff.Status.Faulted)","19"
RCOMMENT,"LineDrives","TopTakeoff","****$NUnlatch the Drive Faulted Status$N****","OTU(TopTakeoff.Status.FailedToStop)","20"
RCOMMENT,"LineDrives","TopTOFBelt","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(TopTOFBelt.Internal.Permissive)","0"
RCOMMENT,"LineDrives","TopTOFBelt","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(TopTOFBelt.Command.Enable)","1"
RCOMMENT,"LineDrives","TopTOFBelt","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(TopTOFBelt.Command.Disable)","2"
RCOMMENT,"LineDrives","TopTOFBelt","****$NJog Command$N****","OTE(TopTOFBelt.Internal.IntermediateJog)","3"
RCOMMENT,"LineDrives","TopTOFBelt","****$NWhen the drive is jogged reverse, the reverse bit is latched in$Nuntil the ramp returns to zero.$N****","OTE(TopTOFBelt.Internal.DriveReverse)","4"
RCOMMENT,"LineDrives","TopTOFBelt","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(TopTOFBelt.Internal.MaintModeRun)","5"
RCOMMENT,"LineDrives","TopTOFBelt","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(TopTOFBelt.Internal.ReleaseRamp)","6"
RCOMMENT,"LineDrives","TopTOFBelt","****$NThe speed may be incremented/decremented$Nby the step change value.  It is then checked against pre-determined values.$N****","SUB(TopTOFBelt.Command.SpeedSetpoint,TopTOFBelt.Command.StepChangeValue,TopTOFBelt.Command.SpeedSetpoint)","7"
RCOMMENT,"LineDrives","TopTOFBelt","****$NThe commanded speed is calculated based on speed setpoint$Nmultiplied by the line speed (in percent).  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are based on the line speed accel and decel.$NThese should always be less so than the line speed$'s so the drives will follow the line ramp.$N****","MOV(TopTOFBelt.Internal.DecelTime,TopTOFBelt.Internal.DecelTime)","8"
RCOMMENT,"LineDrives","TopTOFBelt","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","NEG(TopTOFBelt.Internal.SpeedReference.ScaledOutput,TopTOFBelt.Outputs.SetSpeed)","9"
RCOMMENT,"LineDrives","TopTOFBelt","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(TopTOFBelt.Outputs.DriveCommandWord.Enable2)","10"
RCOMMENT,"LineDrives","TopTOFBelt","****$NInhibit the drive when it is not being told to run.$N****","OTE(TopTOFBelt.Outputs.DriveCommandWord.ControllerInhibit)","11"
RCOMMENT,"LineDrives","TopTOFBelt","****$NScale the raw analog signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(TopTOFBelt.Internal.ActualSpeedScaler.ScaledOutput,TopTOFBelt.Status.ActualSpeed)","12"
RCOMMENT,"LineDrives","TopTOFBelt","****$NDepending on the mode, scale the proper feedback$Nfor load display on the HMI$N****","MOV(TopTOFBelt.Internal.LoadScaler.ScaledOutput,TopTOFBelt.Status.MotorLoad)","13"
RCOMMENT,"LineDrives","TopTOFBelt","****$NDrive Running Status$N****","OTE(TopTOFBelt.Status.Running)","14"
RCOMMENT,"LineDrives","TopTOFBelt","****$NJogging Forward Status$N****","OTE(TopTOFBelt.Status.JoggingFwd)","15"
RCOMMENT,"LineDrives","TopTOFBelt","****$NJogging Reverse Status$N****","OTE(TopTOFBelt.Status.JoggingRev)","16"
RCOMMENT,"LineDrives","TopTOFBelt","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(TopTOFBelt.Status.FailedToStart)","17"
RCOMMENT,"LineDrives","TopTOFBelt","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(TopTOFBelt.Status.FailedToStop)","18"
RCOMMENT,"LineDrives","TopTOFBelt","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(TopTOFBelt.Status.Faulted)","19"
RCOMMENT,"LineDrives","TopTOFBelt","****$NUnlatch the Drive Faulted Status$N****","OTU(TopTOFBelt.Status.FailedToStop)","20"
RCOMMENT,"LineDrives","Worker","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(Worker.Internal.Permissive)","0"
RCOMMENT,"LineDrives","Worker","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(Worker.Command.Enable)","1"
RCOMMENT,"LineDrives","Worker","****$NIf the line is not running, the drive may be enabled/disabled.$N****","OTU(Worker.Command.Disable)","2"
RCOMMENT,"LineDrives","Worker","****$NJog Command$N****","OTE(Worker.Internal.IntermediateJog)","3"
RCOMMENT,"LineDrives","Worker","****$NWhen the drive is jogged reverse, the reverse bit is latched in$Nuntil the ramp returns to zero.$N****","OTE(Worker.Internal.DriveReverse)","4"
RCOMMENT,"LineDrives","Worker","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(Worker.Internal.MaintModeRun)","5"
RCOMMENT,"LineDrives","Worker","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(Worker.Internal.ReleaseRamp)","6"
RCOMMENT,"LineDrives","Worker","****$NThe speed may be incremented/decremented$Nby the step change value.  It is then checked against pre-determined values.$N****","SUB(Worker.Command.SpeedSetpoint,Worker.Command.StepChangeValue,Worker.Command.SpeedSetpoint)","7"
RCOMMENT,"LineDrives","Worker","****$NThe commanded speed is calculated based on speed setpoint$Nmultiplied by the line speed (in percent).  If the drive has not been started (ramp release),$Na zero is moved to the ramp.  When the drive is started (ramp release) the calculated$Nspeed is sent to the ramp.  The accel and decel times are based on the line speed accel and decel.$NThese should always be less so than the line speed$'s so the drives will follow the line ramp.$N****","MOV(Worker.Internal.DecelTime,Worker.Internal.DecelTime)","8"
RCOMMENT,"LineDrives","Worker","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","NEG(Worker.Internal.SpeedReference.ScaledOutput,Worker.Outputs.SetSpeed)","9"
RCOMMENT,"LineDrives","Worker","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(Worker.Outputs.DriveCommandWord.Enable2)","10"
RCOMMENT,"LineDrives","Worker","****$NInhibit the drive when it is not being told to run.$N****","OTE(Worker.Outputs.DriveCommandWord.ControllerInhibit)","11"
RCOMMENT,"LineDrives","Worker","****$NScale the raw analog signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(Worker.Internal.ActualSpeedScaler.ScaledOutput,Worker.Status.ActualSpeed)","12"
RCOMMENT,"LineDrives","Worker","****$NDepending on the mode, scale the proper feedback$Nfor load display on the HMI$N****","MOV(Worker.Internal.LoadScaler.ScaledOutput,Worker.Status.MotorLoad)","13"
RCOMMENT,"LineDrives","Worker","****$NDrive Running Status$N****","OTE(Worker.Status.Running)","14"
RCOMMENT,"LineDrives","Worker","****$NJogging Forward Status$N****","OTE(Worker.Status.JoggingFwd)","15"
RCOMMENT,"LineDrives","Worker","****$NJogging Reverse Status$N****","OTE(Worker.Status.JoggingRev)","16"
RCOMMENT,"LineDrives","Worker","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(Worker.Status.FailedToStart)","17"
RCOMMENT,"LineDrives","Worker","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(Worker.Status.FailedToStop)","18"
RCOMMENT,"LineDrives","Worker","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(Worker.Status.Faulted)","19"
RCOMMENT,"LineDrives","Worker","****$NUnlatch the Drive Faulted Status$N****","OTU(Worker.Status.FailedToStop)","20"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"LineMotors","CardAspirationFan","****$NPermissives to Operate Motor.$N****","OTE(CardAspirationFan.Internal.Permissive)","0"
RCOMMENT,"LineMotors","CardAspirationFan","****$NCommand the Motor to Automatic Mode$N****","OTE(CardAspirationFan.Status.Enabled)","1"
RCOMMENT,"LineMotors","CardAspirationFan","****$NJog the Motor$N****","OTE(CardAspirationFan.Internal.IntermediateJogForward)","2"
RCOMMENT,"LineMotors","CardAspirationFan","****$NManual mode Start/Stop Logic$N****","OTE(CardAspirationFan.Internal.IntermediateRunForward)","3"
RCOMMENT,"LineMotors","CardAspirationFan","****$NPut logic here for automatic run of Motor.  The timers are for debounce.$N****","TOF(CardAspirationFan.Internal.AutoOffDelayTimer,?,?)","4"
RCOMMENT,"LineMotors","CardAspirationFan","****$NReset off delay if permissive is lost to prevent restart.$N****","RES(CardAspirationFan.Internal.AutoOffDelayTimer)","5"
RCOMMENT,"LineMotors","CardAspirationFan","****$NWhen the on delay above is done, the off delay comes on.  Only the off delay$Ndone bitis used for the run command.$N****","OTE(CardAspirationFan.Internal.AutoModeRun)","6"
RCOMMENT,"LineMotors","CardAspirationFan","****$NMotor Contactor Control$N****","OTE(AspirationFanRun)","7"
RCOMMENT,"LineMotors","CardAspirationFan","****$NMotor Running Status$N****","OTE(CardAspirationFan.Status.RunningForward)","8"
RCOMMENT,"LineMotors","CardAspirationFan","****$NIf the Motor is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(CardAspirationFan.Status.FailedToStart)","9"
RCOMMENT,"LineMotors","CardAspirationFan","****$NIf the Motor runs when it is not being told to, it has failed to stop.$N****","OTL(CardAspirationFan.Status.FailedToStop)","10"
RCOMMENT,"LineMotors","CardAspirationFan","****$NMotor Faulted Status$NThe faulted status is in the permissive and will stop the Motor.$N****","OTE(CardAspirationFan.Status.Faulted)","11"
RCOMMENT,"LineMotors","CardAspirationFan","****$NUnlatch the Motor Faulted Status$N****","OTU(CardAspirationFan.Status.FailedToStop)","12"
RCOMMENT,"LineMotors","DrafterLiftMotor","****$NPermissives to Operate Motor.$N****","OTE(DrafterLiftMotor.Internal.Permissive)","0"
RCOMMENT,"LineMotors","DrafterLiftMotor","****$NCommand the Motor to Automatic Mode$N****","OTE(DrafterLiftMotor.Status.Enabled)","1"
RCOMMENT,"LineMotors","DrafterLiftMotor","****$NJog the Motor$N****","OTE(DrafterLiftMotor.Internal.IntermediateJogForward)","2"
RCOMMENT,"LineMotors","DrafterLiftMotor","****$NJog the Motor$N****","OTE(DrafterLiftMotor.Internal.IntermediateJogReverse)","3"
RCOMMENT,"LineMotors","DrafterLiftMotor","****$NMotor Contactor Control$N****","OTE(DrafterLiftMotorDownRun)","4"
RCOMMENT,"LineMotors","DrafterLiftMotor","****$NMotor Contactor Control$N****","OTE(DrafterLiftMotorUpRun)","5"
RCOMMENT,"LineMotors","DrafterLiftMotor","****$NMotor Running Status$N****","OTE(DrafterLiftMotor.Status.RunningForward)","6"
RCOMMENT,"LineMotors","DrafterLiftMotor","****$NMotor Running Status$N****","OTE(DrafterLiftMotor.Status.RunningReverse)","7"
RCOMMENT,"LineMotors","DrafterLiftMotor","****$NDisplay for HMI$N****","OTE(HMI_DrafterBottomRollersLimit)","8"
RCOMMENT,"LineMotors","DrafterLiftMotor","****$NDisplay for HMI$N****","OTE(HMI_DrafterTopRollersLimit)","9"
RCOMMENT,"LineMotors","DrafterLiftMotor","****$NIf the Motor is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(DrafterLiftMotor.Status.FailedToStart)","10"
RCOMMENT,"LineMotors","DrafterLiftMotor","****$NIf the Motor runs when it is not being told to, it has failed to stop.$N****","OTL(DrafterLiftMotor.Status.FailedToStop)","11"
RCOMMENT,"LineMotors","DrafterLiftMotor","****$NMotor Faulted Status$NThe faulted status is in the permissive and will stop the Motor.$N****","OTE(DrafterLiftMotor.Status.Faulted)","12"
RCOMMENT,"LineMotors","DrafterLiftMotor","****$NUnlatch the Motor Faulted Status$N****","OTU(DrafterLiftMotor.Status.FailedToStop)","13"
RCOMMENT,"LineMotors","LineMotorsMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(CardAspirationFan,0)","0"
RCOMMENT,"LineMotors","LineMotorsMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(DrafterLiftMotor,0)","1"
RCOMMENT,"LineMotors","LineMotorsMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(ProttTransportMotor,0)","2"
RCOMMENT,"LineMotors","ProttTransportMotor","****$NPermissives to Operate Motor.$N****","OTE(ProttTransportMotor.Internal.Permissive)","0"
RCOMMENT,"LineMotors","ProttTransportMotor","****$NCommand the Motor to Automatic Mode$N****","OTE(ProttTransportMotor.Status.Enabled)","1"
RCOMMENT,"LineMotors","ProttTransportMotor","****$NJog the Motor$N****","OTE(ProttTransportMotor.Internal.IntermediateJogForward)","2"
RCOMMENT,"LineMotors","ProttTransportMotor","****$NManual mode Start/Stop Logic$N****","OTE(ProttTransportMotor.Internal.IntermediateRunForward)","3"
RCOMMENT,"LineMotors","ProttTransportMotor","****$NPut logic here for automatic run of Motor.  The timers are for debounce.$N****","TOF(ProttTransportMotor.Internal.AutoOffDelayTimer,?,?)","4"
RCOMMENT,"LineMotors","ProttTransportMotor","****$NReset off delay if permissive is lost to prevent restart.$N****","RES(ProttTransportMotor.Internal.AutoOffDelayTimer)","5"
RCOMMENT,"LineMotors","ProttTransportMotor","****$NWhen the on delay above is done, the off delay comes on.  Only the off delay$Ndone bitis used for the run command.$N****","OTE(ProttTransportMotor.Internal.AutoModeRun)","6"
RCOMMENT,"LineMotors","ProttTransportMotor","****$NMotor Contactor Control$N****","OTE(ProttTransportMotorCont)","7"
RCOMMENT,"LineMotors","ProttTransportMotor","****$NMotor Running Status$N****","OTE(ProttTransportMotor.Status.RunningForward)","8"
RCOMMENT,"LineMotors","ProttTransportMotor","****$NIf the Motor is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(ProttTransportMotor.Status.FailedToStart)","9"
RCOMMENT,"LineMotors","ProttTransportMotor","****$NIf the Motor runs when it is not being told to, it has failed to stop.$N****","OTL(ProttTransportMotor.Status.FailedToStop)","10"
RCOMMENT,"LineMotors","ProttTransportMotor","****$NMotor Faulted Status$NThe faulted status is in the permissive and will stop the Motor.$N****","OTE(ProttTransportMotor.Status.Faulted)","11"
RCOMMENT,"LineMotors","ProttTransportMotor","****$NUnlatch the Motor Faulted Status$N****","OTU(ProttTransportMotor.Status.FailedToStop)","12"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","0"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","1"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","2"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","3"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","4"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","5"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","6"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","7"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","8"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","9"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","10"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","11"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","12"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","13"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","14"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","15"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","16"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","17"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","18"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","19"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","20"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","21"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","22"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","23"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","24"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","25"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","26"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","27"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","28"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","29"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","30"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","31"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","32"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","33"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","34"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","35"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","36"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","37"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","38"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","39"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","40"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","41"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","42"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","43"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","44"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","45"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","46"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","47"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","48"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","49"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","50"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","51"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","52"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","53"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","54"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","55"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","56"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","57"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","58"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","59"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","60"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","61"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","62"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","63"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","64"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","65"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","66"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","67"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","68"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","69"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","70"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","71"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","72"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","73"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","74"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","75"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","76"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","77"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","78"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","79"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","80"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","81"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","82"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","83"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","84"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","85"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","86"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","87"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","88"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","89"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","90"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","91"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","92"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","93"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","94"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","95"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","96"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","97"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","98"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","99"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","100"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","101"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","102"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","103"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","104"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","105"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","106"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","107"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","108"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","109"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","110"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","111"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","112"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","113"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","114"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","115"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","116"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","117"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","118"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","119"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","120"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","121"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","122"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","123"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","124"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","125"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","126"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","127"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","128"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","129"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","130"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","131"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","132"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","133"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","134"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","135"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","136"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","137"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","138"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","139"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","140"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","141"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","142"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","143"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","144"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","145"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","146"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","147"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","148"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","149"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","150"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","151"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","152"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","153"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","154"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","155"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","156"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","157"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","158"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","159"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","160"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","161"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","162"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","163"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","164"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","165"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","166"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","167"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","168"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","169"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","170"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","171"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","172"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","173"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","174"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","175"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","176"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","177"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","178"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","179"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","180"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","181"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","182"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","183"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","184"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","185"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","186"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","187"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","188"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","189"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","190"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","191"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","192"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","193"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","194"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","195"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","196"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","197"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","198"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","199"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","200"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","201"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","202"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","203"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","204"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","205"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","206"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","207"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","208"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","209"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","210"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","211"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","212"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","213"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","214"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","215"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","216"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","217"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","218"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","219"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","220"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","221"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","222"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","223"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","224"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","225"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","226"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","227"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","228"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","229"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","230"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","231"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","232"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","233"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","234"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","235"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","236"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","237"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","238"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","239"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","240"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","241"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","242"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","243"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","244"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","245"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","246"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","247"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","248"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","249"
RCOMMENT,"MainProgram","Alarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(Alarms.NewAlarm)","250"
RCOMMENT,"MainProgram","AnalogSignals","****$NScale the analog input to engineering units.$N****","SUB(HMI_LoomSpeedMPM,HMI_M2DrawOffSpeedActual,LoomDifference)","0"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(Apron.Comms.CommsFault)","0"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(BottomDoffer.Comms.CommsFault)","1"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(BottomScrambler.Comms.CommsFault)","2"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(BottomTakeoff.Comms.CommsFault)","3"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(BottomTOFBelt.Comms.CommsFault)","4"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(ChutefeedFeedroll.Comms.CommsFault)","5"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(DrafterGroup1.Comms.CommsFault)","6"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(DrafterGroup2.Comms.CommsFault)","7"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(DrafterGroup3.Comms.CommsFault)","8"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(DrafterGroup4.Comms.CommsFault)","9"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(DrafterGroup5.Comms.CommsFault)","10"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(FeedRoll.Comms.CommsFault)","11"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(MainCylinder.Comms.CommsFault)","12"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(ScaleBelt.Comms.CommsFault)","13"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(TopDoffer.Comms.CommsFault)","14"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(TopScrambler.Comms.CommsFault)","15"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(TopTakeoff.Comms.CommsFault)","16"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(TopTOFBelt.Comms.CommsFault)","17"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(TransportBelt.Comms.CommsFault)","18"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(Worker.Comms.CommsFault)","19"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(BO1LoadApron.Comms.CommsFault)","20"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(BO1ExtendedApron.Comms.CommsFault)","21"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(BO1LiftApron.Comms.CommsFault)","22"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(BO2LoadApron.Comms.CommsFault)","23"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(BO2ExtendedApron.Comms.CommsFault)","24"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(BO2LiftApron.Comms.CommsFault)","25"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(BO3LoadApron.Comms.CommsFault)","26"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(BO3ExtendedApron.Comms.CommsFault)","27"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(BO3LiftApron.Comms.CommsFault)","28"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(BO4LoadApron.Comms.CommsFault)","29"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(BO4ExtendedApron.Comms.CommsFault)","30"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(BO4LiftApron.Comms.CommsFault)","31"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(BO5LoadApron.Comms.CommsFault)","32"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(BO5ExtendedApron.Comms.CommsFault)","33"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(BO5LiftApron.Comms.CommsFault)","34"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(TH6LiftApron.Comms.CommsFault)","35"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(TH7LiftApron.Comms.CommsFault)","36"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(RH1ExtendedApron.Comms.CommsFault)","37"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(RH1LiftApron.Comms.CommsFault)","38"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(RH2ExtendedApron.Comms.CommsFault)","39"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(RH2LiftApron.Comms.CommsFault)","40"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(B1BlendConveyor.Comms.CommsFault)","41"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(B1BlendTransportFan.Comms.CommsFault)","42"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(FS51ReserveSiloFeedroll.Comms.CommsFault)","43"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(FOFeedroll.Comms.CommsFault)","44"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(FOOutfeedFan.Comms.CommsFault)","45"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(FS52ReserveSiloFeedroll.Comms.CommsFault)","46"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(FS52ReserveSiloOutfeedFan.Comms.CommsFault)","47"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(ChutefeedVentilators.Comms.CommsFault)","48"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(ChutefeedDeliveryRoll.Comms.CommsFault)","49"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(PLCCPComms.CommsFault)","50"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(OBCPComms.CommsFault)","51"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(CCPComms.CommsFault)","52"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(OB1RPComms.CommsFault)","53"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(OB2RPComms.CommsFault)","54"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(OB3RPComms.CommsFault)","55"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(OB4RPComms.CommsFault)","56"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(OB5RPComms.CommsFault)","57"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(TH6RPComms.CommsFault)","58"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(TH7RPComms.CommsFault)","59"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(RH1RPComms.CommsFault)","60"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(RH2RPComms.CommsFault)","61"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(VBORPComms.CommsFault)","62"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(FS52Comms.CommsFault)","63"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(CRP1Comms.CommsFault)","64"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(CRP2Comms.CommsFault)","65"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(ExitPLCComms.CommsFault)","66"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NQuery the station to retrieve the bitmapped status word on the Adapter.  The status is mapped into bits 12-15, so mask bits 0-11, and shift bits 12-15 to position 0-4 to convert the status into an integer value between 0 and 15.  Use this integer value to check the adapter status.$NIf the Current Status Code of the adapter is not equal to the predefined Normal state (Running=4), then set the Rack Status Fault bit.$N****","OTE(RedLionDSPComms.CommsFault)","67"
RCOMMENT,"MainProgram","CommunicationsCheck","****$NThis GSV instruction gets the value of the IO LED on the front of the processor.$N0-LED off No IO Modules Configured$N1-LED Flashing Red-No Modules Running$N2-LED Flashing Green-At least 1 Module not Running$N3-LED Solid Green-All Configured Modules Running$N****$NCheck I/O in PLC configuration to determine the problem module(s).$N****","COP(IOLEDDescriptions[IO_LEDStatus],CurrentIOStatus,1)","68"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","0"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","1"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","2"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","3"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","4"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","5"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","6"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","7"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","8"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","9"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","10"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","11"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","12"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","13"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","14"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","15"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","16"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","17"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","18"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","19"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","20"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","21"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","22"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","23"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","24"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","25"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","26"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","27"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","28"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","29"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","30"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","31"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","32"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","33"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","34"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","35"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","36"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","37"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","38"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","39"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","40"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","41"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","42"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","43"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","44"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","45"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","46"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","47"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","48"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","49"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","50"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","51"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","52"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","53"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","54"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","55"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","56"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","57"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","58"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","59"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","60"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","61"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","62"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","63"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","64"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","65"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","66"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","67"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","68"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","69"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","70"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","71"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","72"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","73"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","74"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","75"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","76"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","77"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","78"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","79"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","80"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","81"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","82"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","83"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","84"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","85"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","86"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","87"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","88"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","89"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","90"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","91"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","92"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","93"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****$N","OTL(FastStopFaults.NewFault)","94"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","95"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","96"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","97"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","98"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","100"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","101"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","102"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","103"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","104"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","105"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","106"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","107"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","108"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","109"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","110"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","111"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","112"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","113"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","114"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","115"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","116"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","117"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","118"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","119"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","120"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","121"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","122"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","123"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","124"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","125"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","126"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","127"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","128"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","129"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","130"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","131"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","132"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","133"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","134"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","135"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","136"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","137"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","138"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","139"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","140"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","141"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","142"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","143"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","144"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","145"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","146"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","147"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","148"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","149"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","150"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","151"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","152"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","153"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","154"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","155"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","156"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","157"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","158"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","159"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","160"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","161"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","162"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","163"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","164"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","165"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","166"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","167"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","168"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","169"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","170"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","171"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","172"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","173"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","174"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","175"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","176"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","177"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","178"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","179"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","180"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","181"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","182"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","183"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","184"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","185"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","186"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","187"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","188"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","189"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","190"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","191"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","192"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","193"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","194"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","195"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","196"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","197"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","198"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","199"
RCOMMENT,"MainProgram","FastStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(FastStopFaults.NewFault)","200"
RCOMMENT,"MainProgram","GloballyUsed","****$NThe $QYes$Q bit is used throughout the program as an always on bit.$N****","OTL(Yes)","0"
RCOMMENT,"MainProgram","GloballyUsed","****$NThe $QNo$Q bit is used throughout the program as an always off bit.$N****","OTU(No)","1"
RCOMMENT,"MainProgram","GloballyUsed","****$NSetup for Flashing Bit$NOne Second On, One Second Off$N****","TON(System.Internal.OneSecondFlashTimer,?,?)","3"
RCOMMENT,"MainProgram","GloballyUsed","****$NWhen the timer above gets done, it toggles the flasher bit.$N****","JKFlipFLop(System.Internal.OneSecondFlipFlop,System.Internal.OneSecondFlashTimer.DN,System.Internal.OneSecondFlasher,No)","4"
RCOMMENT,"MainProgram","GloballyUsed","****$NSetup for Flashing Bit$NHalf Second On, Half Second Off$N****","TON(System.Internal.HalfSecondFlashTimer,?,?)","5"
RCOMMENT,"MainProgram","GloballyUsed","****$NWhen the timer above gets done, it toggles the flasher bit.$N****","JKFlipFLop(System.Internal.HalfSecondFlipFlop,System.Internal.HalfSecondFlashTimer.DN,System.Internal.HalfSecondFlasher,No)","6"
RCOMMENT,"MainProgram","GloballyUsed","****$NThe heartbeat is displayed on the HMI to confirm communications between the PLC and HMI.$N****","OTE(System.Status.Heartbeat)","7"
RCOMMENT,"MainProgram","GloballyUsed","****$NThe reset command is held high by the timer.$N****","OTE(WLEStopResetToLooms)","8"
RCOMMENT,"MainProgram","MainRoutine","****$NUse the main routine to call the other routines in the program.$N****","JSR(Alarms,0)","0"
RCOMMENT,"MainProgram","MainRoutine","****$NUse the main routine to call the other routines in the program.$N****","JSR(AnalogSignals,0)","1"
RCOMMENT,"MainProgram","MainRoutine","****$NUse the main routine to call the other routines in the program.$N****","JSR(CommunicationsCheck,0)","2"
RCOMMENT,"MainProgram","MainRoutine","****$NUse the main routine to call the other routines in the program.$N****","JSR(FastStopFaults,0)","3"
RCOMMENT,"MainProgram","MainRoutine","****$NUse the main routine to call the other routines in the program.$N****","JSR(GloballyUsed,0)","4"
RCOMMENT,"MainProgram","MainRoutine","****$NUse the main routine to call the other routines in the program.$N****","JSR(MetalDetectors,0)","5"
RCOMMENT,"MainProgram","MainRoutine","****$NUse the main routine to call the other routines in the program.$N****","JSR(NormalStopFaults,0)","6"
RCOMMENT,"MainProgram","MainRoutine","****$NUse the main routine to call the other routines in the program.$N****","JSR(SafetyMapping,0)","7"
RCOMMENT,"MainProgram","MainRoutine","****$NUse the main routine to call the other routines in the program.$N****","JSR(StackLightControl,0)","8"
RCOMMENT,"MainProgram","MainRoutine","****$NUse the main routine to call the other routines in the program.$N****","JSR(WinderData,0)","9"
RCOMMENT,"MainProgram","MainRoutine","****$NThis is some logic to test scan times.$N****","OTU(RunScanCounter)","10"
RCOMMENT,"MainProgram","MetalDetectors","****$NLatch the detected bit with the input.$N****","OTL(LeftSideMetalDetected)","0"
RCOMMENT,"MainProgram","MetalDetectors","****$NLatch the detected bit with the input.$N****","OTL(RightSideMetalDetected)","1"
RCOMMENT,"MainProgram","MetalDetectors","****$NIf there is no metal detect a test can be performed.$N****","TOF(MetalDetectTestTimer,?,?)","2"
RCOMMENT,"MainProgram","MetalDetectors","****$NUnlatch the latched bits.$N****","OTU(RightSideMetalDetected)","3"
RCOMMENT,"MainProgram","MetalDetectors","****$NFire the the light will stay on as long as the alarm bit is present.  The$Nbuzzer will sound for a set time only.  Both will be energized when the test/reset PB is pressed.$N****","OTE(LeftMetalDetectorBuzzer)","4"
RCOMMENT,"MainProgram","MetalDetectors","****$NFire the the light will stay on as long as the alarm bit is present.  The$Nbuzzer will sound for a set time only.  Both will be energized when the test/reset PB is pressed.$N****","OTE(RightMetalDetectorBuzzer)","5"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","0"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","1"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","2"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","3"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","4"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","5"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","6"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","7"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","8"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","9"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","10"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","11"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","12"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","13"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","14"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","15"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","16"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","17"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","18"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","19"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","20"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","21"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","22"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","23"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","24"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","25"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","26"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","27"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","28"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","29"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","30"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","31"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","32"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","33"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","34"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","35"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","36"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","37"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","38"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","39"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","40"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","41"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","42"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","43"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","44"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","45"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","46"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","47"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","48"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","49"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","50"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","51"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","52"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","53"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","54"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","55"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","56"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","57"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","58"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","59"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","60"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","61"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","62"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","63"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","64"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","65"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","66"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","67"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","68"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","69"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","70"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","71"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","72"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","73"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","74"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","75"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","76"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","77"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","78"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","79"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","80"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","81"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","82"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","83"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","84"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","85"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","86"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","87"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","88"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","89"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","90"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","91"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","92"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","93"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****$N","OTL(NormalStopFaults.NewFault)","94"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","95"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","96"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","97"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","98"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","100"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","101"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","102"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","103"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","104"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","105"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","106"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","107"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","108"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","109"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","110"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","111"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","112"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","113"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","114"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","115"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","116"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","117"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","118"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","119"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","120"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","121"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","122"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","123"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","124"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","125"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","126"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","127"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","128"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","129"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","130"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","131"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","132"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","133"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","134"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","135"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","136"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","137"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","138"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","139"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","140"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","141"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","142"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","143"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","144"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","145"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","146"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","147"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","148"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","149"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","150"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","151"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","152"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","153"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","154"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","155"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","156"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","157"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","158"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","159"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","160"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","161"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","162"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","163"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","164"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","165"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","166"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","167"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","168"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","169"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","170"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","171"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","172"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","173"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","174"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","175"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","176"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","177"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","178"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","179"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","180"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","181"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","182"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","183"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","184"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","185"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","186"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","187"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","188"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","189"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","190"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","191"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","192"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","193"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","194"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","195"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","196"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","197"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","198"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","199"
RCOMMENT,"MainProgram","NormalStopFaults","****$NA FAULT IS A CONDITION THAT WILL STOP THE LINE OR PREVENT IT FROM RUNNING!!!$N$NOnce a fault condition occurs, a timer is started.  If the timer gets done, a fault occurs and is latched in.$NThe fault will stay latched in until a reset is given.  Also, each time a new fault occurs (even after a reset, the$Nnew fault bit is latched.$N****","OTL(NormalStopFaults.NewFault)","200"
RCOMMENT,"MainProgram","SafetyMapping","****$NAlias tags cannot be mapped to safety tags.  Therefore, the alias tags are$Ntied to internal tags and mapped to safety tags.$N****","OTE(OB1DisconnectToSafety)","0"
RCOMMENT,"MainProgram","StackLightControl","****$NGreen Light = Starting (Blinking) or Running (Solid)$N****","OTE(CardGreenStackLight)","0"
RCOMMENT,"MainProgram","StackLightControl","****$NYellow Light = Alarm Active$N****","OTE(CardYellowStackLight)","1"
RCOMMENT,"MainProgram","StackLightControl","****$NRed Light = Line Ready to Start$N****","OTE(CardRedStackLight)","2"
RCOMMENT,"MainProgram","StackLightControl","****$NHorn = Starting$N****","OTE(CardHornStackLight)","3"
RCOMMENT,"MainProgram","StackLightControl","****$NGreen Light = Starting (Blinking) or Running (Solid)$N****","OTE(BlendingGreenStackLight2)","4"
RCOMMENT,"MainProgram","StackLightControl","****$NYellow Light = Alarm Active$N****","OTE(BlendingYellowStackLight2)","5"
RCOMMENT,"MainProgram","StackLightControl","****$NRed Light = Line Ready to Start$N**** ","OTE(BlendingRedStackLight2)","6"
RCOMMENT,"MainProgram","StackLightControl","****$NSet up a toggling bit for setting the frequency of the blending horn during startup.$N****","JKFlipFLop(HornJK,HornFlipFlopBit,HornBeeper,No)","7"
RCOMMENT,"MainProgram","StackLightControl","****$NHorn = Starting$N****","OTE(BlendingHornStackLight2)","8"
RCOMMENT,"MainProgram","WinderData","****$NThis bit is the start bit used in the exit PLC when it is in automatic.$N****","OTE(DataToExitPLC.Bit1)","0"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"Recipe","CopyRecipe","****$NThis is the first step in loading a selected recipe.  Once the$Nload recipe command has been given, it must be confirmed to complete the action.$N****","OTL(HMI_CopyRecipeActive)","0"
RCOMMENT,"Recipe","CopyRecipe","****$NThis is the second step in loading a recipe.  The load recipe latched a bit$Nand the confirm actually loads the recipe.  The latched Initiate load recipe$Nbit is unlatched at the end of the routine when the load is complete.$N****","OTL(InitiateCopyRecipe)","1"
RCOMMENT,"Recipe","CopyRecipe","****$NThe operator may cancel the requested action.$N****","OTU(HMI_CopyRecipeActive)","2"
RCOMMENT,"Recipe","CopyRecipe","****$NSet up the index for loading a recipe.$N****","MOV(HMI_CopySelectRecipe,CopyRecipeIndex)","3"
RCOMMENT,"Recipe","CopyRecipe","****$NSet up the index for loading a recipe.$N****","MOV(HMI_PasteSelectRecipe,PasteRecipeIndex)","4"
RCOMMENT,"Recipe","CopyRecipe","****$NThis rung deletes the $QPaste to$Q recipe$'s name$Nand then sets it to the new name.$N****","CONCAT(Recipes[PasteRecipeIndex].RecipeName,HMI_NewRecipeName,Recipes[PasteRecipeIndex].RecipeName)","5"
RCOMMENT,"Recipe","CopyRecipe","****$NUnlatch the recipe copy bit at the end of the routine, because$Nit is no longer needed.$N****","OTU(HMI_CopyRecipeActive)","6"
RCOMMENT,"Recipe","LoadRecipe","****$NThis is the first step in loading a selected recipe.  Once the$Nload recipe command has been given, it must be confirmed to complete the action.$N****","OTL(HMI_LoadRecipeActive)","0"
RCOMMENT,"Recipe","LoadRecipe","****$NThis is the second step in loading a recipe.  The load recipe latched a bit$Nand the confirm actually loads the recipe.  The latched Initiate load recipe$Nbit is unlatched at the end of the routine when the load is complete.$N****","OTL(InitiateLoadRecipe)","1"
RCOMMENT,"Recipe","LoadRecipe","****$NThe operator may cancel the requested action.$N****","OTU(HMI_LoadRecipeActive)","2"
RCOMMENT,"Recipe","LoadRecipe","****$NSet up the index for loading a recipe.$N****","MOV(HMI_LoadSelectRecipe,LoadRecipeIndex)","3"
RCOMMENT,"Recipe","LoadRecipe","****$NThe recipe selected to be loaded will be moved into a $Qloaded recipe$Q$Nfor display on the HMI.$N****","COP(Recipes[LoadRecipeIndex],HMI_LoadedRecipe,1)","4"
RCOMMENT,"Recipe","LoadRecipe","****$NWhen a load recipe is initiated, the selected $Qload$Q recipe values get moved into the active setpoints.$N****","MOV(Recipes[LoadRecipeIndex].BO1WeighModeSlowSP,BO1.Command.SlowDownPercentSetpoint)","5"
RCOMMENT,"Recipe","LoadRecipe","****$NWhen a load recipe is initiated, the selected $Qload$Q recipe values get moved into the active setpoints.$N****","MOV(Recipes[LoadRecipeIndex].BO2WeighModeSlowSP,BO2.Command.SlowDownPercentSetpoint)","6"
RCOMMENT,"Recipe","LoadRecipe","****$NWhen a load recipe is initiated, the selected $Qload$Q recipe values get moved into the active setpoints.$N****","MOV(Recipes[LoadRecipeIndex].BO3WeighModeSlowSP,BO3.Command.SlowDownPercentSetpoint)","7"
RCOMMENT,"Recipe","LoadRecipe","****$NWhen a load recipe is initiated, the selected $Qload$Q recipe values get moved into the active setpoints.$N****","MOV(Recipes[LoadRecipeIndex].BO4WeighModeSlowSP,BO4.Command.SlowDownPercentSetpoint)","8"
RCOMMENT,"Recipe","LoadRecipe","****$NWhen a load recipe is initiated, the selected $Qload$Q recipe values get moved into the active setpoints.$N****","MOV(Recipes[LoadRecipeIndex].BO5WeighModeSlowSP,BO5.Command.SlowDownPercentSetpoint)","9"
RCOMMENT,"Recipe","LoadRecipe","****$NWhen a load recipe is initiated, the selected $Qload$Q recipe values get moved into the active setpoints.$N****","MOV(Recipes[LoadRecipeIndex].TH6WeighModeSlowSP,TH6.Command.SlowDownPercentSetpoint)","10"
RCOMMENT,"Recipe","LoadRecipe","****$NWhen a load recipe is initiated, the selected $Qload$Q recipe values get moved into the active setpoints.$N****","MOV(Recipes[LoadRecipeIndex].TH7WeighModeSlowSP,TH7.Command.SlowDownPercentSetpoint)","11"
RCOMMENT,"Recipe","LoadRecipe","****$NWhen a load recipe is initiated, the selected $Qload$Q recipe values get moved into the active setpoints.$N****","MOV(Recipes[LoadRecipeIndex].RH1ExtendedApronSP,RH1ExtendedApron.Command.SpeedSetpoint)","12"
RCOMMENT,"Recipe","LoadRecipe","****$NWhen a load recipe is initiated, the selected $Qload$Q recipe values get moved into the active setpoints.$N****","MOV(Recipes[LoadRecipeIndex].RH2ExtendedApronSP,RH2ExtendedApron.Command.SpeedSetpoint)","13"
RCOMMENT,"Recipe","LoadRecipe","****$NWhen a load recipe is initiated, the selected $Qload$Q recipe values get moved into the active setpoints.$N****","MOV(Recipes[LoadRecipeIndex].ChutefeedDeliveryRollDrawSP,ChutefeedDeliveryRoll.Command.DrawSetpoint)","14"
RCOMMENT,"Recipe","LoadRecipe","****$NWhen a load recipe is initiated, the selected $Qload$Q recipe values get moved into the active setpoints.$N****","MOV(Recipes[LoadRecipeIndex].BottomTOFBeltSP,BottomTOFBelt.Command.SpeedSetpoint)","15"
RCOMMENT,"Recipe","LoadRecipe","****$NWhen a load recipe is initiated, the selected $Qload$Q recipe values get moved into the active setpoints.$N****","MOV(Recipes[LoadRecipeIndex].DrafterGroup5DrawSP,DrafterGroup5.Command.DrawSetpoint)","16"
RCOMMENT,"Recipe","LoadRecipe","****$NThis routine fills the current recipe with the current working values$Nthat are in use at the moment.  If any changes are made on the screen to $Nany of these setpoints, the current recipe is updated immediately.$N****","MOV(Recipes[LoadRecipeIndex].CrosslapperApronHeightRight,HMI_WCApronHeightRightSetpoint)","17"
RCOMMENT,"Recipe","LoadRecipe","****$NThis routine fills the current recipe with the current working values$Nthat are in use at the moment.  If any changes are made on the screen to $Nany of these setpoints, the current recipe is updated immediately.$N****","MOV(Recipes[LoadRecipeIndex].M2Gap,HMI_M2Gap)","18"
RCOMMENT,"Recipe","LoadRecipe","****$NOnce the crosslapper values are loaded into the $QHMI$Q registers, there must be time$Nfor the other program to convert them to the scaled values used in the Siemens PLC.$NAfter that time, the bit must be sent telling the Siemens PLC to accept the values.$NIt is a one shot in the Siemens PLC.$N****","OTE(WCTakeoverSetpoint)","19"
RCOMMENT,"Recipe","LoadRecipe","****$NOnce the Loom values are loaded into the $QHMI$Q registers, there must be time$Nfor the other program to convert them to the scaled values used in the Siemens PLC.$NAfter that time, the bit must be sent telling the Siemens PLC to accept the values.$NIt is a one shot in the Siemens PLC.$N****","OTE(WLTakeOverSetpoint)","20"
RCOMMENT,"Recipe","LoadRecipe","****$NUnlatch the recipe load bit at the end of the routine, because$Nit is no longer needed.$N****","OTU(HMI_LoadRecipeActive)","21"
RCOMMENT,"Recipe","RecipeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(CopyRecipe,0)","0"
RCOMMENT,"Recipe","RecipeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(LoadRecipe,0)","1"
RCOMMENT,"Recipe","RecipeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(RunningRecipe,0)","2"
RCOMMENT,"Recipe","RecipeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(SaveRecipe,0)","3"
RCOMMENT,"Recipe","RecipeMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(ViewRecipe,0)","4"
RCOMMENT,"Recipe","RecipeMain","****$NJust a quick way to set all the recipe numbers.$NNo other recipe values should be affected.$N****$NJust toggle the bit.  It is automatically reset.$N","OTU(SetRecipeNumbers)","5"
RCOMMENT,"Recipe","RunningRecipe","****$NThis routine fills the current recipe with the current working values$Nthat are in use at the moment.  If any changes are made on the screen to $Nany of these setpoints, the current recipe is updated immediately.$N****","MOV(BO1.Command.SlowDownPercentSetpoint,CurrentSPRecipe.BO1WeighModeSlowSP)","0"
RCOMMENT,"Recipe","RunningRecipe","****$NThis routine fills the current recipe with the current working values$Nthat are in use at the moment.  If any changes are made on the screen to $Nany of these setpoints, the current recipe is updated immediately.$N****$N","MOV(BO2.Command.SlowDownPercentSetpoint,CurrentSPRecipe.BO2WeighModeSlowSP)","1"
RCOMMENT,"Recipe","RunningRecipe","****$NThis routine fills the current recipe with the current working values$Nthat are in use at the moment.  If any changes are made on the screen to $Nany of these setpoints, the current recipe is updated immediately.$N****","MOV(BO3.Command.SlowDownPercentSetpoint,CurrentSPRecipe.BO3WeighModeSlowSP)","2"
RCOMMENT,"Recipe","RunningRecipe","****$NThis routine fills the current recipe with the current working values$Nthat are in use at the moment.  If any changes are made on the screen to $Nany of these setpoints, the current recipe is updated immediately.$N****","MOV(BO4.Command.SlowDownPercentSetpoint,CurrentSPRecipe.BO4WeighModeSlowSP)","3"
RCOMMENT,"Recipe","RunningRecipe","****$NThis routine fills the current recipe with the current working values$Nthat are in use at the moment.  If any changes are made on the screen to $Nany of these setpoints, the current recipe is updated immediately.$N****","MOV(BO5.Command.SlowDownPercentSetpoint,CurrentSPRecipe.BO5WeighModeSlowSP)","4"
RCOMMENT,"Recipe","RunningRecipe","****$NThis routine fills the current recipe with the current working values$Nthat are in use at the moment.  If any changes are made on the screen to $Nany of these setpoints, the current recipe is updated immediately.$N****","MOV(TH6.Command.SlowDownPercentSetpoint,CurrentSPRecipe.TH6WeighModeSlowSP)","5"
RCOMMENT,"Recipe","RunningRecipe","****$NThis routine fills the current recipe with the current working values$Nthat are in use at the moment.  If any changes are made on the screen to $Nany of these setpoints, the current recipe is updated immediately.$N****","MOV(TH7.Command.SlowDownPercentSetpoint,CurrentSPRecipe.TH7WeighModeSlowSP)","6"
RCOMMENT,"Recipe","RunningRecipe","****$NThis routine fills the current recipe with the current working values$Nthat are in use at the moment.  If any changes are made on the screen to $Nany of these setpoints, the current recipe is updated immediately.$N****","MOV(RH1ExtendedApron.Command.SpeedSetpoint,CurrentSPRecipe.RH1ExtendedApronSP)","7"
RCOMMENT,"Recipe","RunningRecipe","****$NThis routine fills the current recipe with the current working values$Nthat are in use at the moment.  If any changes are made on the screen to $Nany of these setpoints, the current recipe is updated immediately.$N****","MOV(RH2ExtendedApron.Command.SpeedSetpoint,CurrentSPRecipe.RH2ExtendedApronSP)","8"
RCOMMENT,"Recipe","RunningRecipe","****$NThis routine fills the current recipe with the current working values$Nthat are in use at the moment.  If any changes are made on the screen to $Nany of these setpoints, the current recipe is updated immediately.$N****","MOV(ChutefeedDeliveryRoll.Command.DrawSetpoint,CurrentSPRecipe.ChutefeedDeliveryRollDrawSP)","9"
RCOMMENT,"Recipe","RunningRecipe","****$NThis routine fills the current recipe with the current working values$Nthat are in use at the moment.  If any changes are made on the screen to $Nany of these setpoints, the current recipe is updated immediately.$N****","MOV(BottomTOFBelt.Command.SpeedSetpoint,CurrentSPRecipe.BottomTOFBeltSP)","10"
RCOMMENT,"Recipe","RunningRecipe","****$NThis routine fills the current recipe with the current working values$Nthat are in use at the moment.  If any changes are made on the screen to $Nany of these setpoints, the current recipe is updated immediately.$N****","MOV(DrafterGroup5.Command.DrawSetpoint,CurrentSPRecipe.DrafterGroup5DrawSP)","11"
RCOMMENT,"Recipe","RunningRecipe","****$NThis routine fills the current recipe with the current working values$Nthat are in use at the moment.  If any changes are made on the screen to $Nany of these setpoints, the current recipe is updated immediately.$N****","MOV(HMI_RCApronHeightFBRight,CurrentSPRecipe.CrosslapperApronHeightRight)","12"
RCOMMENT,"Recipe","RunningRecipe","****$NThis routine fills the current recipe with the current working values$Nthat are in use at the moment.  If any changes are made on the screen to $Nany of these setpoints, the current recipe is updated immediately.$N****","MOV(HMI_M2GapSetpointFB,CurrentSPRecipe.M2Gap)","13"
RCOMMENT,"Recipe","SaveRecipe","****$NThis is the first step in saving a selected recipe.  Once the$Nsave recipe command has been given, it must be confirmed to complete the action.$N****","OTL(HMI_SaveRecipeActive)","0"
RCOMMENT,"Recipe","SaveRecipe","****$NThis is the second step in saving a recipe.  The save recipe latched a bit$Nand the confirm actually saves the recipe.  The latched Initiate save recipe$Nbit is unlatched at the end of the routine when the save is complete.$N****","OTL(InitiateSaveRecipe)","1"
RCOMMENT,"Recipe","SaveRecipe","****$NThe operator may cancel the requested action.$N****","OTU(HMI_SaveRecipeActive)","2"
RCOMMENT,"Recipe","SaveRecipe","****$NSet up the index for saving a recipe.$N****","MOV(HMI_SaveSelectRecipe,SaveRecipeIndex)","3"
RCOMMENT,"Recipe","SaveRecipe","****$NWhen a save recipe is initiated, the active values get moved into the selected $Qsave$Q recipe.$NThe new $Qsaved$Q recipe gets its name from the screen.$N****","CONCAT(Recipes[SaveRecipeIndex].RecipeName,HMI_SaveRecipeName,Recipes[SaveRecipeIndex].RecipeName)","4"
RCOMMENT,"Recipe","SaveRecipe","****$NUnlatch the recipe save bit at the end of the routine, because$Nit is no longer needed.$N****","OTU(HMI_SaveRecipeActive)","5"
RCOMMENT,"Recipe","SetRecipeNumbers","****$NJust a quick way to set all the recipe numbers.$N****","MOV(SetRecipeNumbersIndex,Recipes[SetRecipeNumbersIndex].RecipeNumber)","0"
RCOMMENT,"Recipe","ViewRecipe","****$NSet up the index for viewing a recipe.$N****","MOV(HMI_ViewSelectRecipe,ViewRecipeIndex)","0"
RCOMMENT,"Recipe","ViewRecipe","****$NA viewed recipe has no effect.  It simply loads$Na recipe into the $QViewRecipe$Q for HMI display.$N****","COP(Recipes[ViewRecipeIndex],HMI_ViewRecipe,1)","1"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"RecycleHopper1","RH1DeliveryFan","****$NPermissive to operate the motor.$N****","OTE(RH1DeliveryFan.Internal.Permissive)","0"
RCOMMENT,"RecycleHopper1","RH1DeliveryFan","****$NManual Run Control$N****","OTE(RH1DeliveryFan.Internal.IntermediateRunForward)","1"
RCOMMENT,"RecycleHopper1","RH1DeliveryFan","****$NManual Jog Control$N****","OTE(RH1DeliveryFan.Internal.IntermediateJogForward)","2"
RCOMMENT,"RecycleHopper1","RH1DeliveryFan","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(RH1DeliveryFan.Internal.AutoOffDelayTimer,?,?)","3"
RCOMMENT,"RecycleHopper1","RH1DeliveryFan","****$NMotor Starter Control$N****","OTE(RH1DeliveryFanCont)","4"
RCOMMENT,"RecycleHopper1","RH1DeliveryFan","****$NRunning Status$N****","OTE(RH1DeliveryFan.Status.RunningForward)","5"
RCOMMENT,"RecycleHopper1","RH1DeliveryFan","****$NIf the motor does not start when commanded, it has failed to run$N****","OTL(RH1DeliveryFan.Status.FailedToStart)","6"
RCOMMENT,"RecycleHopper1","RH1DeliveryFan","****$NIf a motor continues to run when the run command has been removed,$Nit has failed to stop.$N****$N","OTL(RH1DeliveryFan.Status.FailedToStop)","7"
RCOMMENT,"RecycleHopper1","RH1DeliveryFan","****$NGeneral Faulted Status$N****","OTE(RH1DeliveryFan.Status.Faulted)","8"
RCOMMENT,"RecycleHopper1","RH1DeliveryFan","****$NReset Fault Latches$N****","OTU(RH1DeliveryFan.Status.FailedToStop)","9"
RCOMMENT,"RecycleHopper1","RH1Doffer","****$NPermissive to operate the motor.$N****","OTE(RH1Doffer.Internal.Permissive)","0"
RCOMMENT,"RecycleHopper1","RH1Doffer","****$NManual Run Control$N****","OTE(RH1Doffer.Internal.IntermediateRunForward)","1"
RCOMMENT,"RecycleHopper1","RH1Doffer","****$NManual Jog Control$N****","OTE(RH1Doffer.Internal.IntermediateJogForward)","2"
RCOMMENT,"RecycleHopper1","RH1Doffer","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(RH1Doffer.Internal.AutoOffDelayTimer,?,?)","3"
RCOMMENT,"RecycleHopper1","RH1Doffer","****$NMotor Starter Control$N****","OTE(RH1DofferCont)","4"
RCOMMENT,"RecycleHopper1","RH1Doffer","****$NRunning Status$N****","OTE(RH1Doffer.Status.RunningForward)","5"
RCOMMENT,"RecycleHopper1","RH1Doffer","****$NIf the motor does not start when commanded, it has failed to run$N****","OTL(RH1Doffer.Status.FailedToStart)","6"
RCOMMENT,"RecycleHopper1","RH1Doffer","****$NIf a motor continues to run when the run command has been removed,$Nit has failed to stop.$N****$N","OTL(RH1Doffer.Status.FailedToStop)","7"
RCOMMENT,"RecycleHopper1","RH1Doffer","****$NGeneral Faulted Status$N****","OTE(RH1Doffer.Status.Faulted)","8"
RCOMMENT,"RecycleHopper1","RH1Doffer","****$NReset Fault Latches$N****","OTU(RH1Doffer.Status.FailedToStop)","9"
RCOMMENT,"RecycleHopper1","RH1DoorLocks","****$NThe permissive to lock is delayed by the timer.$N****","OTE(RH1DoorLocks.Internal.LockPermissive)","0"
RCOMMENT,"RecycleHopper1","RH1DoorLocks","****$NThe permissive to unlock is delayed by the timer.$N****","OTE(RH1DoorLocks.Internal.UnlockPermissive)","1"
RCOMMENT,"RecycleHopper1","RH1DoorLocks","****$NThe unlock command works if the permissive above is satisfied.$N****","OTE(RH1DoorLocks.Internal.IntermediateUnlock)","2"
RCOMMENT,"RecycleHopper1","RH1DoorLocks","****$NStatus for the HMI$N****","OTE(RH1DoorLocks.Status.Locked)","3"
RCOMMENT,"RecycleHopper1","RH1DoorLocks","****$NStatus for the HMI$N****","OTE(RH1DoorLocks.Status.Unlocked)","4"
RCOMMENT,"RecycleHopper1","RH1DoorLocks","****$NFire the Outputs$N****","OTE(RH1TopAccessHatchReleaseSol)","5"
RCOMMENT,"RecycleHopper1","RH1ExtendedApron","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(RH1ExtendedApron.Internal.Permissive)","0"
RCOMMENT,"RecycleHopper1","RH1ExtendedApron","****$NJog Command$N****","OTE(RH1ExtendedApron.Internal.IntermediateJog)","1"
RCOMMENT,"RecycleHopper1","RH1ExtendedApron","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(RH1ExtendedApron.Internal.DriveReverse)","2"
RCOMMENT,"RecycleHopper1","RH1ExtendedApron","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(RH1ExtendedApron.Internal.MaintModeRun)","3"
RCOMMENT,"RecycleHopper1","RH1ExtendedApron","****$NAutomatic control.  The TON is dalay for start while the TOF is $Nthe delay for stop.$N****","OTE(RH1ExtendedApron.Internal.AutoModeRun)","4"
RCOMMENT,"RecycleHopper1","RH1ExtendedApron","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(RH1ExtendedApron.Internal.ReleaseRamp)","5"
RCOMMENT,"RecycleHopper1","RH1ExtendedApron","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(RH1ExtendedApron.Internal.DecelTime,RH1ExtendedApron.Internal.DecelTime)","6"
RCOMMENT,"RecycleHopper1","RH1ExtendedApron","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(RH1ExtendedApron.Internal.SpeedReference.ScaledOutput,RH1ExtendedApron:O.FreqCommand)","7"
RCOMMENT,"RecycleHopper1","RH1ExtendedApron","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(RH1ExtendedApron:O.Start)","8"
RCOMMENT,"RecycleHopper1","RH1ExtendedApron","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(RH1ExtendedApron:O.Stop)","9"
RCOMMENT,"RecycleHopper1","RH1ExtendedApron","****$NThe reverse command is set above.$N****","OTE(RH1ExtendedApron:O.Reverse)","10"
RCOMMENT,"RecycleHopper1","RH1ExtendedApron","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(RH1ExtendedApron:O.Forward)","11"
RCOMMENT,"RecycleHopper1","RH1ExtendedApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(RH1ExtendedApron.Internal.ActualSpeedScaler.ScaledOutput,RH1ExtendedApron.Status.ActualSpeed)","12"
RCOMMENT,"RecycleHopper1","RH1ExtendedApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(RH1ExtendedApron.Internal.LoadScaler.ScaledOutput,RH1ExtendedApron.Status.MotorLoad)","13"
RCOMMENT,"RecycleHopper1","RH1ExtendedApron","****$NDrive Running Status$N****","OTE(RH1ExtendedApron.Status.Running)","14"
RCOMMENT,"RecycleHopper1","RH1ExtendedApron","****$NJogging Forward Status$N****","OTE(RH1ExtendedApron.Status.JoggingFwd)","15"
RCOMMENT,"RecycleHopper1","RH1ExtendedApron","****$NJogging Reverse Status$N****","OTE(RH1ExtendedApron.Status.JoggingRev)","16"
RCOMMENT,"RecycleHopper1","RH1ExtendedApron","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(RH1ExtendedApron.Status.FailedToStart)","17"
RCOMMENT,"RecycleHopper1","RH1ExtendedApron","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(RH1ExtendedApron.Status.FailedToStop)","18"
RCOMMENT,"RecycleHopper1","RH1ExtendedApron","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(RH1ExtendedApron.Status.Faulted)","19"
RCOMMENT,"RecycleHopper1","RH1ExtendedApron","****$NUnlatch the Drive Faulted Status$N****","OTU(RH1ExtendedApron.Status.FailedToStop)","20"
RCOMMENT,"RecycleHopper1","RH1LiftApron","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(RH1LiftApron.Internal.Permissive)","0"
RCOMMENT,"RecycleHopper1","RH1LiftApron","****$NJog Command$N****","OTE(RH1LiftApron.Internal.IntermediateJog)","1"
RCOMMENT,"RecycleHopper1","RH1LiftApron","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(RH1LiftApron.Internal.DriveReverse)","2"
RCOMMENT,"RecycleHopper1","RH1LiftApron","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(RH1LiftApron.Internal.MaintModeRun)","3"
RCOMMENT,"RecycleHopper1","RH1LiftApron","****$NAutomatic control.  The TON is dalay for start while the TOF is $Nthe delay for stop.$N****","OTE(RH1LiftApron.Internal.AutoModeRun)","4"
RCOMMENT,"RecycleHopper1","RH1LiftApron","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(RH1LiftApron.Internal.ReleaseRamp)","5"
RCOMMENT,"RecycleHopper1","RH1LiftApron","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(RH1LiftApron.Internal.DecelTime,RH1LiftApron.Internal.DecelTime)","6"
RCOMMENT,"RecycleHopper1","RH1LiftApron","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(RH1LiftApron.Internal.SpeedReference.ScaledOutput,RH1LiftApron:O.FreqCommand)","7"
RCOMMENT,"RecycleHopper1","RH1LiftApron","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(RH1LiftApron:O.Start)","8"
RCOMMENT,"RecycleHopper1","RH1LiftApron","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(RH1LiftApron:O.Stop)","9"
RCOMMENT,"RecycleHopper1","RH1LiftApron","****$NThe reverse command is set above.$N****","OTE(RH1LiftApron:O.Reverse)","10"
RCOMMENT,"RecycleHopper1","RH1LiftApron","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(RH1LiftApron:O.Forward)","11"
RCOMMENT,"RecycleHopper1","RH1LiftApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(RH1LiftApron.Internal.ActualSpeedScaler.ScaledOutput,RH1LiftApron.Status.ActualSpeed)","12"
RCOMMENT,"RecycleHopper1","RH1LiftApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(RH1LiftApron.Internal.LoadScaler.ScaledOutput,RH1LiftApron.Status.MotorLoad)","13"
RCOMMENT,"RecycleHopper1","RH1LiftApron","****$NDrive Running Status$N****","OTE(RH1LiftApron.Status.Running)","14"
RCOMMENT,"RecycleHopper1","RH1LiftApron","****$NJogging Forward Status$N****","OTE(RH1LiftApron.Status.JoggingFwd)","15"
RCOMMENT,"RecycleHopper1","RH1LiftApron","****$NJogging Reverse Status$N****","OTE(RH1LiftApron.Status.JoggingRev)","16"
RCOMMENT,"RecycleHopper1","RH1LiftApron","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(RH1LiftApron.Status.FailedToStart)","17"
RCOMMENT,"RecycleHopper1","RH1LiftApron","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(RH1LiftApron.Status.FailedToStop)","18"
RCOMMENT,"RecycleHopper1","RH1LiftApron","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(RH1LiftApron.Status.Faulted)","19"
RCOMMENT,"RecycleHopper1","RH1LiftApron","****$NUnlatch the Drive Faulted Status$N****","OTU(RH1LiftApron.Status.FailedToStop)","20"
RCOMMENT,"RecycleHopper1","RH1Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(RH1Control,0)","0"
RCOMMENT,"RecycleHopper1","RH1Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(RH1DeliveryFan,0)","1"
RCOMMENT,"RecycleHopper1","RH1Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(RH1Doffer,0)","2"
RCOMMENT,"RecycleHopper1","RH1Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(RH1DoorLocks,0)","3"
RCOMMENT,"RecycleHopper1","RH1Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(RH1ExtendedApron,0)","4"
RCOMMENT,"RecycleHopper1","RH1Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(RH1LiftApron,0)","5"
RCOMMENT,"RecycleHopper1","RH1Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(RH1OutfeedFan,0)","6"
RCOMMENT,"RecycleHopper1","RH1OutfeedFan","****$NPermissive to operate the motor.$N****","OTE(RH1OutfeedFan.Internal.Permissive)","0"
RCOMMENT,"RecycleHopper1","RH1OutfeedFan","****$NManual Run Control$N****","OTE(RH1OutfeedFan.Internal.IntermediateRunForward)","1"
RCOMMENT,"RecycleHopper1","RH1OutfeedFan","****$NManual Jog Control$N****","OTE(RH1OutfeedFan.Internal.IntermediateJogForward)","2"
RCOMMENT,"RecycleHopper1","RH1OutfeedFan","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(RH1OutfeedFan.Internal.AutoOffDelayTimer,?,?)","3"
RCOMMENT,"RecycleHopper1","RH1OutfeedFan","****$NMotor Starter Control$N****","OTE(RH1OutfeedFanCont)","4"
RCOMMENT,"RecycleHopper1","RH1OutfeedFan","****$NRunning Status$N****","OTE(RH1OutfeedFan.Status.RunningForward)","5"
RCOMMENT,"RecycleHopper1","RH1OutfeedFan","****$NIf the motor does not start when commanded, it has failed to run$N****","OTL(RH1OutfeedFan.Status.FailedToStart)","6"
RCOMMENT,"RecycleHopper1","RH1OutfeedFan","****$NIf a motor continues to run when the run command has been removed,$Nit has failed to stop.$N****$N","OTL(RH1OutfeedFan.Status.FailedToStop)","7"
RCOMMENT,"RecycleHopper1","RH1OutfeedFan","****$NGeneral Faulted Status$N****","OTE(RH1OutfeedFan.Status.Faulted)","8"
RCOMMENT,"RecycleHopper1","RH1OutfeedFan","****$NReset Fault Latches$N****","OTU(RH1OutfeedFan.Status.FailedToStop)","9"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"RecycleHopper2","RH2DeliveryFan","****$NPermissive to operate the motor.$N****","OTE(RH2DeliveryFan.Internal.Permissive)","0"
RCOMMENT,"RecycleHopper2","RH2DeliveryFan","****$NManual Run Control$N****","OTE(RH2DeliveryFan.Internal.IntermediateRunForward)","1"
RCOMMENT,"RecycleHopper2","RH2DeliveryFan","****$NManual Jog Control$N****","OTE(RH2DeliveryFan.Internal.IntermediateJogForward)","2"
RCOMMENT,"RecycleHopper2","RH2DeliveryFan","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(RH2DeliveryFan.Internal.AutoOffDelayTimer,?,?)","3"
RCOMMENT,"RecycleHopper2","RH2DeliveryFan","****$NMotor Starter Control$N****","OTE(RH2DeliveryFanCont)","4"
RCOMMENT,"RecycleHopper2","RH2DeliveryFan","****$NRunning Status$N****","OTE(RH2DeliveryFan.Status.RunningForward)","5"
RCOMMENT,"RecycleHopper2","RH2DeliveryFan","****$NIf the motor does not start when commanded, it has failed to run$N****","OTL(RH2DeliveryFan.Status.FailedToStart)","6"
RCOMMENT,"RecycleHopper2","RH2DeliveryFan","****$NIf a motor continues to run when the run command has been removed,$Nit has failed to stop.$N****$N","OTL(RH2DeliveryFan.Status.FailedToStop)","7"
RCOMMENT,"RecycleHopper2","RH2DeliveryFan","****$NGeneral Faulted Status$N****","OTE(RH2DeliveryFan.Status.Faulted)","8"
RCOMMENT,"RecycleHopper2","RH2DeliveryFan","****$NReset Fault Latches$N****","OTU(RH2DeliveryFan.Status.FailedToStop)","9"
RCOMMENT,"RecycleHopper2","RH2Doffer","****$NPermissive to operate the motor.$N****","OTE(RH2Doffer.Internal.Permissive)","0"
RCOMMENT,"RecycleHopper2","RH2Doffer","****$NManual Run Control$N****","OTE(RH2Doffer.Internal.IntermediateRunForward)","1"
RCOMMENT,"RecycleHopper2","RH2Doffer","****$NManual Jog Control$N****","OTE(RH2Doffer.Internal.IntermediateJogForward)","2"
RCOMMENT,"RecycleHopper2","RH2Doffer","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(RH2Doffer.Internal.AutoOffDelayTimer,?,?)","3"
RCOMMENT,"RecycleHopper2","RH2Doffer","****$NMotor Starter Control$N****","OTE(RH2DofferCont)","4"
RCOMMENT,"RecycleHopper2","RH2Doffer","****$NRunning Status$N****","OTE(RH2Doffer.Status.RunningForward)","5"
RCOMMENT,"RecycleHopper2","RH2Doffer","****$NIf the motor does not start when commanded, it has failed to run$N****","OTL(RH2Doffer.Status.FailedToStart)","6"
RCOMMENT,"RecycleHopper2","RH2Doffer","****$NIf a motor continues to run when the run command has been removed,$Nit has failed to stop.$N****$N","OTL(RH2Doffer.Status.FailedToStop)","7"
RCOMMENT,"RecycleHopper2","RH2Doffer","****$NGeneral Faulted Status$N****","OTE(RH2Doffer.Status.Faulted)","8"
RCOMMENT,"RecycleHopper2","RH2Doffer","****$NReset Fault Latches$N****","OTU(RH2Doffer.Status.FailedToStop)","9"
RCOMMENT,"RecycleHopper2","RH2DoorLocks","****$NThe permissive to lock is delayed by the timer.$N****","OTE(RH2DoorLocks.Internal.LockPermissive)","0"
RCOMMENT,"RecycleHopper2","RH2DoorLocks","****$NThe permissive to unlock is delayed by the timer.$N****","OTE(RH2DoorLocks.Internal.UnlockPermissive)","1"
RCOMMENT,"RecycleHopper2","RH2DoorLocks","****$NThe unlock command works if the permissive above is satisfied.$N****","OTE(RH2DoorLocks.Internal.IntermediateUnlock)","2"
RCOMMENT,"RecycleHopper2","RH2DoorLocks","****$NStatus for the HMI$N****","OTE(RH2DoorLocks.Status.Locked)","3"
RCOMMENT,"RecycleHopper2","RH2DoorLocks","****$NStatus for the HMI$N****","OTE(RH2DoorLocks.Status.Unlocked)","4"
RCOMMENT,"RecycleHopper2","RH2DoorLocks","****$NFire the Outputs$N****","OTE(RH2TopAccessHatchReleaseSol)","5"
RCOMMENT,"RecycleHopper2","RH2ExtendedApron","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(RH2ExtendedApron.Internal.Permissive)","0"
RCOMMENT,"RecycleHopper2","RH2ExtendedApron","****$NJog Command$N****","OTE(RH2ExtendedApron.Internal.IntermediateJog)","1"
RCOMMENT,"RecycleHopper2","RH2ExtendedApron","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(RH2ExtendedApron.Internal.DriveReverse)","2"
RCOMMENT,"RecycleHopper2","RH2ExtendedApron","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(RH2ExtendedApron.Internal.MaintModeRun)","3"
RCOMMENT,"RecycleHopper2","RH2ExtendedApron","****$NAutomatic control.  The TON is dalay for start while the TOF is $Nthe delay for stop.$N****","OTE(RH2ExtendedApron.Internal.AutoModeRun)","4"
RCOMMENT,"RecycleHopper2","RH2ExtendedApron","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(RH2ExtendedApron.Internal.ReleaseRamp)","5"
RCOMMENT,"RecycleHopper2","RH2ExtendedApron","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(RH2ExtendedApron.Internal.DecelTime,RH2ExtendedApron.Internal.DecelTime)","6"
RCOMMENT,"RecycleHopper2","RH2ExtendedApron","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(RH2ExtendedApron.Internal.SpeedReference.ScaledOutput,RH2ExtendedApron:O.FreqCommand)","7"
RCOMMENT,"RecycleHopper2","RH2ExtendedApron","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(RH2ExtendedApron:O.Start)","8"
RCOMMENT,"RecycleHopper2","RH2ExtendedApron","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(RH2ExtendedApron:O.Stop)","9"
RCOMMENT,"RecycleHopper2","RH2ExtendedApron","****$NThe reverse command is set above.$N****","OTE(RH2ExtendedApron:O.Reverse)","10"
RCOMMENT,"RecycleHopper2","RH2ExtendedApron","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(RH2ExtendedApron:O.Forward)","11"
RCOMMENT,"RecycleHopper2","RH2ExtendedApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(RH2ExtendedApron.Internal.ActualSpeedScaler.ScaledOutput,RH2ExtendedApron.Status.ActualSpeed)","12"
RCOMMENT,"RecycleHopper2","RH2ExtendedApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(RH2ExtendedApron.Internal.LoadScaler.ScaledOutput,RH2ExtendedApron.Status.MotorLoad)","13"
RCOMMENT,"RecycleHopper2","RH2ExtendedApron","****$NDrive Running Status$N****","OTE(RH2ExtendedApron.Status.Running)","14"
RCOMMENT,"RecycleHopper2","RH2ExtendedApron","****$NJogging Forward Status$N****","OTE(RH2ExtendedApron.Status.JoggingFwd)","15"
RCOMMENT,"RecycleHopper2","RH2ExtendedApron","****$NJogging Reverse Status$N****","OTE(RH2ExtendedApron.Status.JoggingRev)","16"
RCOMMENT,"RecycleHopper2","RH2ExtendedApron","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(RH2ExtendedApron.Status.FailedToStart)","17"
RCOMMENT,"RecycleHopper2","RH2ExtendedApron","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(RH2ExtendedApron.Status.FailedToStop)","18"
RCOMMENT,"RecycleHopper2","RH2ExtendedApron","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(RH2ExtendedApron.Status.Faulted)","19"
RCOMMENT,"RecycleHopper2","RH2ExtendedApron","****$NUnlatch the Drive Faulted Status$N****","OTU(RH2ExtendedApron.Status.FailedToStop)","20"
RCOMMENT,"RecycleHopper2","RH2LiftApron","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(RH2LiftApron.Internal.Permissive)","0"
RCOMMENT,"RecycleHopper2","RH2LiftApron","****$NJog Command$N****","OTE(RH2LiftApron.Internal.IntermediateJog)","1"
RCOMMENT,"RecycleHopper2","RH2LiftApron","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(RH2LiftApron.Internal.DriveReverse)","2"
RCOMMENT,"RecycleHopper2","RH2LiftApron","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(RH2LiftApron.Internal.MaintModeRun)","3"
RCOMMENT,"RecycleHopper2","RH2LiftApron","****$NAutomatic control.  The TON is dalay for start while the TOF is $Nthe delay for stop.$N****","OTE(RH2LiftApron.Internal.AutoModeRun)","4"
RCOMMENT,"RecycleHopper2","RH2LiftApron","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(RH2LiftApron.Internal.ReleaseRamp)","5"
RCOMMENT,"RecycleHopper2","RH2LiftApron","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(RH2LiftApron.Internal.DecelTime,RH2LiftApron.Internal.DecelTime)","6"
RCOMMENT,"RecycleHopper2","RH2LiftApron","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(RH2LiftApron.Internal.SpeedReference.ScaledOutput,RH2LiftApron:O.FreqCommand)","7"
RCOMMENT,"RecycleHopper2","RH2LiftApron","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(RH2LiftApron:O.Start)","8"
RCOMMENT,"RecycleHopper2","RH2LiftApron","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(RH2LiftApron:O.Stop)","9"
RCOMMENT,"RecycleHopper2","RH2LiftApron","****$NThe reverse command is set above.$N****","OTE(RH2LiftApron:O.Reverse)","10"
RCOMMENT,"RecycleHopper2","RH2LiftApron","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(RH2LiftApron:O.Forward)","11"
RCOMMENT,"RecycleHopper2","RH2LiftApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(RH2LiftApron.Internal.ActualSpeedScaler.ScaledOutput,RH2LiftApron.Status.ActualSpeed)","12"
RCOMMENT,"RecycleHopper2","RH2LiftApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(RH2LiftApron.Internal.LoadScaler.ScaledOutput,RH2LiftApron.Status.MotorLoad)","13"
RCOMMENT,"RecycleHopper2","RH2LiftApron","****$NDrive Running Status$N****","OTE(RH2LiftApron.Status.Running)","14"
RCOMMENT,"RecycleHopper2","RH2LiftApron","****$NJogging Forward Status$N****","OTE(RH2LiftApron.Status.JoggingFwd)","15"
RCOMMENT,"RecycleHopper2","RH2LiftApron","****$NJogging Reverse Status$N****","OTE(RH2LiftApron.Status.JoggingRev)","16"
RCOMMENT,"RecycleHopper2","RH2LiftApron","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(RH2LiftApron.Status.FailedToStart)","17"
RCOMMENT,"RecycleHopper2","RH2LiftApron","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(RH2LiftApron.Status.FailedToStop)","18"
RCOMMENT,"RecycleHopper2","RH2LiftApron","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(RH2LiftApron.Status.Faulted)","19"
RCOMMENT,"RecycleHopper2","RH2LiftApron","****$NUnlatch the Drive Faulted Status$N****","OTU(RH2LiftApron.Status.FailedToStop)","20"
RCOMMENT,"RecycleHopper2","RH2Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(RH2Control,0)","0"
RCOMMENT,"RecycleHopper2","RH2Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(RH2DeliveryFan,0)","1"
RCOMMENT,"RecycleHopper2","RH2Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(RH2Doffer,0)","2"
RCOMMENT,"RecycleHopper2","RH2Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(RH2DoorLocks,0)","3"
RCOMMENT,"RecycleHopper2","RH2Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(RH2ExtendedApron,0)","4"
RCOMMENT,"RecycleHopper2","RH2Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(RH2LiftApron,0)","5"
RCOMMENT,"RecycleHopper2","RH2Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(RH2OutfeedFan,0)","6"
RCOMMENT,"RecycleHopper2","RH2OutfeedFan","****$NPermissive to operate the motor.$N****","OTE(RH2OutfeedFan.Internal.Permissive)","0"
RCOMMENT,"RecycleHopper2","RH2OutfeedFan","****$NManual Run Control$N****","OTE(RH2OutfeedFan.Internal.IntermediateRunForward)","1"
RCOMMENT,"RecycleHopper2","RH2OutfeedFan","****$NManual Jog Control$N****","OTE(RH2OutfeedFan.Internal.IntermediateJogForward)","2"
RCOMMENT,"RecycleHopper2","RH2OutfeedFan","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(RH2OutfeedFan.Internal.AutoOffDelayTimer,?,?)","3"
RCOMMENT,"RecycleHopper2","RH2OutfeedFan","****$NMotor Starter Control$N****","OTE(RH2OutfeedFanCont)","4"
RCOMMENT,"RecycleHopper2","RH2OutfeedFan","****$NRunning Status$N****","OTE(RH2OutfeedFan.Status.RunningForward)","5"
RCOMMENT,"RecycleHopper2","RH2OutfeedFan","****$NIf the motor does not start when commanded, it has failed to run$N****","OTL(RH2OutfeedFan.Status.FailedToStart)","6"
RCOMMENT,"RecycleHopper2","RH2OutfeedFan","****$NIf a motor continues to run when the run command has been removed,$Nit has failed to stop.$N****$N","OTL(RH2OutfeedFan.Status.FailedToStop)","7"
RCOMMENT,"RecycleHopper2","RH2OutfeedFan","****$NGeneral Faulted Status$N****","OTE(RH2OutfeedFan.Status.Faulted)","8"
RCOMMENT,"RecycleHopper2","RH2OutfeedFan","****$NReset Fault Latches$N****","OTU(RH2OutfeedFan.Status.FailedToStop)","9"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"SafetyProgram","CalenderZone","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","OTE(CalenderZone.Status.InputStatus)","0"
RCOMMENT,"SafetyProgram","CalenderZone","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****$NBecause the $QExternal$Q system has it$'s own reset, our output will automatically reset (with the SafetyYes jumper).$N****","OTE(CalenderZone.Status.EStopsUp)","1"
RCOMMENT,"SafetyProgram","CalenderZone","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(CalenderZone.Internal.EStopOkTmr,?,?)","2"
RCOMMENT,"SafetyProgram","CalenderZone","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(CalenderZone.Internal.EStopDelayTmr,?,?)","3"
RCOMMENT,"SafetyProgram","CalenderZone","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(CalenderZone.Internal.Feedback)","4"
RCOMMENT,"SafetyProgram","CalenderZone","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(CalenderZone.Internal.FeedbackStatus)","5"
RCOMMENT,"SafetyProgram","CalenderZone","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(CalenderZone.Internal.SafeOutput,POSITIVE,1000,CalenderZone.Internal.EStopOkTmr.DN,CalenderZone.Internal.Feedback,CalenderZone.Internal.Feedback,CalenderZone.Internal.FeedbackStatus,CalenderZoneExpansionUnitStatus,CalenderZone.Command.Reset)","6"
RCOMMENT,"SafetyProgram","CalenderZone","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(CalenderZone.Internal.SafeOutput.DiagnosticCode,CalenderZone.Internal.SafeOutput.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","CalenderZone","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(CalenderZone.Status.EStopStatus)","8"
RCOMMENT,"SafetyProgram","CalenderZone","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(CalenderSafetyExpansion2)","9"
RCOMMENT,"SafetyProgram","CrosslapperZone","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","OTE(CrosslapperZone.Status.InputStatus)","0"
RCOMMENT,"SafetyProgram","CrosslapperZone","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****$NBecause the $QExternal$Q system has it$'s own reset, our output will automatically reset (with the SafetyYes jumper).$N****","OTE(CrosslapperZone.Status.EStopsUp)","1"
RCOMMENT,"SafetyProgram","CrosslapperZone","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(CrosslapperZone.Internal.EStopOkTmr,?,?)","2"
RCOMMENT,"SafetyProgram","CrosslapperZone","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(CrosslapperZone.Internal.EStopDelayTmr,?,?)","3"
RCOMMENT,"SafetyProgram","CrosslapperZone","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(CrosslapperZone.Internal.Feedback)","4"
RCOMMENT,"SafetyProgram","CrosslapperZone","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(CrosslapperZone.Internal.FeedbackStatus)","5"
RCOMMENT,"SafetyProgram","CrosslapperZone","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(CrosslapperZone.Internal.SafeOutput,POSITIVE,1000,CrosslapperZone.Internal.EStopOkTmr.DN,CrosslapperZone.Internal.Feedback,CrosslapperZone.Internal.Feedback,CrosslapperZone.Internal.FeedbackStatus,CrosslapperZoneExpansionUnitStatus,CrosslapperZone.Command.Reset)","6"
RCOMMENT,"SafetyProgram","CrosslapperZone","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(CrosslapperZone.Internal.SafeOutput.DiagnosticCode,CrosslapperZone.Internal.SafeOutput.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","CrosslapperZone","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(CrosslapperZone.Status.EStopStatus)","8"
RCOMMENT,"SafetyProgram","CrosslapperZone","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(CrosslapperSafetyExpansion2)","9"
RCOMMENT,"SafetyProgram","ExitEquipmentZone","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","OTE(ExitEquipmentZone.Status.InputStatus)","0"
RCOMMENT,"SafetyProgram","ExitEquipmentZone","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****$NBecause the $QExternal$Q system has it$'s own reset, our output will automatically reset (with the SafetyYes jumper).$N****","OTE(ExitEquipmentZone.Status.EStopsUp)","1"
RCOMMENT,"SafetyProgram","ExitEquipmentZone","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(ExitEquipmentZone.Internal.EStopOkTmr,?,?)","2"
RCOMMENT,"SafetyProgram","ExitEquipmentZone","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(ExitEquipmentZone.Internal.EStopDelayTmr,?,?)","3"
RCOMMENT,"SafetyProgram","ExitEquipmentZone","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(ExitEquipmentZone.Internal.Feedback)","4"
RCOMMENT,"SafetyProgram","ExitEquipmentZone","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(ExitEquipmentZone.Internal.FeedbackStatus)","5"
RCOMMENT,"SafetyProgram","ExitEquipmentZone","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(ExitEquipmentZone.Internal.SafeOutput,POSITIVE,1000,ExitEquipmentZone.Internal.EStopOkTmr.DN,ExitEquipmentZone.Internal.Feedback,ExitEquipmentZone.Internal.Feedback,ExitEquipmentZone.Internal.FeedbackStatus,ExitEquipmentZoneExpansionUnitStatus,ExitEquipmentZone.Command.Reset)","6"
RCOMMENT,"SafetyProgram","ExitEquipmentZone","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(ExitEquipmentZone.Internal.SafeOutput.DiagnosticCode,ExitEquipmentZone.Internal.SafeOutput.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","ExitEquipmentZone","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(ExitEquipmentZone.Status.EStopStatus)","8"
RCOMMENT,"SafetyProgram","ExitEquipmentZone","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(ExitEquipmentSafetyExpansion2)","9"
RCOMMENT,"SafetyProgram","GlobalInputsStatus","****$NThese are the inputs that are considered the global e-stops.$N****","OTE(GlobalSafetyInputStatus)","0"
RCOMMENT,"SafetyProgram","LoomsZone","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","OTE(LoomsZone.Status.InputStatus)","0"
RCOMMENT,"SafetyProgram","LoomsZone","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****$NBecause the $QExternal$Q system has it$'s own reset, our output will automatically reset (with the SafetyYes jumper).$N****","OTE(LoomsZone.Status.EStopsUp)","1"
RCOMMENT,"SafetyProgram","LoomsZone","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(LoomsZone.Internal.EStopOkTmr,?,?)","2"
RCOMMENT,"SafetyProgram","LoomsZone","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(LoomsZone.Internal.EStopDelayTmr,?,?)","3"
RCOMMENT,"SafetyProgram","LoomsZone","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(LoomsZone.Internal.Feedback)","4"
RCOMMENT,"SafetyProgram","LoomsZone","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(LoomsZone.Internal.FeedbackStatus)","5"
RCOMMENT,"SafetyProgram","LoomsZone","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(LoomsZone.Internal.SafeOutput,POSITIVE,1000,LoomsZone.Internal.EStopOkTmr.DN,LoomsZone.Internal.Feedback,LoomsZone.Internal.Feedback,LoomsZone.Internal.FeedbackStatus,LoomsZoneExpansionUnitStatus,LoomsZone.Command.Reset)","6"
RCOMMENT,"SafetyProgram","LoomsZone","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(LoomsZone.Internal.SafeOutput.DiagnosticCode,LoomsZone.Internal.SafeOutput.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","LoomsZone","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(LoomsZone.Status.EStopStatus)","8"
RCOMMENT,"SafetyProgram","LoomsZone","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(LoomsSafetyExpansion2)","9"
RCOMMENT,"SafetyProgram","MotorZeroSpeeds","****$NThe safety zero speed input must be on for the specified time before$Nthe status is turned on.  The status is used elsewhere in the system.$N****","OTE(Zone11ChutefeedBeaterZSpeedStatus)","0"
RCOMMENT,"SafetyProgram","MotorZeroSpeeds","****$NThe safety zero speed input must be on for the specified time before$Nthe status is turned on.  The status is used elsewhere in the system.$N****","OTE(BO1BaleBreakerZSpeedStatus)","1"
RCOMMENT,"SafetyProgram","MotorZeroSpeeds","****$NThe safety zero speed input must be on for the specified time before$Nthe status is turned on.  The status is used elsewhere in the system.$N****","OTE(BO2BaleBreakerZSpeedStatus)","2"
RCOMMENT,"SafetyProgram","MotorZeroSpeeds","****$NThe safety zero speed input must be on for the specified time before$Nthe status is turned on.  The status is used elsewhere in the system.$N****","OTE(BO3BaleBreakerZSpeedStatus)","3"
RCOMMENT,"SafetyProgram","MotorZeroSpeeds","****$NThe safety zero speed input must be on for the specified time before$Nthe status is turned on.  The status is used elsewhere in the system.$N****","OTE(BO4BaleBreakerZSpeedStatus)","4"
RCOMMENT,"SafetyProgram","MotorZeroSpeeds","****$NThe safety zero speed input must be on for the specified time before$Nthe status is turned on.  The status is used elsewhere in the system.$N****","OTE(BO5BaleBreakerZSpeedStatus)","5"
RCOMMENT,"SafetyProgram","MotorZeroSpeeds","****$NThe safety zero speed input must be on for the specified time before$Nthe status is turned on.  The status is used elsewhere in the system.$N****","OTE(B1BlenderBeaterZSpeedStatus)","6"
RCOMMENT,"SafetyProgram","MotorZeroSpeeds","****$NThe safety zero speed input must be on for the specified time before$Nthe status is turned on.  The status is used elsewhere in the system.$N****","OTE(FS51BeaterZSpeedStatus)","7"
RCOMMENT,"SafetyProgram","MotorZeroSpeeds","****$NThe safety zero speed input must be on for the specified time before$Nthe status is turned on.  The status is used elsewhere in the system.$N****","OTE(FS52BeaterZSpeedStatus)","8"
RCOMMENT,"SafetyProgram","MotorZeroSpeeds","****$NThe safety zero speed input must be on for the specified time before$Nthe status is turned on.  The status is used elsewhere in the system.$N****","OTE(RH1DofferZSpeedStatus)","9"
RCOMMENT,"SafetyProgram","MotorZeroSpeeds","****$NThe safety zero speed input must be on for the specified time before$Nthe status is turned on.  The status is used elsewhere in the system.$N****","OTE(RH2DofferZSpeedStatus)","10"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(HMIStation1EStopPB.DCS.DiagnosticCode,HMIStation1EStopPB.DCS.DiagnosticCode)","0"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(HMIStation3EStopPB.DCS.DiagnosticCode,HMIStation3EStopPB.DCS.DiagnosticCode)","1"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(HMIStation4EStopPB.DCS.DiagnosticCode,HMIStation4EStopPB.DCS.DiagnosticCode)","2"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CrosslapperEStop.DCS.DiagnosticCode,CrosslapperEStop.DCS.DiagnosticCode)","3"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(LoomsEStop.DCS.DiagnosticCode,LoomsEStop.DCS.DiagnosticCode)","4"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CalenderEStop.DCS.DiagnosticCode,CalenderEStop.DCS.DiagnosticCode)","5"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(ExitEquipmentEStop.DCS.DiagnosticCode,ExitEquipmentEStop.DCS.DiagnosticCode)","6"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(BO1PanelEStopPB.DCS.DiagnosticCode,BO1PanelEStopPB.DCS.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(BO1RightBaleEntryEStopPB.DCS.DiagnosticCode,BO1RightBaleEntryEStopPB.DCS.DiagnosticCode)","8"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(BO1LoadDoorSafety.DCS.DiagnosticCode,BO1LoadDoorSafety.DCS.DiagnosticCode)","9"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(BO1TopAccessHatch.DCS.DiagnosticCode,BO1TopAccessHatch.DCS.DiagnosticCode)","10"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(BO2PanelEStopPB.DCS.DiagnosticCode,BO2PanelEStopPB.DCS.DiagnosticCode)","11"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(BO2RightBaleEntryEStopPB.DCS.DiagnosticCode,BO2RightBaleEntryEStopPB.DCS.DiagnosticCode)","12"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(BO2LoadDoorSafety.DCS.DiagnosticCode,BO2LoadDoorSafety.DCS.DiagnosticCode)","13"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(BO2TopAccessHatch.DCS.DiagnosticCode,BO2TopAccessHatch.DCS.DiagnosticCode)","14"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(BO3PanelEStopPB.DCS.DiagnosticCode,BO3PanelEStopPB.DCS.DiagnosticCode)","15"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(BO3RightBaleEntryEStopPB.DCS.DiagnosticCode,BO3RightBaleEntryEStopPB.DCS.DiagnosticCode)","16"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(BO3LoadDoorSafety.DCS.DiagnosticCode,BO3LoadDoorSafety.DCS.DiagnosticCode)","17"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(BO3TopAccessHatch.DCS.DiagnosticCode,BO3TopAccessHatch.DCS.DiagnosticCode)","18"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(BO4PanelEStopPB.DCS.DiagnosticCode,BO4PanelEStopPB.DCS.DiagnosticCode)","19"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(BO4RightBaleEntryEStopPB.DCS.DiagnosticCode,BO4RightBaleEntryEStopPB.DCS.DiagnosticCode)","20"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(BO4LoadDoorSafety.DCS.DiagnosticCode,BO4LoadDoorSafety.DCS.DiagnosticCode)","21"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(BO4TopAccessHatch.DCS.DiagnosticCode,BO4TopAccessHatch.DCS.DiagnosticCode)","22"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(BO5PanelEStopPB.DCS.DiagnosticCode,BO5PanelEStopPB.DCS.DiagnosticCode)","23"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(BO5RightBaleEntryEStopPB.DCS.DiagnosticCode,BO5RightBaleEntryEStopPB.DCS.DiagnosticCode)","24"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(BO5LoadDoorSafety.DCS.DiagnosticCode,BO5LoadDoorSafety.DCS.DiagnosticCode)","25"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(BO5TopAccessHatch.DCS.DiagnosticCode,BO5TopAccessHatch.DCS.DiagnosticCode)","26"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(TH6PanelEStopPB.DCS.DiagnosticCode,TH6PanelEStopPB.DCS.DiagnosticCode)","27"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(TH6RightAccessDoor.DCS.DiagnosticCode,TH6RightAccessDoor.DCS.DiagnosticCode)","28"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(TH6LeftAccessDoor.DCS.DiagnosticCode,TH6LeftAccessDoor.DCS.DiagnosticCode)","29"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(TH7PanelEStopPB.DCS.DiagnosticCode,TH7PanelEStopPB.DCS.DiagnosticCode)","30"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(TH7RightBaleEntryEStopPB.DCS.DiagnosticCode,TH7RightBaleEntryEStopPB.DCS.DiagnosticCode)","31"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(TH7RightAccessDoor.DCS.DiagnosticCode,TH7RightAccessDoor.DCS.DiagnosticCode)","32"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(TH7LeftAccessDoor.DCS.DiagnosticCode,TH7LeftAccessDoor.DCS.DiagnosticCode)","33"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(RH1RightEStopPB.DCS.DiagnosticCode,RH1RightEStopPB.DCS.DiagnosticCode)","34"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(RH1LeftEStopPB.DCS.DiagnosticCode,RH1LeftEStopPB.DCS.DiagnosticCode)","35"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(RH1SideAccessDoorSwitch.DCS.DiagnosticCode,RH1SideAccessDoorSwitch.DCS.DiagnosticCode)","36"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(RH1TopAccessHatch.DCS.DiagnosticCode,RH1TopAccessHatch.DCS.DiagnosticCode)","37"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(RH2RightEStopPB.DCS.DiagnosticCode,RH2RightEStopPB.DCS.DiagnosticCode)","38"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(RH2LeftEStopPB.DCS.DiagnosticCode,RH2LeftEStopPB.DCS.DiagnosticCode)","39"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(RH2SideAccessDoorSwitch.DCS.DiagnosticCode,RH2SideAccessDoorSwitch.DCS.DiagnosticCode)","40"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(RH2TopAccessHatch.DCS.DiagnosticCode,RH2TopAccessHatch.DCS.DiagnosticCode)","41"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(B1BlenderLeftEStopPB.DCS.DiagnosticCode,B1BlenderLeftEStopPB.DCS.DiagnosticCode)","42"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(B1BlenderRightEStopPB.DCS.DiagnosticCode,B1BlenderRightEStopPB.DCS.DiagnosticCode)","43"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(VBOLeftEStopPB.DCS.DiagnosticCode,VBOLeftEStopPB.DCS.DiagnosticCode)","44"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(VBORightEStopPB.DCS.DiagnosticCode,VBORightEStopPB.DCS.DiagnosticCode)","45"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(B1_VBO_FS51RPDoorEStopPB.DCS.DiagnosticCode,B1_VBO_FS51RPDoorEStopPB.DCS.DiagnosticCode)","46"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(FS51InspectionDoorSwitch.DCS.DiagnosticCode,FS51InspectionDoorSwitch.DCS.DiagnosticCode)","47"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(FS52PanelEStopPB.DCS.DiagnosticCode,FS52PanelEStopPB.DCS.DiagnosticCode)","48"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(FS52UpperInspectionDoorSwitch.DCS.DiagnosticCode,FS52UpperInspectionDoorSwitch.DCS.DiagnosticCode)","49"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(FS52LowerInspectionDoorSwitch.DCS.DiagnosticCode,FS52LowerInspectionDoorSwitch.DCS.DiagnosticCode)","50"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardLeftFeedrollDoorEStopPB.DCS.DiagnosticCode,CardLeftFeedrollDoorEStopPB.DCS.DiagnosticCode)","51"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardLeftApronDoorEStopPB.DCS.DiagnosticCode,CardLeftApronDoorEStopPB.DCS.DiagnosticCode)","52"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardRightFeedrollDoorEStopPB.DCS.DiagnosticCode,CardRightFeedrollDoorEStopPB.DCS.DiagnosticCode)","53"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardRightApronDoorEStopPB.DCS.DiagnosticCode,CardRightApronDoorEStopPB.DCS.DiagnosticCode)","54"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(DrafterLeftEStopPB.DCS.DiagnosticCode,DrafterLeftEStopPB.DCS.DiagnosticCode)","55"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(DrafterRightEStopPB.DCS.DiagnosticCode,DrafterRightEStopPB.DCS.DiagnosticCode)","56"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(ChutefeedFrontLeftLeftDoor.DCS.DiagnosticCode,ChutefeedFrontLeftLeftDoor.DCS.DiagnosticCode)","57"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(ChutefeedFrontLeftRightDoor.DCS.DiagnosticCode,ChutefeedFrontLeftRightDoor.DCS.DiagnosticCode)","58"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(ChutefeedFrontRightLeftDoor.DCS.DiagnosticCode,ChutefeedFrontRightLeftDoor.DCS.DiagnosticCode)","59"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(ChutefeedFrontRightRightDoor.DCS.DiagnosticCode,ChutefeedFrontRightRightDoor.DCS.DiagnosticCode)","60"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(ChutefeedFrontAccessDoor.DCS.DiagnosticCode,ChutefeedFrontAccessDoor.DCS.DiagnosticCode)","61"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardLeftScaleBeltDoor.DCS.DiagnosticCode,CardLeftScaleBeltDoor.DCS.DiagnosticCode)","62"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardLeftDoor1.DCS.DiagnosticCode,CardLeftDoor1.DCS.DiagnosticCode)","63"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardLeftDoor2.DCS.DiagnosticCode,CardLeftDoor2.DCS.DiagnosticCode)","64"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardLeftDoor3.DCS.DiagnosticCode,CardLeftDoor3.DCS.DiagnosticCode)","65"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardLeftDoor4.DCS.DiagnosticCode,CardLeftDoor4.DCS.DiagnosticCode)","66"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardLeftDoor5.DCS.DiagnosticCode,CardLeftDoor5.DCS.DiagnosticCode)","67"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardLeftDoor6.DCS.DiagnosticCode,CardLeftDoor6.DCS.DiagnosticCode)","68"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardLeftDoor7.DCS.DiagnosticCode,CardLeftDoor7.DCS.DiagnosticCode)","69"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardLeftBottomAccessDoor.DCS.DiagnosticCode,CardLeftBottomAccessDoor.DCS.DiagnosticCode)","70"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardRightScaleBeltDoor.DCS.DiagnosticCode,CardRightScaleBeltDoor.DCS.DiagnosticCode)","71"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardRightDoor1.DCS.DiagnosticCode,CardRightDoor1.DCS.DiagnosticCode)","72"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardRightDoor2.DCS.DiagnosticCode,CardRightDoor2.DCS.DiagnosticCode)","73"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardRightDoor3.DCS.DiagnosticCode,CardRightDoor3.DCS.DiagnosticCode)","74"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardRightDoor4.DCS.DiagnosticCode,CardRightDoor4.DCS.DiagnosticCode)","75"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardRightDoor5.DCS.DiagnosticCode,CardRightDoor5.DCS.DiagnosticCode)","76"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardRightDoor6.DCS.DiagnosticCode,CardRightDoor6.DCS.DiagnosticCode)","77"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardRightDoor7.DCS.DiagnosticCode,CardRightDoor7.DCS.DiagnosticCode)","78"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardRightBottomAccessDoor.DCS.DiagnosticCode,CardRightBottomAccessDoor.DCS.DiagnosticCode)","79"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(DrafterLeftDoor1.DCS.DiagnosticCode,DrafterLeftDoor1.DCS.DiagnosticCode)","80"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardFeedrollTopHatch.DCS.DiagnosticCode,CardFeedrollTopHatch.DCS.DiagnosticCode)","81"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(DrafterRightDoor1.DCS.DiagnosticCode,DrafterRightDoor1.DCS.DiagnosticCode)","82"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardCover1ClosedProx.DCS.DiagnosticCode,CardCover1ClosedProx.DCS.DiagnosticCode)","83"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardCover2ClosedProx.DCS.DiagnosticCode,CardCover2ClosedProx.DCS.DiagnosticCode)","84"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardCover3ClosedProx.DCS.DiagnosticCode,CardCover3ClosedProx.DCS.DiagnosticCode)","85"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CardCover4ClosedProx.DCS.DiagnosticCode,CardCover4ClosedProx.DCS.DiagnosticCode)","86"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(ChuteReserveHopperLeftAccessDoor.DCS.DiagnosticCode,ChuteReserveHopperLeftAccessDoor.DCS.DiagnosticCode)","87"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(ChuteReserveHopperRightAccessDoor.DCS.DiagnosticCode,ChuteReserveHopperRightAccessDoor.DCS.DiagnosticCode)","88"
RCOMMENT,"SafetyProgram","RedundantSafetyInputs","****$NThe actual inputs are mapped to bits before being used in the DCS instruction.  If$Nthe instruction has a fault present (FP), the branches below may be used to troubleshoot.$N****","MOV(CrosslapperCV1AccessDoor.DCS.DiagnosticCode,CrosslapperCV1AccessDoor.DCS.DiagnosticCode)","89"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","0"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","1"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","2"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","3"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","4"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","5"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","6"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","7"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","8"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","9"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","10"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","11"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","12"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","13"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","14"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","15"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","16"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","17"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","18"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","19"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","20"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","21"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","22"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","23"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","24"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","25"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","26"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","27"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","28"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","29"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","30"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","31"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","32"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","33"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","34"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","35"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","36"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","37"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","38"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","39"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","40"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","41"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","42"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","43"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","44"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","45"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","46"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","47"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","48"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","49"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","50"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","51"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","52"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","53"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","54"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","55"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","56"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","57"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","58"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","59"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","60"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","61"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","62"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","63"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","64"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","65"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","66"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","67"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","68"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","69"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","70"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","71"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","72"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","73"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","74"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","75"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","76"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","77"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","78"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","79"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","80"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","81"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","82"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","83"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","84"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","85"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","86"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","87"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","88"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","89"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","90"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","91"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","92"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","93"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","94"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","95"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","96"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","97"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","98"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","99"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","100"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","101"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","102"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","103"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","104"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","105"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","106"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","107"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","108"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","109"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","110"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","111"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","112"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","113"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","114"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","115"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","116"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","117"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","118"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","119"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","120"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","121"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","122"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","123"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","124"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","125"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","126"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","127"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","128"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","129"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","130"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","131"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","132"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","133"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","134"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","135"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","136"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","137"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","138"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","139"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","140"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","141"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","142"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","143"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","144"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","145"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","146"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","147"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","148"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","149"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","150"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","151"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","152"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","153"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","154"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","155"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","156"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","157"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","158"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","159"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","160"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","161"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","162"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","163"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","164"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","165"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","166"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","167"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","168"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","169"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","170"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","171"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","172"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","173"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","174"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","175"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","176"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","177"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","178"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","179"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","180"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","181"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","182"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","183"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","184"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","185"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","186"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","187"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","188"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","189"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","190"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","191"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","192"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","193"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","194"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","195"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","196"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","197"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","198"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","199"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","200"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","201"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","202"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","203"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","204"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","205"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","206"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","207"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","208"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","209"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","210"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","211"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","212"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","213"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","214"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","215"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","216"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","217"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","218"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","219"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","220"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","221"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","222"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","223"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","224"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","225"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","226"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","227"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","228"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","229"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","230"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","231"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","232"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","233"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","234"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","235"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","236"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","237"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","238"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","239"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","240"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","241"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","242"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","243"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","244"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","245"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","246"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","247"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","248"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","249"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","250"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","251"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","252"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","253"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","254"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","255"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","256"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","257"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","258"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","259"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","260"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","261"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","262"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","263"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","264"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","265"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","266"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","267"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","268"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","269"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","270"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","271"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","272"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","273"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","274"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","275"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","276"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","277"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","278"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","279"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","280"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","281"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","282"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","283"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","284"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","285"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","286"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","287"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","288"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","289"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","290"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","291"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","292"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","293"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","294"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","295"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","296"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","297"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","298"
RCOMMENT,"SafetyProgram","SafetyAlarms","****$NOnce a condition has occured, the alarm timer starts.  If the condition stays until the timer$Ngets done, the alarm latches itself in.  Also, the alarm one shots to tell us when a new$Nalarm has occured.$N****","OTL(SafetyAlarms.NewAlarm)","299"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(CalenderZone,0)","3"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(CrosslapperZone,0)","4"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(ExitEquipmentZone,0)","5"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(GlobalInputsStatus,0)","6"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(LoomsZone,0)","7"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(MotorZeroSpeeds,0)","8"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(RedundantSafetyInputs,0)","9"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(SafetyAlarms,0)","10"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Zone10,0)","11"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Zone11,0)","12"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Zone12,0)","13"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Zone13,0)","14"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Zone14,0)","15"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Zone15CardCovers,0)","16"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Zone16,0)","17"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Zone1A,0)","18"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Zone1B,0)","19"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Zone2A,0)","20"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Zone2B,0)","21"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Zone3A,0)","22"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Zone3B,0)","23"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Zone4A,0)","24"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Zone4B,0)","25"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Zone5A,0)","26"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Zone5B,0)","27"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Zone6,0)","28"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Zone7,0)","29"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Zone8,0)","30"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(Zone9,0)","31"
RCOMMENT,"SafetyProgram","SafetyProgramMain","****$NUse the main routine to call the other routines in the program.$N****","JSR(ZoneResets,0)","32"
RCOMMENT,"SafetyProgram","Zone10","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","TOF(Zone10InputsDelayOff,?,?)","0"
RCOMMENT,"SafetyProgram","Zone10","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****","OTE(Zone10.Status.EStopsUp)","2"
RCOMMENT,"SafetyProgram","Zone10","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(Zone10.Internal.EStopOkTmr,?,?)","3"
RCOMMENT,"SafetyProgram","Zone10","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(Zone10.Internal.EStopDelayTmr,?,?)","4"
RCOMMENT,"SafetyProgram","Zone10","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(Zone10.Internal.Feedback)","5"
RCOMMENT,"SafetyProgram","Zone10","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(Zone10.Internal.FeedbackStatus)","6"
RCOMMENT,"SafetyProgram","Zone10","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(Zone10.Internal.SafeOutput,POSITIVE,1000,Zone10.Internal.EStopOkTmr.DN,Zone10.Internal.Feedback,Zone10.Internal.Feedback,Zone10.Internal.FeedbackStatus,Zone10ExpansionUnitStatus,Zone10.Command.Reset)","7"
RCOMMENT,"SafetyProgram","Zone10","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(Zone10.Internal.SafeOutput.DiagnosticCode,Zone10.Internal.SafeOutput.DiagnosticCode)","8"
RCOMMENT,"SafetyProgram","Zone10","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(Zone10.Status.EStopStatus)","9"
RCOMMENT,"SafetyProgram","Zone10","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(Zone10SafetyExpansion2)","10"
RCOMMENT,"SafetyProgram","Zone11","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","OTE(Zone11.Status.InputStatus)","0"
RCOMMENT,"SafetyProgram","Zone11","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****","OTE(Zone11.Status.EStopsUp)","1"
RCOMMENT,"SafetyProgram","Zone11","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(Zone11.Internal.EStopOkTmr,?,?)","2"
RCOMMENT,"SafetyProgram","Zone11","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(Zone11.Internal.EStopDelayTmr,?,?)","3"
RCOMMENT,"SafetyProgram","Zone11","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(Zone11.Internal.Feedback)","4"
RCOMMENT,"SafetyProgram","Zone11","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(Zone11.Internal.FeedbackStatus)","5"
RCOMMENT,"SafetyProgram","Zone11","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(Zone11.Internal.SafeOutput,POSITIVE,1000,Zone11.Internal.EStopOkTmr.DN,Zone11.Internal.Feedback,Zone11.Internal.Feedback,Zone11.Internal.FeedbackStatus,Zone11ExpansionUnitStatus,Zone11.Command.Reset)","6"
RCOMMENT,"SafetyProgram","Zone11","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(Zone11.Internal.SafeOutput.DiagnosticCode,Zone11.Internal.SafeOutput.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","Zone11","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(Zone11.Status.EStopStatus)","8"
RCOMMENT,"SafetyProgram","Zone11","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(Zone11SafetyExpansion2)","9"
RCOMMENT,"SafetyProgram","Zone12","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","OTE(Zone12.Status.InputStatus)","0"
RCOMMENT,"SafetyProgram","Zone12","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****","OTE(Zone12.Status.EStopsUp)","1"
RCOMMENT,"SafetyProgram","Zone12","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(Zone12.Internal.EStopOkTmr,?,?)","2"
RCOMMENT,"SafetyProgram","Zone12","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(Zone12.Internal.EStopDelayTmr,?,?)","3"
RCOMMENT,"SafetyProgram","Zone12","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(Zone12.Internal.Feedback)","4"
RCOMMENT,"SafetyProgram","Zone12","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(Zone12.Internal.FeedbackStatus)","5"
RCOMMENT,"SafetyProgram","Zone12","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(Zone12.Internal.SafeOutput,POSITIVE,1000,Zone12.Internal.EStopOkTmr.DN,Zone12.Internal.Feedback,Zone12.Internal.Feedback,Zone12.Internal.FeedbackStatus,Zone12ExpansionUnitStatus,Zone12.Command.Reset)","6"
RCOMMENT,"SafetyProgram","Zone12","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(Zone12.Internal.SafeOutput.DiagnosticCode,Zone12.Internal.SafeOutput.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","Zone12","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(Zone12.Status.EStopStatus)","8"
RCOMMENT,"SafetyProgram","Zone12","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(Zone12SafetyExpansion2)","9"
RCOMMENT,"SafetyProgram","Zone13","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","OTE(Zone13.Status.InputStatus)","0"
RCOMMENT,"SafetyProgram","Zone13","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****","OTE(Zone13.Status.EStopsUp)","1"
RCOMMENT,"SafetyProgram","Zone13","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(Zone13.Internal.EStopOkTmr,?,?)","2"
RCOMMENT,"SafetyProgram","Zone13","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(Zone13.Internal.EStopDelayTmr,?,?)","3"
RCOMMENT,"SafetyProgram","Zone13","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(Zone13.Internal.Feedback)","4"
RCOMMENT,"SafetyProgram","Zone13","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(Zone13.Internal.FeedbackStatus)","5"
RCOMMENT,"SafetyProgram","Zone13","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(Zone13.Internal.SafeOutput,POSITIVE,1000,Zone13.Internal.EStopOkTmr.DN,Zone13.Internal.Feedback,Zone13.Internal.Feedback,Zone13.Internal.FeedbackStatus,Zone13ExpansionUnitStatus,Zone13.Command.Reset)","6"
RCOMMENT,"SafetyProgram","Zone13","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(Zone13.Internal.SafeOutput.DiagnosticCode,Zone13.Internal.SafeOutput.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","Zone13","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(Zone13.Status.EStopStatus)","8"
RCOMMENT,"SafetyProgram","Zone13","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(Zone13SafetyExpansion2)","9"
RCOMMENT,"SafetyProgram","Zone14","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","OTE(Zone14.Status.InputStatus)","0"
RCOMMENT,"SafetyProgram","Zone14","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****","OTE(Zone14.Status.EStopsUp)","1"
RCOMMENT,"SafetyProgram","Zone14","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(Zone14.Internal.EStopOkTmr,?,?)","2"
RCOMMENT,"SafetyProgram","Zone14","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(Zone14.Internal.EStopDelayTmr,?,?)","3"
RCOMMENT,"SafetyProgram","Zone14","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(Zone14.Internal.Feedback)","4"
RCOMMENT,"SafetyProgram","Zone14","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(Zone14.Internal.FeedbackStatus)","5"
RCOMMENT,"SafetyProgram","Zone14","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(Zone14.Internal.SafeOutput,POSITIVE,1000,Zone14.Internal.EStopOkTmr.DN,Zone14.Internal.Feedback,Zone14.Internal.Feedback,Zone14.Internal.FeedbackStatus,Zone14ExpansionUnitStatus,Zone14.Command.Reset)","6"
RCOMMENT,"SafetyProgram","Zone14","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(Zone14.Internal.SafeOutput.DiagnosticCode,Zone14.Internal.SafeOutput.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","Zone14","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(Zone14.Status.EStopStatus)","8"
RCOMMENT,"SafetyProgram","Zone14","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(Zone14SafetyExpansion2)","9"
RCOMMENT,"SafetyProgram","Zone15CardCovers","****$NBecause the outputs are safety rated, they must$Nbe controlled from the safety task.  The logic that drives the$Ncontrolling bits are found the the standard program under $QCardCovers$Q.$N****","OTE(CardCoverCylindersDown)","0"
RCOMMENT,"SafetyProgram","Zone15CardCovers","****$NBecause the outputs are safety rated, they must$Nbe controlled from the safety task.  The logic that drives the$Ncontrolling bits are found the the standard program under $QCardCovers$Q.$N****","OTE(CardCoverCylindersUp)","1"
RCOMMENT,"SafetyProgram","Zone15CardCovers","****$NIf either of the contactors fail to go to the appropriate state, the$Ncard cover system will fault.$N****","OTL(SafetyCardCoverFailedToRun)","2"
RCOMMENT,"SafetyProgram","Zone15CardCovers","****$NIf either of the contactors fail to go to the appropriate state, the$Ncard cover system will fault.$N****","OTL(SafetyCardCoverFailedToStop)","3"
RCOMMENT,"SafetyProgram","Zone15CardCovers","****$NIf the system fails to got to the appropriate state, a fault is generated.  This$Nfault will prevent any further attempt until a reset is requested.$N****","OTE(SafetyCardCoverFault)","4"
RCOMMENT,"SafetyProgram","Zone15CardCovers","****$NA reset can be sent if the inputs have returned to the safe state.$N****","OTU(SafetyCardCoverFailedToStop)","5"
RCOMMENT,"SafetyProgram","Zone16","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","OTE(Zone16.Status.InputStatus)","0"
RCOMMENT,"SafetyProgram","Zone16","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****","OTE(Zone16.Status.EStopsUp)","1"
RCOMMENT,"SafetyProgram","Zone16","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(Zone16.Internal.EStopOkTmr,?,?)","2"
RCOMMENT,"SafetyProgram","Zone16","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(Zone16.Internal.EStopDelayTmr,?,?)","3"
RCOMMENT,"SafetyProgram","Zone16","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(Zone16.Internal.Feedback)","4"
RCOMMENT,"SafetyProgram","Zone16","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(Zone16.Internal.FeedbackStatus)","5"
RCOMMENT,"SafetyProgram","Zone16","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(Zone16.Internal.SafeOutput,POSITIVE,1000,Zone16.Internal.EStopOkTmr.DN,Zone16.Internal.Feedback,Zone16.Internal.Feedback,Zone16.Internal.FeedbackStatus,Zone16ExpansionUnitStatus,Zone16.Command.Reset)","6"
RCOMMENT,"SafetyProgram","Zone16","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(Zone16.Internal.SafeOutput.DiagnosticCode,Zone16.Internal.SafeOutput.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","Zone16","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(Zone16.Status.EStopStatus)","8"
RCOMMENT,"SafetyProgram","Zone16","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(Zone16SafetyExpansion2)","9"
RCOMMENT,"SafetyProgram","Zone1A","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","OTE(Zone1A.Status.InputStatus)","0"
RCOMMENT,"SafetyProgram","Zone1A","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****","OTE(Zone1A.Status.EStopsUp)","1"
RCOMMENT,"SafetyProgram","Zone1A","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(Zone1A.Internal.EStopOkTmr,?,?)","2"
RCOMMENT,"SafetyProgram","Zone1A","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(Zone1A.Internal.EStopDelayTmr,?,?)","3"
RCOMMENT,"SafetyProgram","Zone1A","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(Zone1A.Internal.Feedback)","4"
RCOMMENT,"SafetyProgram","Zone1A","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(Zone1A.Internal.FeedbackStatus)","5"
RCOMMENT,"SafetyProgram","Zone1A","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(Zone1A.Internal.SafeOutput,POSITIVE,1000,Zone1A.Internal.EStopOkTmr.DN,Zone1A.Internal.Feedback,Zone1A.Internal.Feedback,Zone1A.Internal.FeedbackStatus,Zone1AExpansionUnitStatus,Zone1A.Command.Reset)","6"
RCOMMENT,"SafetyProgram","Zone1A","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(Zone1A.Internal.SafeOutput.DiagnosticCode,Zone1A.Internal.SafeOutput.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","Zone1A","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(Zone1A.Status.EStopStatus)","8"
RCOMMENT,"SafetyProgram","Zone1A","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(Zone1ASafetyExpansion2)","9"
RCOMMENT,"SafetyProgram","Zone1B","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","OTE(Zone1B.Status.InputStatus)","0"
RCOMMENT,"SafetyProgram","Zone1B","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****","OTE(Zone1B.Status.EStopsUp)","1"
RCOMMENT,"SafetyProgram","Zone1B","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(Zone1B.Internal.EStopOkTmr,?,?)","2"
RCOMMENT,"SafetyProgram","Zone1B","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(Zone1B.Internal.EStopDelayTmr,?,?)","3"
RCOMMENT,"SafetyProgram","Zone1B","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(Zone1B.Internal.Feedback)","4"
RCOMMENT,"SafetyProgram","Zone1B","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(Zone1B.Internal.FeedbackStatus)","5"
RCOMMENT,"SafetyProgram","Zone1B","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(Zone1B.Internal.SafeOutput,POSITIVE,1000,Zone1B.Internal.EStopOkTmr.DN,Zone1B.Internal.Feedback,Zone1B.Internal.Feedback,Zone1B.Internal.FeedbackStatus,Zone1BExpansionUnitStatus,Zone1B.Command.Reset)","6"
RCOMMENT,"SafetyProgram","Zone1B","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(Zone1B.Internal.SafeOutput.DiagnosticCode,Zone1B.Internal.SafeOutput.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","Zone1B","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(Zone1B.Status.EStopStatus)","8"
RCOMMENT,"SafetyProgram","Zone1B","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(Zone1BSafetyExpansion2)","9"
RCOMMENT,"SafetyProgram","Zone2A","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","OTE(Zone2A.Status.InputStatus)","0"
RCOMMENT,"SafetyProgram","Zone2A","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****","OTE(Zone2A.Status.EStopsUp)","1"
RCOMMENT,"SafetyProgram","Zone2A","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(Zone2A.Internal.EStopOkTmr,?,?)","2"
RCOMMENT,"SafetyProgram","Zone2A","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(Zone2A.Internal.EStopDelayTmr,?,?)","3"
RCOMMENT,"SafetyProgram","Zone2A","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(Zone2A.Internal.Feedback)","4"
RCOMMENT,"SafetyProgram","Zone2A","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(Zone2A.Internal.FeedbackStatus)","5"
RCOMMENT,"SafetyProgram","Zone2A","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(Zone2A.Internal.SafeOutput,POSITIVE,1000,Zone2A.Internal.EStopOkTmr.DN,Zone2A.Internal.Feedback,Zone2A.Internal.Feedback,Zone2A.Internal.FeedbackStatus,Zone2AExpansionUnitStatus,Zone2A.Command.Reset)","6"
RCOMMENT,"SafetyProgram","Zone2A","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(Zone2A.Internal.SafeOutput.DiagnosticCode,Zone2A.Internal.SafeOutput.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","Zone2A","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(Zone2A.Status.EStopStatus)","8"
RCOMMENT,"SafetyProgram","Zone2A","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(Zone2ASafetyExpansion2)","9"
RCOMMENT,"SafetyProgram","Zone2B","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","OTE(Zone2B.Status.InputStatus)","0"
RCOMMENT,"SafetyProgram","Zone2B","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****","OTE(Zone2B.Status.EStopsUp)","1"
RCOMMENT,"SafetyProgram","Zone2B","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(Zone2B.Internal.EStopOkTmr,?,?)","2"
RCOMMENT,"SafetyProgram","Zone2B","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(Zone2B.Internal.EStopDelayTmr,?,?)","3"
RCOMMENT,"SafetyProgram","Zone2B","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(Zone2B.Internal.Feedback)","4"
RCOMMENT,"SafetyProgram","Zone2B","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(Zone2B.Internal.FeedbackStatus)","5"
RCOMMENT,"SafetyProgram","Zone2B","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(Zone2B.Internal.SafeOutput,POSITIVE,1000,Zone2B.Internal.EStopOkTmr.DN,Zone2B.Internal.Feedback,Zone2B.Internal.Feedback,Zone2B.Internal.FeedbackStatus,Zone2BExpansionUnitStatus,Zone2B.Command.Reset)","6"
RCOMMENT,"SafetyProgram","Zone2B","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(Zone2B.Internal.SafeOutput.DiagnosticCode,Zone2B.Internal.SafeOutput.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","Zone2B","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(Zone2B.Status.EStopStatus)","8"
RCOMMENT,"SafetyProgram","Zone2B","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(Zone2BSafetyExpansion2)","9"
RCOMMENT,"SafetyProgram","Zone3A","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","OTE(Zone3A.Status.InputStatus)","0"
RCOMMENT,"SafetyProgram","Zone3A","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****","OTE(Zone3A.Status.EStopsUp)","1"
RCOMMENT,"SafetyProgram","Zone3A","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(Zone3A.Internal.EStopOkTmr,?,?)","2"
RCOMMENT,"SafetyProgram","Zone3A","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(Zone3A.Internal.EStopDelayTmr,?,?)","3"
RCOMMENT,"SafetyProgram","Zone3A","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(Zone3A.Internal.Feedback)","4"
RCOMMENT,"SafetyProgram","Zone3A","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(Zone3A.Internal.FeedbackStatus)","5"
RCOMMENT,"SafetyProgram","Zone3A","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(Zone3A.Internal.SafeOutput,POSITIVE,1000,Zone3A.Internal.EStopOkTmr.DN,Zone3A.Internal.Feedback,Zone3A.Internal.Feedback,Zone3A.Internal.FeedbackStatus,Zone3AExpansionUnitStatus,Zone3A.Command.Reset)","6"
RCOMMENT,"SafetyProgram","Zone3A","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(Zone3A.Internal.SafeOutput.DiagnosticCode,Zone3A.Internal.SafeOutput.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","Zone3A","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(Zone3A.Status.EStopStatus)","8"
RCOMMENT,"SafetyProgram","Zone3A","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(Zone3ASafetyExpansion2)","9"
RCOMMENT,"SafetyProgram","Zone3B","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","OTE(Zone3B.Status.InputStatus)","0"
RCOMMENT,"SafetyProgram","Zone3B","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****","OTE(Zone3B.Status.EStopsUp)","1"
RCOMMENT,"SafetyProgram","Zone3B","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(Zone3B.Internal.EStopOkTmr,?,?)","2"
RCOMMENT,"SafetyProgram","Zone3B","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(Zone3B.Internal.EStopDelayTmr,?,?)","3"
RCOMMENT,"SafetyProgram","Zone3B","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(Zone3B.Internal.Feedback)","4"
RCOMMENT,"SafetyProgram","Zone3B","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(Zone3B.Internal.FeedbackStatus)","5"
RCOMMENT,"SafetyProgram","Zone3B","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(Zone3B.Internal.SafeOutput,POSITIVE,1000,Zone3B.Internal.EStopOkTmr.DN,Zone3B.Internal.Feedback,Zone3B.Internal.Feedback,Zone3B.Internal.FeedbackStatus,Zone3BExpansionUnitStatus,Zone3B.Command.Reset)","6"
RCOMMENT,"SafetyProgram","Zone3B","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(Zone3B.Internal.SafeOutput.DiagnosticCode,Zone3B.Internal.SafeOutput.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","Zone3B","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(Zone3B.Status.EStopStatus)","8"
RCOMMENT,"SafetyProgram","Zone3B","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(Zone3BSafetyExpansion2)","9"
RCOMMENT,"SafetyProgram","Zone4A","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","OTE(Zone4A.Status.InputStatus)","0"
RCOMMENT,"SafetyProgram","Zone4A","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****","OTE(Zone4A.Status.EStopsUp)","1"
RCOMMENT,"SafetyProgram","Zone4A","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(Zone4A.Internal.EStopOkTmr,?,?)","2"
RCOMMENT,"SafetyProgram","Zone4A","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(Zone4A.Internal.EStopDelayTmr,?,?)","3"
RCOMMENT,"SafetyProgram","Zone4A","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(Zone4A.Internal.Feedback)","4"
RCOMMENT,"SafetyProgram","Zone4A","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(Zone4A.Internal.FeedbackStatus)","5"
RCOMMENT,"SafetyProgram","Zone4A","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(Zone4A.Internal.SafeOutput,POSITIVE,1000,Zone4A.Internal.EStopOkTmr.DN,Zone4A.Internal.Feedback,Zone4A.Internal.Feedback,Zone4A.Internal.FeedbackStatus,Zone4AExpansionUnitStatus,Zone4A.Command.Reset)","6"
RCOMMENT,"SafetyProgram","Zone4A","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(Zone4A.Internal.SafeOutput.DiagnosticCode,Zone4A.Internal.SafeOutput.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","Zone4A","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(Zone4A.Status.EStopStatus)","8"
RCOMMENT,"SafetyProgram","Zone4A","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(Zone4ASafetyExpansion2)","9"
RCOMMENT,"SafetyProgram","Zone4B","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","OTE(Zone4B.Status.InputStatus)","0"
RCOMMENT,"SafetyProgram","Zone4B","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****","OTE(Zone4B.Status.EStopsUp)","1"
RCOMMENT,"SafetyProgram","Zone4B","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(Zone4B.Internal.EStopOkTmr,?,?)","2"
RCOMMENT,"SafetyProgram","Zone4B","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(Zone4B.Internal.EStopDelayTmr,?,?)","3"
RCOMMENT,"SafetyProgram","Zone4B","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(Zone4B.Internal.Feedback)","4"
RCOMMENT,"SafetyProgram","Zone4B","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(Zone4B.Internal.FeedbackStatus)","5"
RCOMMENT,"SafetyProgram","Zone4B","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(Zone4B.Internal.SafeOutput,POSITIVE,1000,Zone4B.Internal.EStopOkTmr.DN,Zone4B.Internal.Feedback,Zone4B.Internal.Feedback,Zone4B.Internal.FeedbackStatus,Zone4BExpansionUnitStatus,Zone4B.Command.Reset)","6"
RCOMMENT,"SafetyProgram","Zone4B","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(Zone4B.Internal.SafeOutput.DiagnosticCode,Zone4B.Internal.SafeOutput.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","Zone4B","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(Zone4B.Status.EStopStatus)","8"
RCOMMENT,"SafetyProgram","Zone4B","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(Zone4BSafetyExpansion2)","9"
RCOMMENT,"SafetyProgram","Zone5A","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","OTE(Zone5A.Status.InputStatus)","0"
RCOMMENT,"SafetyProgram","Zone5A","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****","OTE(Zone5A.Status.EStopsUp)","1"
RCOMMENT,"SafetyProgram","Zone5A","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(Zone5A.Internal.EStopOkTmr,?,?)","2"
RCOMMENT,"SafetyProgram","Zone5A","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(Zone5A.Internal.EStopDelayTmr,?,?)","3"
RCOMMENT,"SafetyProgram","Zone5A","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(Zone5A.Internal.Feedback)","4"
RCOMMENT,"SafetyProgram","Zone5A","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(Zone5A.Internal.FeedbackStatus)","5"
RCOMMENT,"SafetyProgram","Zone5A","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(Zone5A.Internal.SafeOutput,POSITIVE,1000,Zone5A.Internal.EStopOkTmr.DN,Zone5A.Internal.Feedback,Zone5A.Internal.Feedback,Zone5A.Internal.FeedbackStatus,Zone5AExpansionUnitStatus,Zone5A.Command.Reset)","6"
RCOMMENT,"SafetyProgram","Zone5A","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(Zone5A.Internal.SafeOutput.DiagnosticCode,Zone5A.Internal.SafeOutput.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","Zone5A","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(Zone5A.Status.EStopStatus)","8"
RCOMMENT,"SafetyProgram","Zone5A","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(Zone5ASafetyExpansion2)","9"
RCOMMENT,"SafetyProgram","Zone5B","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","OTE(Zone5B.Status.InputStatus)","0"
RCOMMENT,"SafetyProgram","Zone5B","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****","OTE(Zone5B.Status.EStopsUp)","1"
RCOMMENT,"SafetyProgram","Zone5B","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(Zone5B.Internal.EStopOkTmr,?,?)","2"
RCOMMENT,"SafetyProgram","Zone5B","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(Zone5B.Internal.EStopDelayTmr,?,?)","3"
RCOMMENT,"SafetyProgram","Zone5B","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(Zone5B.Internal.Feedback)","4"
RCOMMENT,"SafetyProgram","Zone5B","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(Zone5B.Internal.FeedbackStatus)","5"
RCOMMENT,"SafetyProgram","Zone5B","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(Zone5B.Internal.SafeOutput,POSITIVE,1000,Zone5B.Internal.EStopOkTmr.DN,Zone5B.Internal.Feedback,Zone5B.Internal.Feedback,Zone5B.Internal.FeedbackStatus,Zone5BExpansionUnitStatus,Zone5B.Command.Reset)","6"
RCOMMENT,"SafetyProgram","Zone5B","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(Zone5B.Internal.SafeOutput.DiagnosticCode,Zone5B.Internal.SafeOutput.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","Zone5B","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(Zone5B.Status.EStopStatus)","8"
RCOMMENT,"SafetyProgram","Zone5B","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(Zone5BSafetyExpansion2)","9"
RCOMMENT,"SafetyProgram","Zone6","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","OTE(Zone6.Status.InputStatus)","0"
RCOMMENT,"SafetyProgram","Zone6","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****","OTE(Zone6.Status.EStopsUp)","1"
RCOMMENT,"SafetyProgram","Zone6","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(Zone6.Internal.EStopOkTmr,?,?)","2"
RCOMMENT,"SafetyProgram","Zone6","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(Zone6.Internal.EStopDelayTmr,?,?)","3"
RCOMMENT,"SafetyProgram","Zone6","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(Zone6.Internal.Feedback)","4"
RCOMMENT,"SafetyProgram","Zone6","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(Zone6.Internal.FeedbackStatus)","5"
RCOMMENT,"SafetyProgram","Zone6","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(Zone6.Internal.SafeOutput,POSITIVE,1000,Zone6.Internal.EStopOkTmr.DN,Zone6.Internal.Feedback,Zone6.Internal.Feedback,Zone6.Internal.FeedbackStatus,Zone6ExpansionUnitStatus,Zone6.Command.Reset)","6"
RCOMMENT,"SafetyProgram","Zone6","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(Zone6.Internal.SafeOutput.DiagnosticCode,Zone6.Internal.SafeOutput.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","Zone6","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(Zone6.Status.EStopStatus)","8"
RCOMMENT,"SafetyProgram","Zone6","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(Zone6SafetyExpansion2)","9"
RCOMMENT,"SafetyProgram","Zone7","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","OTE(Zone7.Status.InputStatus)","0"
RCOMMENT,"SafetyProgram","Zone7","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****","OTE(Zone7.Status.EStopsUp)","1"
RCOMMENT,"SafetyProgram","Zone7","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(Zone7.Internal.EStopOkTmr,?,?)","2"
RCOMMENT,"SafetyProgram","Zone7","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(Zone7.Internal.EStopDelayTmr,?,?)","3"
RCOMMENT,"SafetyProgram","Zone7","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(Zone7.Internal.Feedback)","4"
RCOMMENT,"SafetyProgram","Zone7","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(Zone7.Internal.FeedbackStatus)","5"
RCOMMENT,"SafetyProgram","Zone7","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(Zone7.Internal.SafeOutput,POSITIVE,1000,Zone7.Internal.EStopOkTmr.DN,Zone7.Internal.Feedback,Zone7.Internal.Feedback,Zone7.Internal.FeedbackStatus,Zone7ExpansionUnitStatus,Zone7.Command.Reset)","6"
RCOMMENT,"SafetyProgram","Zone7","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(Zone7.Internal.SafeOutput.DiagnosticCode,Zone7.Internal.SafeOutput.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","Zone7","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(Zone7.Status.EStopStatus)","8"
RCOMMENT,"SafetyProgram","Zone7","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(Zone7SafetyExpansion2)","9"
RCOMMENT,"SafetyProgram","Zone8","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","OTE(Zone8.Status.InputStatus)","0"
RCOMMENT,"SafetyProgram","Zone8","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****","OTE(Zone8.Status.EStopsUp)","1"
RCOMMENT,"SafetyProgram","Zone8","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(Zone8.Internal.EStopOkTmr,?,?)","2"
RCOMMENT,"SafetyProgram","Zone8","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(Zone8.Internal.EStopDelayTmr,?,?)","3"
RCOMMENT,"SafetyProgram","Zone8","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(Zone8.Internal.Feedback)","4"
RCOMMENT,"SafetyProgram","Zone8","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(Zone8.Internal.FeedbackStatus)","5"
RCOMMENT,"SafetyProgram","Zone8","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(Zone8.Internal.SafeOutput,POSITIVE,1000,Zone8.Internal.EStopOkTmr.DN,Zone8.Internal.Feedback,Zone8.Internal.Feedback,Zone8.Internal.FeedbackStatus,Zone8ExpansionUnitStatus,Zone8.Command.Reset)","6"
RCOMMENT,"SafetyProgram","Zone8","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(Zone8.Internal.SafeOutput.DiagnosticCode,Zone8.Internal.SafeOutput.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","Zone8","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(Zone8.Status.EStopStatus)","8"
RCOMMENT,"SafetyProgram","Zone8","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(Zone8SafetyExpansion2)","9"
RCOMMENT,"SafetyProgram","Zone9","****$NSome zones have inputs that are not global e-stops.  They will$Naffect this zone only.$N****","OTE(Zone9.Status.InputStatus)","0"
RCOMMENT,"SafetyProgram","Zone9","****$NThe zone E-Stop up is reset and latched in when the global E-Stops are$Nup and the individual E-Stops are up.  Either will drop out the status.$N****","OTE(Zone9.Status.EStopsUp)","1"
RCOMMENT,"SafetyProgram","Zone9","****$NWhen a safe state is activated above the TOF serves as a delay$Nbefore the safety outputs are dropped out.  This time is the $Qfast stop$Q time$Neven if the inputs come back.$N****","TOF(Zone9.Internal.EStopOkTmr,?,?)","2"
RCOMMENT,"SafetyProgram","Zone9","****$NThe delay timer prevents the E-Stop from re-energizing too soon.$NIt must stay dropped out for this amount of time.$N****","TON(Zone9.Internal.EStopDelayTmr,?,?)","3"
RCOMMENT,"SafetyProgram","Zone9","****$NThe feedback string is all the monitored devices for this zone.$NThe coil is used below in the CROUT instructioin.$N****","OTE(Zone9.Internal.Feedback)","4"
RCOMMENT,"SafetyProgram","Zone9","****$NThe feedback status is the status inputs from the device monitors$NThe coil is used below in the CROUT instruction.$N****","OTE(Zone9.Internal.FeedbackStatus)","5"
RCOMMENT,"SafetyProgram","Zone9","****$NThe CROUT instruction controls the safety outputs for this zone.$NIt monitors the feedbacks of the monitored devices and verifies everything$Nis functioning properly before setting the outputs.$N****","CROUT(Zone9.Internal.SafeOutput,POSITIVE,1000,Zone9.Internal.EStopOkTmr.DN,Zone9.Internal.Feedback,Zone9.Internal.Feedback,Zone9.Internal.FeedbackStatus,Zone9ExpansionUnitStatus,Zone9.Command.Reset)","6"
RCOMMENT,"SafetyProgram","Zone9","****$NThe CROUT instruction will fault if the input parameters (feedbacks and statuses) don$'t do what they$'re$Nsupposed to.  Check the diagnostic/fault registers to determine the problem.$N****","MOV(Zone9.Internal.SafeOutput.DiagnosticCode,Zone9.Internal.SafeOutput.DiagnosticCode)","7"
RCOMMENT,"SafetyProgram","Zone9","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel one of this zone$'s outputs.$N****","OTE(Zone9.Status.EStopStatus)","8"
RCOMMENT,"SafetyProgram","Zone9","****$NThe CROUT instruction above controls the safety outputs.$NThis is channel two of this zone$'s outputs.$N****","OTE(Zone9SafetyExpansion2)","9"
RCOMMENT,"SafetyProgram","ZoneResets","****$NAll the zones are tied to one reset bit coming from the master reset (for now).$N****","OTE(ExitEquipmentZone.Internal.ResetInternal)","0"
RCOMMENT,"SafetyProgram","ZoneResets","****$NThis zone resets different ways.  It will reset with a normal reset, but also$Nwith a restart pushbutton that is mapped from the normal program.$N****","OTE(Zone1B.Internal.ResetInternal)","1"
RCOMMENT,"SafetyProgram","ZoneResets","****$NThis zone resets different ways.  It will reset with a normal reset, but also$Nwith a restart pushbutton that is mapped from the normal program.$N****","OTE(Zone2B.Internal.ResetInternal)","2"
RCOMMENT,"SafetyProgram","ZoneResets","****$NThis zone resets different ways.  It will reset with a normal reset, but also$Nwith a restart pushbutton that is mapped from the normal program.$N****","OTE(Zone3B.Internal.ResetInternal)","3"
RCOMMENT,"SafetyProgram","ZoneResets","****$NThis zone resets different ways.  It will reset with a normal reset, but also$Nwith a restart pushbutton that is mapped from the normal program.$N****","OTE(Zone4B.Internal.ResetInternal)","4"
RCOMMENT,"SafetyProgram","ZoneResets","****$NThis zone resets different ways.  It will reset with a normal reset, but also$Nwith a restart pushbutton that is mapped from the normal program.$N****","OTE(Zone5B.Internal.ResetInternal)","5"
RCOMMENT,"SafetyProgram","ZoneResets","****$NThis is the reset for the instruction faults.$N****","OTE(SafetyAlarms.AlarmReset)","6"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"TrimHopper6","TH6Control","****$NPermissive to Operate Manually$N****","OTE(TH6.Internal.Permissive)","0"
RCOMMENT,"TrimHopper6","TH6Control","****$NEnable the Hopper for Operation$N****","OTU(TH6.Command.Enable)","1"
RCOMMENT,"TrimHopper6","TH6Control","****$NDisable the Hopper$N****","OTU(TH6.Command.Disable)","2"
RCOMMENT,"TrimHopper6","TH6Control","****$NDisable the hopper if it is neither enabled or disabled.$N****","OTL(TH6.Status.Disabled)","3"
RCOMMENT,"TrimHopper6","TH6Control","****$NIf the blend line is not running or the hopper is not enabled, enable manual controls.$N****","OTE(TH6.Internal.EnableManualControls)","4"
RCOMMENT,"TrimHopper6","TH6Control","****$NCheck the setpoint against limits$N****","SUB(TH6.Command.WeightSetpoint,TH6.Command.AnticipationWeight,TH6.Internal.StopWeight)","5"
RCOMMENT,"TrimHopper6","TH6Control","****$NScale the analog input to determine weight.$N****","MOV(TH6.Internal.WeightScaler.ScaledOutput,TH6.Status.CurrentWeight)","6"
RCOMMENT,"TrimHopper6","TH6Control","****$NWhen the blend line is in weigh mode, the lift apron slows when the weight gets$Nabove the slow down ratio.$N****","OTE(TH6.Status.SlowDownActive)","7"
RCOMMENT,"TrimHopper6","TH6Control","****$NWhen the blend line is in weigh mode the lift apron stops$Nand the door closes when the pan reaches setpoint.$N****","OTL(TH6.Status.WeightSetpointReached)","8"
RCOMMENT,"TrimHopper6","TH6Control","****$NSet up the values for the upper and lower weights that will cause an alarm$N(OUT OF TOLERANCE VALUES)$N****","SUB(TH6.Command.WeightSetpoint,TH6.Internal.WeightAlarmValue,TH6.Status.AlarmWeightLowerWindow)","9"
RCOMMENT,"TrimHopper6","TH6Control","****$NWhen the settling timer is done, shift the array numbers down and move the latest$Nweight into array 9.  Array 9 will be the latest value. 8 will be previous then 7, etc.$N****","OTL(TH6.Status.LowWeightAlarm)","10"
RCOMMENT,"TrimHopper6","TH6Control","****$NReset the setpoint reached bit.$N****","OTU(TH6.Status.WeightSetpointReached)","11"
RCOMMENT,"TrimHopper6","TH6Control","****$NThe photoeye should control the extended apron.  If the lift apron is running for too long$Nwithout anything blocking the eye, there is a problem.  Perhaps the hopper is empty.$N****","OTE(TH6.Internal.HopperPETooLong)","12"
RCOMMENT,"TrimHopper6","TH6Control","****$NHopper filling status.$N****","OTE(TH6.Status.Filling)","13"
RCOMMENT,"TrimHopper6","TH6Control","****$NIf the weight is not reached in a certain amount of time...alarm.$N****","TON(TH6FillTooLongTmr,?,?)","14"
RCOMMENT,"TrimHopper6","TH6Control","****$NGeneral alarm for HMI display.$N****","OTE(TH6.Status.WeightAlarm)","15"
RCOMMENT,"TrimHopper6","TH6Control","****$NReset the alarm latches.$N****","OTU(TH6.Status.LowWeightAlarm)","16"
RCOMMENT,"TrimHopper6","TH6Control","****$NThe RunLiftAprons bit comes from the blend control routine.$NAfter the appropriate drives are running and the call for fiber is on, this$Nbit comes on.  If the hopper is enabled, run the lift apron.$N****","OTE(TH6.Internal.RunLiftApron)","17"
RCOMMENT,"TrimHopper6","TH6Damper","****$NPermissive to operate$N****","OTE(TH6Damper.Internal.Permissive)","0"
RCOMMENT,"TrimHopper6","TH6Damper","****$NSolenoid to Automatic Mode$N****","OTU(TH6Damper.Command.ToAuto)","1"
RCOMMENT,"TrimHopper6","TH6Damper","****$NSolenoid to Manua Mode$N****","OTU(TH6Damper.Command.ToManual)","2"
RCOMMENT,"TrimHopper6","TH6Damper","****$NIf the solenoid is not in either mode, put in manual mode.$N****","OTL(TH6Damper.Status.InManual)","3"
RCOMMENT,"TrimHopper6","TH6Damper","****$NManual Run Control$N****","OTE(TH6Damper.Internal.ManualOpen)","4"
RCOMMENT,"TrimHopper6","TH6Damper","****$NAutomatic mode controls.$N****","TOF(TH6Damper.Internal.DelayCloseTimer,?,?)","5"
RCOMMENT,"TrimHopper6","TH6Damper","****$NControl of the solenoid.$N****","OTE(TH6Damper.Internal.IntermediateOpen)","6"
RCOMMENT,"TrimHopper6","TH6Damper","****$NIf not open command, then close command.$N****","OTE(TH6WeighPnDamperCloseSol)","7"
RCOMMENT,"TrimHopper6","TH6Damper","****$NOpen Status$N****","OTE(TH6Damper.Status.Open)","8"
RCOMMENT,"TrimHopper6","TH6Damper","****$NClosed Status$N****","OTE(TH6Damper.Status.Closed)","9"
RCOMMENT,"TrimHopper6","TH6Doffer","****$NPermissive to operate the motor.$N****","OTE(TH6Doffer.Internal.Permissive)","0"
RCOMMENT,"TrimHopper6","TH6Doffer","****$NManual Run Control$N****","OTE(TH6Doffer.Internal.IntermediateRunForward)","1"
RCOMMENT,"TrimHopper6","TH6Doffer","****$NManual Jog Control$N****","OTE(TH6Doffer.Internal.IntermediateJogForward)","2"
RCOMMENT,"TrimHopper6","TH6Doffer","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(TH6Doffer.Internal.AutoOffDelayTimer,?,?)","3"
RCOMMENT,"TrimHopper6","TH6Doffer","****$NIf the permissive is lost, reset the TOF for immediate stop.$N****","RES(TH6Doffer.Internal.AutoOffDelayTimer)","4"
RCOMMENT,"TrimHopper6","TH6Doffer","****$NMotor Starter Control$N****","OTE(TH6DofferCont)","5"
RCOMMENT,"TrimHopper6","TH6Doffer","****$NRunning Status$N****","OTE(TH6Doffer.Status.RunningForward)","6"
RCOMMENT,"TrimHopper6","TH6Doffer","****$NIf the motor does not start when commanded, it has failed to run$N****","OTL(TH6Doffer.Status.FailedToStart)","7"
RCOMMENT,"TrimHopper6","TH6Doffer","****$NIf a motor continues to run when the run command has been removed,$Nit has failed to stop.$N****$N","OTL(TH6Doffer.Status.FailedToStop)","8"
RCOMMENT,"TrimHopper6","TH6Doffer","****$NGeneral Faulted Status$N****","OTE(TH6Doffer.Status.Faulted)","9"
RCOMMENT,"TrimHopper6","TH6Doffer","****$NReset Fault Latches$N****","OTU(TH6Doffer.Status.FailedToStop)","10"
RCOMMENT,"TrimHopper6","TH6Doors","****$NThe permissive to lock is delayed by the timer.$N****","OTE(TH6DoorLocks.Internal.LockPermissive)","0"
RCOMMENT,"TrimHopper6","TH6Doors","****$NThe permissive to unlock is delayed by the timer.$N****","OTE(TH6DoorLocks.Internal.UnlockPermissive)","1"
RCOMMENT,"TrimHopper6","TH6Doors","****$NThe unlock command works if the permissive above is satisfied.$N****","OTE(TH6DoorLocks.Internal.IntermediateUnlock)","2"
RCOMMENT,"TrimHopper6","TH6Doors","****$NStatus for the HMI$N****","OTE(TH6DoorLocks.Status.Locked)","3"
RCOMMENT,"TrimHopper6","TH6Doors","****$NStatus for the HMI$N****","OTE(TH6DoorLocks.Status.Unlocked)","4"
RCOMMENT,"TrimHopper6","TH6Doors","****$NFire the Outputs$N****","OTE(TH6RightAccessDoorReleaseSol)","5"
RCOMMENT,"TrimHopper6","TH6Dump","****$NPermissive to operate$N****","OTE(TH6Dump.Internal.Permissive)","0"
RCOMMENT,"TrimHopper6","TH6Dump","****$NSolenoid to Automatic Mode$N****","OTU(TH6Dump.Command.ToAuto)","1"
RCOMMENT,"TrimHopper6","TH6Dump","****$NSolenoid to Manua Mode$N****","OTU(TH6Dump.Command.ToManual)","2"
RCOMMENT,"TrimHopper6","TH6Dump","****$NIf the solenoid is not in either mode, put in manual mode.$N****","OTL(TH6Dump.Status.InManual)","3"
RCOMMENT,"TrimHopper6","TH6Dump","****$NManual Run Control$N****","OTE(TH6Dump.Internal.ManualOpen)","4"
RCOMMENT,"TrimHopper6","TH6Dump","****$NAutomatic mode controls.$N****","TOF(TH6Dump.Internal.DelayOpenTimer,?,?)","5"
RCOMMENT,"TrimHopper6","TH6Dump","****$NControl of the solenoid.$N****","OTE(TH6Dump.Status.Open)","6"
RCOMMENT,"TrimHopper6","TH6Dump","****$NOpen Status$N****","OTE(TH6Dump.Status.Closed)","7"
RCOMMENT,"TrimHopper6","TH6LiftApron","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(TH6LiftApron.Internal.Permissive)","0"
RCOMMENT,"TrimHopper6","TH6LiftApron","****$NJog Command$N****","OTE(TH6LiftApron.Internal.IntermediateJog)","1"
RCOMMENT,"TrimHopper6","TH6LiftApron","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(TH6LiftApron.Internal.DriveReverse)","2"
RCOMMENT,"TrimHopper6","TH6LiftApron","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(TH6LiftApron.Internal.MaintModeRun)","3"
RCOMMENT,"TrimHopper6","TH6LiftApron","****$NThis timer makes sure the doffer is running and up to speed$Nbefore the lfit apron starts.$N****","TON(TH6.Internal.DofferRunningTimer,?,?)","4"
RCOMMENT,"TrimHopper6","TH6LiftApron","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(TH6LiftApron.Internal.ReleaseRamp)","5"
RCOMMENT,"TrimHopper6","TH6LiftApron","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(TH6LiftApron.Internal.DecelTime,TH6LiftApron.Internal.DecelTime)","6"
RCOMMENT,"TrimHopper6","TH6LiftApron","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(TH6LiftApron.Internal.SpeedReference.ScaledOutput,TH6LiftApron:O.FreqCommand)","7"
RCOMMENT,"TrimHopper6","TH6LiftApron","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(TH6LiftApron:O.Start)","8"
RCOMMENT,"TrimHopper6","TH6LiftApron","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(TH6LiftApron:O.Stop)","9"
RCOMMENT,"TrimHopper6","TH6LiftApron","****$NThe reverse command is set above.$N****","OTE(TH6LiftApron:O.Reverse)","10"
RCOMMENT,"TrimHopper6","TH6LiftApron","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(TH6LiftApron:O.Forward)","11"
RCOMMENT,"TrimHopper6","TH6LiftApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(TH6LiftApron.Internal.ActualSpeedScaler.ScaledOutput,TH6LiftApron.Status.ActualSpeed)","12"
RCOMMENT,"TrimHopper6","TH6LiftApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(TH6LiftApron.Internal.LoadScaler.ScaledOutput,TH6LiftApron.Status.MotorLoad)","13"
RCOMMENT,"TrimHopper6","TH6LiftApron","****$NDrive Running Status$N****","OTE(TH6LiftApron.Status.Running)","14"
RCOMMENT,"TrimHopper6","TH6LiftApron","****$NJogging Forward Status$N****","OTE(TH6LiftApron.Status.JoggingFwd)","15"
RCOMMENT,"TrimHopper6","TH6LiftApron","****$NJogging Reverse Status$N****","OTE(TH6LiftApron.Status.JoggingRev)","16"
RCOMMENT,"TrimHopper6","TH6LiftApron","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(TH6LiftApron.Status.FailedToStart)","17"
RCOMMENT,"TrimHopper6","TH6LiftApron","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(TH6LiftApron.Status.FailedToStop)","18"
RCOMMENT,"TrimHopper6","TH6LiftApron","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(TH6LiftApron.Status.Faulted)","19"
RCOMMENT,"TrimHopper6","TH6LiftApron","****$NUnlatch the Drive Faulted Status$N****","OTU(TH6LiftApron.Status.FailedToStop)","20"
RCOMMENT,"TrimHopper6","TH6Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(TH6Control,0)","0"
RCOMMENT,"TrimHopper6","TH6Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(TH6Damper,0)","1"
RCOMMENT,"TrimHopper6","TH6Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(TH6Doffer,0)","2"
RCOMMENT,"TrimHopper6","TH6Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(TH6Doors,0)","3"
RCOMMENT,"TrimHopper6","TH6Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(TH6Dump,0)","4"
RCOMMENT,"TrimHopper6","TH6Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(TH6LiftApron,0)","5"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
RCOMMENT,"TrimHopper7","TH7Control","****$NPermissive to Operate Manually$N****","OTE(TH7.Internal.Permissive)","0"
RCOMMENT,"TrimHopper7","TH7Control","****$NEnable the Hopper for Operation$N****","OTU(TH7.Command.Enable)","1"
RCOMMENT,"TrimHopper7","TH7Control","****$NDisable the Hopper$N****","OTU(TH7.Command.Disable)","2"
RCOMMENT,"TrimHopper7","TH7Control","****$NDisable the hopper if it is neither enabled or disabled.$N****","OTL(TH7.Status.Disabled)","3"
RCOMMENT,"TrimHopper7","TH7Control","****$NIf the blend line is not running or the hopper is not enabled, enable manual controls.$N****","OTE(TH7.Internal.EnableManualControls)","4"
RCOMMENT,"TrimHopper7","TH7Control","****$NCheck the setpoint against limits$N****","SUB(TH7.Command.WeightSetpoint,TH7.Command.AnticipationWeight,TH7.Internal.StopWeight)","5"
RCOMMENT,"TrimHopper7","TH7Control","****$NScale the analog input to determine weight.$N****","MOV(TH7.Internal.WeightScaler.ScaledOutput,TH7.Status.CurrentWeight)","6"
RCOMMENT,"TrimHopper7","TH7Control","****$NWhen the blend line is in weigh mode, the lift apron slows when the weight gets$Nabove the slow down ratio.$N****","OTE(TH7.Status.SlowDownActive)","7"
RCOMMENT,"TrimHopper7","TH7Control","****$NWhen the blend line is in weigh mode the lift apron stops$Nand the door closes when the pan reaches setpoint.$N****","OTL(TH7.Status.WeightSetpointReached)","8"
RCOMMENT,"TrimHopper7","TH7Control","****$NSet up the values for the upper and lower weights that will cause an alarm$N(OUT OF TOLERANCE VALUES)$N****","SUB(TH7.Command.WeightSetpoint,TH7.Internal.WeightAlarmValue,TH7.Status.AlarmWeightLowerWindow)","9"
RCOMMENT,"TrimHopper7","TH7Control","****$NWhen the settling timer is done, shift the array numbers down and move the latest$Nweight into array 9.  Array 9 will be the latest value. 8 will be previous then 7, etc.$N****","OTL(TH7.Status.LowWeightAlarm)","10"
RCOMMENT,"TrimHopper7","TH7Control","****$NReset the setpoint reached bit.$N****","OTU(TH7.Status.WeightSetpointReached)","11"
RCOMMENT,"TrimHopper7","TH7Control","****$NThe photoeye should control the extended apron.  If the lift apron is running for too long$Nwithout anything blocking the eye, there is a problem.  Perhaps the hopper is empty.$N****","OTE(TH7.Internal.HopperPETooLong)","12"
RCOMMENT,"TrimHopper7","TH7Control","****$NHopper filling status.$N****","OTE(TH7.Status.Filling)","13"
RCOMMENT,"TrimHopper7","TH7Control","****$NIf the weight is not reached in a certain amount of time...alarm.$N****","TON(TH7FillTooLongTmr,?,?)","14"
RCOMMENT,"TrimHopper7","TH7Control","****$NGeneral alarm for HMI display.$N****","OTE(TH7.Status.WeightAlarm)","15"
RCOMMENT,"TrimHopper7","TH7Control","****$NReset the alarm latches.$N****","OTU(TH7.Status.LowWeightAlarm)","16"
RCOMMENT,"TrimHopper7","TH7Control","****$NThe RunLiftAprons bit comes from the blend control routine.$NAfter the appropriate drives are running and the call for fiber is on, this$Nbit comes on.  If the hopper is enabled, run the lift apron.$N****","OTE(TH7.Internal.RunLiftApron)","17"
RCOMMENT,"TrimHopper7","TH7Damper","****$NPermissive to operate$N****","OTE(TH7Damper.Internal.Permissive)","0"
RCOMMENT,"TrimHopper7","TH7Damper","****$NSolenoid to Automatic Mode$N****","OTU(TH7Damper.Command.ToAuto)","1"
RCOMMENT,"TrimHopper7","TH7Damper","****$NSolenoid to Manua Mode$N****","OTU(TH7Damper.Command.ToManual)","2"
RCOMMENT,"TrimHopper7","TH7Damper","****$NIf the solenoid is not in either mode, put in manual mode.$N****","OTL(TH7Damper.Status.InManual)","3"
RCOMMENT,"TrimHopper7","TH7Damper","****$NManual Run Control$N****","OTE(TH7Damper.Internal.ManualOpen)","4"
RCOMMENT,"TrimHopper7","TH7Damper","****$NAutomatic mode controls.$N****","TOF(TH7Damper.Internal.DelayCloseTimer,?,?)","5"
RCOMMENT,"TrimHopper7","TH7Damper","****$NControl of the solenoid.$N****","OTE(TH7Damper.Internal.IntermediateOpen)","6"
RCOMMENT,"TrimHopper7","TH7Damper","****$NIf not open command, then close command.$N****","OTE(TH7WeighPnDamperCloseSol)","7"
RCOMMENT,"TrimHopper7","TH7Damper","****$NOpen Status$N****","OTE(TH7Damper.Status.Open)","8"
RCOMMENT,"TrimHopper7","TH7Damper","****$NClosed Status$N****","OTE(TH7Damper.Status.Closed)","9"
RCOMMENT,"TrimHopper7","TH7Doffer","****$NPermissive to operate the motor.$N****","OTE(TH7Doffer.Internal.Permissive)","0"
RCOMMENT,"TrimHopper7","TH7Doffer","****$NManual Run Control$N****","OTE(TH7Doffer.Internal.IntermediateRunForward)","1"
RCOMMENT,"TrimHopper7","TH7Doffer","****$NManual Jog Control$N****","OTE(TH7Doffer.Internal.IntermediateJogForward)","2"
RCOMMENT,"TrimHopper7","TH7Doffer","****$NAutomatic Run Control with Start and Stop Delays.$N****","TOF(TH7Doffer.Internal.AutoOffDelayTimer,?,?)","3"
RCOMMENT,"TrimHopper7","TH7Doffer","****$NIf the permissive is lost, reset the TOF for immediate stop.$N****","RES(TH7Doffer.Internal.AutoOffDelayTimer)","4"
RCOMMENT,"TrimHopper7","TH7Doffer","****$NMotor Starter Control$N****","OTE(TH7DofferCont)","5"
RCOMMENT,"TrimHopper7","TH7Doffer","****$NRunning Status$N****","OTE(TH7Doffer.Status.RunningForward)","6"
RCOMMENT,"TrimHopper7","TH7Doffer","****$NIf the motor does not start when commanded, it has failed to run$N****","OTL(TH7Doffer.Status.FailedToStart)","7"
RCOMMENT,"TrimHopper7","TH7Doffer","****$NIf a motor continues to run when the run command has been removed,$Nit has failed to stop.$N****$N","OTL(TH7Doffer.Status.FailedToStop)","8"
RCOMMENT,"TrimHopper7","TH7Doffer","****$NGeneral Faulted Status$N****","OTE(TH7Doffer.Status.Faulted)","9"
RCOMMENT,"TrimHopper7","TH7Doffer","****$NReset Fault Latches$N****","OTU(TH7Doffer.Status.FailedToStop)","10"
RCOMMENT,"TrimHopper7","TH7Doors","****$NThe permissive to lock is delayed by the timer.$N****","OTE(TH7DoorLocks.Internal.LockPermissive)","0"
RCOMMENT,"TrimHopper7","TH7Doors","****$NThe permissive to unlock is delayed by the timer.$N****","OTE(TH7DoorLocks.Internal.UnlockPermissive)","1"
RCOMMENT,"TrimHopper7","TH7Doors","****$NThe unlock command works if the permissive above is satisfied.$N****","OTE(TH7DoorLocks.Internal.IntermediateUnlock)","2"
RCOMMENT,"TrimHopper7","TH7Doors","****$NStatus for the HMI$N****","OTE(TH7DoorLocks.Status.Locked)","3"
RCOMMENT,"TrimHopper7","TH7Doors","****$NStatus for the HMI$N****","OTE(TH7DoorLocks.Status.Unlocked)","4"
RCOMMENT,"TrimHopper7","TH7Doors","****$NFire the Outputs$N****","OTE(TH7RightAccessDoorReleaseSol)","5"
RCOMMENT,"TrimHopper7","TH7Dump","****$NPermissive to operate$N****","OTE(TH7Dump.Internal.Permissive)","0"
RCOMMENT,"TrimHopper7","TH7Dump","****$NSolenoid to Automatic Mode$N****","OTU(TH7Dump.Command.ToAuto)","1"
RCOMMENT,"TrimHopper7","TH7Dump","****$NSolenoid to Manua Mode$N****","OTU(TH7Dump.Command.ToManual)","2"
RCOMMENT,"TrimHopper7","TH7Dump","****$NIf the solenoid is not in either mode, put in manual mode.$N****","OTL(TH7Dump.Status.InManual)","3"
RCOMMENT,"TrimHopper7","TH7Dump","****$NManual Run Control$N****","OTE(TH7Dump.Internal.ManualClose)","4"
RCOMMENT,"TrimHopper7","TH7Dump","****$NAutomatic mode controls.$N****","TOF(TH7Dump.Internal.DelayOpenTimer,?,?)","5"
RCOMMENT,"TrimHopper7","TH7Dump","****$NControl of the solenoid.$N****","OTE(TH7Dump.Status.Open)","6"
RCOMMENT,"TrimHopper7","TH7Dump","****$NOpen Status$N****","OTE(TH7Dump.Status.Closed)","7"
RCOMMENT,"TrimHopper7","TH7LiftApron","****$NPermissives to Operate Drive in Maint Mode$N****","OTE(TH7LiftApron.Internal.Permissive)","0"
RCOMMENT,"TrimHopper7","TH7LiftApron","****$NJog Command$N****","OTE(TH7LiftApron.Internal.IntermediateJog)","1"
RCOMMENT,"TrimHopper7","TH7LiftApron","****$NHold in the reverse command until the drive returns to stopped state.$N****","OTE(TH7LiftApron.Internal.DriveReverse)","2"
RCOMMENT,"TrimHopper7","TH7LiftApron","****$NIf the line is in maintenance mode, the drive may be started and stopped$Nindividually.$N****","OTE(TH7LiftApron.Internal.MaintModeRun)","3"
RCOMMENT,"TrimHopper7","TH7LiftApron","****$NThis timer makes sure the doffer is running and up to speed$Nbefore the lfit apron starts.$N****","TON(TH6.Internal.DofferRunningTimer,?,?)","4"
RCOMMENT,"TrimHopper7","TH7LiftApron","****$NWhen the drive is commanded to start, release the ramp.$N****","OTE(TH7LiftApron.Internal.ReleaseRamp)","5"
RCOMMENT,"TrimHopper7","TH7LiftApron","****$NThe commanded speed is based on the operating mode of the blend line.$N****","MOV(TH7LiftApron.Internal.DecelTime,TH7LiftApron.Internal.DecelTime)","6"
RCOMMENT,"TrimHopper7","TH7LiftApron","****$NThe drive ramp will ramp the drive speed reference.$NThe scale will scale the reference from engineering units to a raw value$Nfor the analog output.$N****","MOV(TH7LiftApron.Internal.SpeedReference.ScaledOutput,TH7LiftApron:O.FreqCommand)","7"
RCOMMENT,"TrimHopper7","TH7LiftApron","****$NWhen the ramp is outputting a signal that is greater than 0, start the drive.$NAll the interlocking is done above the ramp.$N****","OTE(TH7LiftApron:O.Start)","8"
RCOMMENT,"TrimHopper7","TH7LiftApron","****$NIf the drive is not being told to start, it should be told to stop.$N****","OTE(TH7LiftApron:O.Stop)","9"
RCOMMENT,"TrimHopper7","TH7LiftApron","****$NThe reverse command is set above.$N****","OTE(TH7LiftApron:O.Reverse)","10"
RCOMMENT,"TrimHopper7","TH7LiftApron","****$NIf the drive is not being told to reverse, it should be told to go forward.$N****","OTE(TH7LiftApron:O.Forward)","11"
RCOMMENT,"TrimHopper7","TH7LiftApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(TH7LiftApron.Internal.ActualSpeedScaler.ScaledOutput,TH7LiftApron.Status.ActualSpeed)","12"
RCOMMENT,"TrimHopper7","TH7LiftApron","****$NScale the raw signal coming from the drive$Nto engineering units for display on the HMI.$N****","MOV(TH7LiftApron.Internal.LoadScaler.ScaledOutput,TH7LiftApron.Status.MotorLoad)","13"
RCOMMENT,"TrimHopper7","TH7LiftApron","****$NDrive Running Status$N****","OTE(TH7LiftApron.Status.Running)","14"
RCOMMENT,"TrimHopper7","TH7LiftApron","****$NJogging Forward Status$N****","OTE(TH7LiftApron.Status.JoggingFwd)","15"
RCOMMENT,"TrimHopper7","TH7LiftApron","****$NJogging Reverse Status$N****","OTE(TH7LiftApron.Status.JoggingRev)","16"
RCOMMENT,"TrimHopper7","TH7LiftApron","****$NIf the drive is being told to run but does not after a certain time$Nit has failed to start.$N****","OTL(TH7LiftApron.Status.FailedToStart)","17"
RCOMMENT,"TrimHopper7","TH7LiftApron","****$NIf the drive runs when it is not being told to, it has failed to stop.$N****","OTL(TH7LiftApron.Status.FailedToStop)","18"
RCOMMENT,"TrimHopper7","TH7LiftApron","****$NDrive Faulted Status$NThe faulted status is in the permissive and will stop the drive.$N****","OTL(TH7LiftApron.Status.Faulted)","19"
RCOMMENT,"TrimHopper7","TH7LiftApron","****$NUnlatch the Drive Faulted Status$N****","OTU(TH7LiftApron.Status.FailedToStop)","20"
RCOMMENT,"TrimHopper7","TH7Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(TH7Control,0)","0"
RCOMMENT,"TrimHopper7","TH7Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(TH7Damper,0)","1"
RCOMMENT,"TrimHopper7","TH7Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(TH7Doffer,0)","2"
RCOMMENT,"TrimHopper7","TH7Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(TH7Doors,0)","3"
RCOMMENT,"TrimHopper7","TH7Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(TH7Dump,0)","4"
RCOMMENT,"TrimHopper7","TH7Main","****$NUse the main routine to call the other routines in the program.$N****","JSR(TH7LiftApron,0)","5"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
TEXTBOX,"DriveRamp:AOI","Logic","The drive has its individual ramp.  The accel and decel rates are in seconds, and can$Nbe manipulated outside of the instruction.","","20:20:Sheet1"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
TEXTBOX,"LadderScale:AOI","Logic","This Add-On instruction is simply a scale block that will be used in ladder instructions.","","380:60:Sheet1"
TYPE,SCOPE,ROUTINE,COMMENT,OWNING_ELEMENT,LOCATION
TEXTBOX,"LineSpeedRamp:AOI","Logic","When the RampEnable is on, the reference is sent to the s-curve and ramped at the appropriate rate.$NAs long is there is no e-stop, the normal accel/decel rates are used.  In the event of an e-stop, the e-stop decel rate$Nis used to ramp the reference down as quickly as possible.  The zero speed bit lets us know the reference has ramped to$Nzero and the line is ready to stop.","","20:20:Sheet1"
TEXTBOX,"LineSpeedRamp:AOI","Logic","The Hold ramp will stop the s-cruve from ramping and freeze the output.","","680:780:Sheet1"
